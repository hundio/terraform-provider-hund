// Package hundApiV1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package hundApiV1

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicScopes  = "basic.Scopes"
	BearerScopes = "bearer.Scopes"
)

// Defines values for BuiltinType.
const (
	BuiltinTypeBuiltin BuiltinType = "builtin"
)

// Defines values for BuiltinFormCreateType.
const (
	BuiltinFormCreateTypeBuiltin BuiltinFormCreateType = "builtin"
)

// Defines values for CLOUDWATCHREGION.
const (
	ApNortheast1 CLOUDWATCHREGION = "ap-northeast-1"
	ApSoutheast1 CLOUDWATCHREGION = "ap-southeast-1"
	ApSoutheast2 CLOUDWATCHREGION = "ap-southeast-2"
	EuCentral1   CLOUDWATCHREGION = "eu-central-1"
	EuWest1      CLOUDWATCHREGION = "eu-west-1"
	SaEast1      CLOUDWATCHREGION = "sa-east-1"
	UsEast1      CLOUDWATCHREGION = "us-east-1"
	UsWest1      CLOUDWATCHREGION = "us-west-1"
	UsWest2      CLOUDWATCHREGION = "us-west-2"
)

// Defines values for CloudwatchType.
const (
	CloudwatchTypeCloudwatch CloudwatchType = "cloudwatch"
)

// Defines values for CloudwatchFormCreateType.
const (
	CloudwatchFormCreateTypeCloudwatch CloudwatchFormCreateType = "cloudwatch"
)

// Defines values for ComponentType.
const (
	ComponentTypeComponent ComponentType = "component"
)

// Defines values for ComponentExpansionaryType.
const (
	ComponentExpansionaryTypeComponent ComponentExpansionaryType = "component"
)

// Defines values for ComponentExpansionaryPagedArrayType.
const (
	ComponentExpansionaryPagedArrayTypePagedArray ComponentExpansionaryPagedArrayType = "paged_array"
)

// Defines values for ComponentPagedArrayType.
const (
	ComponentPagedArrayTypePagedArray ComponentPagedArrayType = "paged_array"
)

// Defines values for DNSMethod.
const (
	DNSMethodDns DNSMethod = "dns"
)

// Defines values for DNSType.
const (
	DNSTypeNative DNSType = "native"
)

// Defines values for DNSFormCreateMethod.
const (
	DNSFormCreateMethodDns DNSFormCreateMethod = "dns"
)

// Defines values for DNSFormCreateResponseContainment.
const (
	DNSFormCreateResponseContainmentAll DNSFormCreateResponseContainment = "all"
	DNSFormCreateResponseContainmentAny DNSFormCreateResponseContainment = "any"
)

// Defines values for DNSFormCreateType.
const (
	DNSFormCreateTypeNative DNSFormCreateType = "native"
)

// Defines values for GroupType.
const (
	GroupTypeGroup GroupType = "group"
)

// Defines values for GroupPagedArrayType.
const (
	GroupPagedArrayTypePagedArray GroupPagedArrayType = "paged_array"
)

// Defines values for HTTPMethod.
const (
	HTTPMethodHttp HTTPMethod = "http"
)

// Defines values for HTTPType.
const (
	HTTPTypeNative HTTPType = "native"
)

// Defines values for HTTPFormCreateMethod.
const (
	HTTPFormCreateMethodHttp HTTPFormCreateMethod = "http"
)

// Defines values for HTTPFormCreateResponseBodyMustContainMode.
const (
	HTTPFormCreateResponseBodyMustContainModeExact HTTPFormCreateResponseBodyMustContainMode = "exact"
	HTTPFormCreateResponseBodyMustContainModeRegex HTTPFormCreateResponseBodyMustContainMode = "regex"
)

// Defines values for HTTPFormCreateType.
const (
	HTTPFormCreateTypeNative HTTPFormCreateType = "native"
)

// Defines values for ICMPMethod.
const (
	ICMPMethodIcmp ICMPMethod = "icmp"
)

// Defines values for ICMPType.
const (
	ICMPTypeNative ICMPType = "native"
)

// Defines values for ICMPFormCreateIpVersion.
const (
	ICMPFormCreateIpVersionInet  ICMPFormCreateIpVersion = "inet"
	ICMPFormCreateIpVersionInet6 ICMPFormCreateIpVersion = "inet6"
)

// Defines values for ICMPFormCreateMethod.
const (
	ICMPFormCreateMethodIcmp ICMPFormCreateMethod = "icmp"
)

// Defines values for ICMPFormCreateType.
const (
	ICMPFormCreateTypeNative ICMPFormCreateType = "native"
)

// Defines values for ISSUELABEL.
const (
	ISSUELABELAssessed      ISSUELABEL = "assessed"
	ISSUELABELIdentified    ISSUELABEL = "identified"
	ISSUELABELInformational ISSUELABEL = "informational"
	ISSUELABELInvestigating ISSUELABEL = "investigating"
	ISSUELABELMaintenance   ISSUELABEL = "maintenance"
)

// Defines values for ISSUEPRIORITY.
const (
	ISSUEPRIORITYMinus1 ISSUEPRIORITY = -1
	ISSUEPRIORITYN0     ISSUEPRIORITY = 0
	ISSUEPRIORITYN1     ISSUEPRIORITY = 1
)

// Defines values for ISSUESPECIALIZATION.
const (
	ISSUESPECIALIZATIONGeneral       ISSUESPECIALIZATION = "general"
	ISSUESPECIALIZATIONInformational ISSUESPECIALIZATION = "informational"
	ISSUESPECIALIZATIONMaintenance   ISSUESPECIALIZATION = "maintenance"
)

// Defines values for ISSUETEMPLATEKIND.
const (
	ISSUETEMPLATEKINDIssue  ISSUETEMPLATEKIND = "issue"
	ISSUETEMPLATEKINDUpdate ISSUETEMPLATEKIND = "update"
)

// Defines values for ISSUETEMPLATELABEL.
const (
	ISSUETEMPLATELABELAddendum      ISSUETEMPLATELABEL = "addendum"
	ISSUETEMPLATELABELAssessed      ISSUETEMPLATELABEL = "assessed"
	ISSUETEMPLATELABELIdentified    ISSUETEMPLATELABEL = "identified"
	ISSUETEMPLATELABELInformational ISSUETEMPLATELABEL = "informational"
	ISSUETEMPLATELABELInvestigating ISSUETEMPLATELABEL = "investigating"
	ISSUETEMPLATELABELMaintenance   ISSUETEMPLATELABEL = "maintenance"
	ISSUETEMPLATELABELMonitoring    ISSUETEMPLATELABEL = "monitoring"
	ISSUETEMPLATELABELResolved      ISSUETEMPLATELABEL = "resolved"
)

// Defines values for ISSUETEMPLATEVARIABLETYPE.
const (
	ISSUETEMPLATEVARIABLETYPEDatetime   ISSUETEMPLATEVARIABLETYPE = "datetime"
	ISSUETEMPLATEVARIABLETYPEI18nString ISSUETEMPLATEVARIABLETYPE = "i18n-string"
	ISSUETEMPLATEVARIABLETYPENumber     ISSUETEMPLATEVARIABLETYPE = "number"
	ISSUETEMPLATEVARIABLETYPEString     ISSUETEMPLATEVARIABLETYPE = "string"
)

// Defines values for IssueComponentsType.
const (
	IssueComponentsTypePagedArray IssueComponentsType = "paged_array"
)

// Defines values for IssueType.
const (
	IssueTypeIssue IssueType = "issue"
)

// Defines values for IssueUpdatesType.
const (
	IssueUpdatesTypePagedArray IssueUpdatesType = "paged_array"
)

// Defines values for IssueFormCreatePriority.
const (
	IssueFormCreatePriorityMinus1 IssueFormCreatePriority = -1
	IssueFormCreatePriorityN0     IssueFormCreatePriority = 0
	IssueFormCreatePriorityN1     IssueFormCreatePriority = 1
)

// Defines values for IssuePagedArrayType.
const (
	IssuePagedArrayTypePagedArray IssuePagedArrayType = "paged_array"
)

// Defines values for IssueTemplateType.
const (
	IssueTemplateTypeIssueTemplate IssueTemplateType = "issue_template"
)

// Defines values for IssueTemplateApplicationType.
const (
	IssueTemplateApplicationTypeIssueTemplateapplication IssueTemplateApplicationType = "issue_template/application"
)

// Defines values for IssueTemplateApplicationIssueType.
const (
	IssueTemplateApplicationIssueTypeIssueTemplateapplication IssueTemplateApplicationIssueType = "issue_template/application"
)

// Defines values for IssueTemplatePagedArrayType.
const (
	IssueTemplatePagedArrayTypePagedArray IssueTemplatePagedArrayType = "paged_array"
)

// Defines values for IssueTemplateVariableFormType.
const (
	IssueTemplateVariableFormTypeDatetime   IssueTemplateVariableFormType = "datetime"
	IssueTemplateVariableFormTypeI18nString IssueTemplateVariableFormType = "i18n-string"
	IssueTemplateVariableFormTypeNumber     IssueTemplateVariableFormType = "number"
	IssueTemplateVariableFormTypeString     IssueTemplateVariableFormType = "string"
)

// Defines values for METRICAGGREGATION.
const (
	Average METRICAGGREGATION = "average"
	First   METRICAGGREGATION = "first"
	Last    METRICAGGREGATION = "last"
	Max     METRICAGGREGATION = "max"
	Min     METRICAGGREGATION = "min"
	Sum     METRICAGGREGATION = "sum"
)

// Defines values for METRICAXISTYPE.
const (
	Measure METRICAXISTYPE = "measure"
	Time    METRICAXISTYPE = "time"
)

// Defines values for METRICINTERPOLATION.
const (
	Basis    METRICINTERPOLATION = "basis"
	Bundle   METRICINTERPOLATION = "bundle"
	Cardinal METRICINTERPOLATION = "cardinal"
	Linear   METRICINTERPOLATION = "linear"
	Step     METRICINTERPOLATION = "step"
)

// Defines values for METRICPLOTTYPE.
const (
	Bar  METRICPLOTTYPE = "bar"
	Line METRICPLOTTYPE = "line"
)

// Defines values for ManualType.
const (
	ManualTypeManual ManualType = "manual"
)

// Defines values for ManualFormCreateType.
const (
	ManualFormCreateTypeManual ManualFormCreateType = "manual"
)

// Defines values for MetricInstanceType.
const (
	MetricInstanceTypeMetricInstance MetricInstanceType = "metric_instance"
)

// Defines values for MetricProviderType.
const (
	MetricProviderTypeMetricProvider MetricProviderType = "metric_provider"
)

// Defines values for MetricProviderPagedArrayType.
const (
	MetricProviderPagedArrayTypePagedArray MetricProviderPagedArrayType = "paged_array"
)

// Defines values for NATIVEDNSRECORDTYPE.
const (
	A     NATIVEDNSRECORDTYPE = "A"
	AAAA  NATIVEDNSRECORDTYPE = "AAAA"
	CNAME NATIVEDNSRECORDTYPE = "CNAME"
	MX    NATIVEDNSRECORDTYPE = "MX"
	NS    NATIVEDNSRECORDTYPE = "NS"
	PTR   NATIVEDNSRECORDTYPE = "PTR"
	SOA   NATIVEDNSRECORDTYPE = "SOA"
	SRV   NATIVEDNSRECORDTYPE = "SRV"
	TXT   NATIVEDNSRECORDTYPE = "TXT"
)

// Defines values for NATIVEDNSRESPONSECONTAINMENT.
const (
	NATIVEDNSRESPONSECONTAINMENTAll NATIVEDNSRESPONSECONTAINMENT = "all"
	NATIVEDNSRESPONSECONTAINMENTAny NATIVEDNSRESPONSECONTAINMENT = "any"
)

// Defines values for NATIVEIPVERSION.
const (
	NATIVEIPVERSIONInet  NATIVEIPVERSION = "inet"
	NATIVEIPVERSIONInet6 NATIVEIPVERSION = "inet6"
)

// Defines values for NATIVEREGION.
const (
	AmsNl1 NATIVEREGION = "ams-nl-1"
	FraDe1 NATIVEREGION = "fra-de-1"
	HelFi1 NATIVEREGION = "hel-fi-1"
	LonGb1 NATIVEREGION = "lon-gb-1"
	NjUs1  NATIVEREGION = "nj-us-1"
	ParFr1 NATIVEREGION = "par-fr-1"
	SinSg1 NATIVEREGION = "sin-sg-1"
	SydAu1 NATIVEREGION = "syd-au-1"
	TxUs1  NATIVEREGION = "tx-us-1"
	WaUs1  NATIVEREGION = "wa-us-1"
)

// Defines values for NATIVESTRINGCONTAINMENTMODE.
const (
	NATIVESTRINGCONTAINMENTMODEExact NATIVESTRINGCONTAINMENTMODE = "exact"
	NATIVESTRINGCONTAINMENTMODERegex NATIVESTRINGCONTAINMENTMODE = "regex"
)

// Defines values for NEWRELICAPIREGION.
const (
	NEWRELICAPIREGIONEu NEWRELICAPIREGION = "eu"
	NEWRELICAPIREGIONUs NEWRELICAPIREGION = "us"
)

// Defines values for NewrelicType.
const (
	NewrelicTypeNewrelic NewrelicType = "newrelic"
)

// Defines values for NewrelicFormCreateApiRegion.
const (
	NewrelicFormCreateApiRegionEu NewrelicFormCreateApiRegion = "eu"
	NewrelicFormCreateApiRegionUs NewrelicFormCreateApiRegion = "us"
)

// Defines values for NewrelicFormCreateType.
const (
	NewrelicFormCreateTypeNewrelic NewrelicFormCreateType = "newrelic"
)

// Defines values for PINGDOMCHECKTYPE.
const (
	PINGDOMCHECKTYPECheck         PINGDOMCHECKTYPE = "check"
	PINGDOMCHECKTYPETransactional PINGDOMCHECKTYPE = "transactional"
)

// Defines values for PagerdutyType.
const (
	PagerdutyTypePagerduty PagerdutyType = "pagerduty"
)

// Defines values for PagerdutyFormCreateType.
const (
	PagerdutyFormCreateTypePagerduty PagerdutyFormCreateType = "pagerduty"
)

// Defines values for PingdomType.
const (
	PingdomTypePingdom PingdomType = "pingdom"
)

// Defines values for PingdomFormCreateCheckType.
const (
	PingdomFormCreateCheckTypeCheck         PingdomFormCreateCheckType = "check"
	PingdomFormCreateCheckTypeTransactional PingdomFormCreateCheckType = "transactional"
)

// Defines values for PingdomFormCreateType.
const (
	PingdomFormCreateTypePingdom PingdomFormCreateType = "pingdom"
)

// Defines values for PingdomFormUpdateCheckType.
const (
	PingdomFormUpdateCheckTypeCheck         PingdomFormUpdateCheckType = "check"
	PingdomFormUpdateCheckTypeTransactional PingdomFormUpdateCheckType = "transactional"
)

// Defines values for PingdomWatchdogType.
const (
	PingdomWatchdogTypePingdom PingdomWatchdogType = "pingdom"
)

// Defines values for PingdomWatchdogFormCreateCheckType.
const (
	PingdomWatchdogFormCreateCheckTypeCheck         PingdomWatchdogFormCreateCheckType = "check"
	PingdomWatchdogFormCreateCheckTypeTransactional PingdomWatchdogFormCreateCheckType = "transactional"
)

// Defines values for PingdomWatchdogFormCreateType.
const (
	PingdomWatchdogFormCreateTypePingdom PingdomWatchdogFormCreateType = "pingdom"
)

// Defines values for PingdomWatchdogFormUpdateCheckType.
const (
	Check         PingdomWatchdogFormUpdateCheckType = "check"
	Transactional PingdomWatchdogFormUpdateCheckType = "transactional"
)

// Defines values for PingdomLegacyV2Type.
const (
	PingdomLegacyV2TypePingdomLegacyV2 PingdomLegacyV2Type = "pingdom_legacy_v2"
)

// Defines values for ScheduleType.
const (
	ScheduleTypeSchedule ScheduleType = "schedule"
)

// Defines values for TCPMethod.
const (
	TCPMethodTcp TCPMethod = "tcp"
)

// Defines values for TCPType.
const (
	TCPTypeNative TCPType = "native"
)

// Defines values for TCPFormCreateIpVersion.
const (
	TCPFormCreateIpVersionInet  TCPFormCreateIpVersion = "inet"
	TCPFormCreateIpVersionInet6 TCPFormCreateIpVersion = "inet6"
)

// Defines values for TCPFormCreateMethod.
const (
	TCPFormCreateMethodTcp TCPFormCreateMethod = "tcp"
)

// Defines values for TCPFormCreateResponseMustContainMode.
const (
	TCPFormCreateResponseMustContainModeExact TCPFormCreateResponseMustContainMode = "exact"
	TCPFormCreateResponseMustContainModeRegex TCPFormCreateResponseMustContainMode = "regex"
)

// Defines values for TCPFormCreateType.
const (
	TCPFormCreateTypeNative TCPFormCreateType = "native"
)

// Defines values for UDPMethod.
const (
	UDPMethodUdp UDPMethod = "udp"
)

// Defines values for UDPType.
const (
	UDPTypeNative UDPType = "native"
)

// Defines values for UDPFormCreateIpVersion.
const (
	UDPFormCreateIpVersionInet  UDPFormCreateIpVersion = "inet"
	UDPFormCreateIpVersionInet6 UDPFormCreateIpVersion = "inet6"
)

// Defines values for UDPFormCreateMethod.
const (
	UDPFormCreateMethodUdp UDPFormCreateMethod = "udp"
)

// Defines values for UDPFormCreateResponseMustContainMode.
const (
	UDPFormCreateResponseMustContainModeExact UDPFormCreateResponseMustContainMode = "exact"
	UDPFormCreateResponseMustContainModeRegex UDPFormCreateResponseMustContainMode = "regex"
)

// Defines values for UDPFormCreateType.
const (
	UDPFormCreateTypeNative UDPFormCreateType = "native"
)

// Defines values for UPDATELABEL.
const (
	UPDATELABELAddendum      UPDATELABEL = "addendum"
	UPDATELABELCancelled     UPDATELABEL = "cancelled"
	UPDATELABELIdentified    UPDATELABEL = "identified"
	UPDATELABELInvestigating UPDATELABEL = "investigating"
	UPDATELABELMonitoring    UPDATELABEL = "monitoring"
	UPDATELABELResolved      UPDATELABEL = "resolved"
)

// Defines values for UpdateType.
const (
	UpdateTypeUpdate UpdateType = "update"
)

// Defines values for UpdateExpansionaryType.
const (
	UpdateExpansionaryTypeUpdate UpdateExpansionaryType = "update"
)

// Defines values for UpdateExpansionaryPagedArrayType.
const (
	PagedArray UpdateExpansionaryPagedArrayType = "paged_array"
)

// Defines values for UpdownType.
const (
	UpdownTypeUpdown UpdownType = "updown"
)

// Defines values for UpdownFormCreateType.
const (
	UpdownFormCreateTypeUpdown UpdownFormCreateType = "updown"
)

// Defines values for UptimerobotType.
const (
	UptimerobotTypeUptimerobot UptimerobotType = "uptimerobot"
)

// Defines values for UptimerobotFormCreateType.
const (
	UptimerobotFormCreateTypeUptimerobot UptimerobotFormCreateType = "uptimerobot"
)

// Defines values for UptimerobotWatchdogType.
const (
	UptimerobotWatchdogTypeUptimerobot UptimerobotWatchdogType = "uptimerobot"
)

// Defines values for UptimerobotWatchdogFormCreateType.
const (
	UptimerobotWatchdogFormCreateTypeUptimerobot UptimerobotWatchdogFormCreateType = "uptimerobot"
)

// Defines values for WatchdogType.
const (
	WatchdogTypeWatchdog WatchdogType = "watchdog"
)

// Defines values for WebhookType.
const (
	WebhookTypeWebhook WebhookType = "webhook"
)

// Defines values for WebhookFormCreateType.
const (
	WebhookFormCreateTypeWebhook WebhookFormCreateType = "webhook"
)

// Defines values for WebhookWatchdogType.
const (
	WebhookWatchdogTypeWebhook WebhookWatchdogType = "webhook"
)

// Defines values for WebhookWatchdogFormCreateType.
const (
	WebhookWatchdogFormCreateTypeWebhook WebhookWatchdogFormCreateType = "webhook"
)

// Defines values for IntegerState.
const (
	Minus1 IntegerState = -1
	N0     IntegerState = 0
	N1     IntegerState = 1
)

// Defines values for GetAllIssueTemplatesParamsKind.
const (
	GetAllIssueTemplatesParamsKindIssue  GetAllIssueTemplatesParamsKind = "issue"
	GetAllIssueTemplatesParamsKindUpdate GetAllIssueTemplatesParamsKind = "update"
)

// Builtin The builtin Hund metric provider, which provides metrics based on recorded
// uptime and incidents.
type Builtin struct {
	Type BuiltinType `json:"type"`
}

// BuiltinType defines model for Builtin.Type.
type BuiltinType string

// BuiltinFormCreate Builtin service creation form.
type BuiltinFormCreate struct {
	Type BuiltinFormCreateType `json:"type"`
}

// BuiltinFormCreateType defines model for BuiltinFormCreate.Type.
type BuiltinFormCreateType string

// BuiltinFormUpdate Builtin service update form.
type BuiltinFormUpdate = map[string]interface{}

// CLOUDWATCHREGION defines model for CLOUDWATCH_REGION.
type CLOUDWATCHREGION string

// Cloudwatch An [AWS CloudWatch](https://aws.amazon.com/cloudwatch/) service. This watchdog
// will monitor the `StatusCheckFailed` metric of an AWS EC2 instance reported by
// AWS CloudWatch.
type Cloudwatch struct {
	// InstanceId The AWS EC2 instance ID to monitor.
	InstanceId string `json:"instance_id"`

	// Region The AWS region that the given EC2 instance resides in.
	Region CLOUDWATCHREGION `json:"region"`
	Type   CloudwatchType   `json:"type"`
}

// CloudwatchType defines model for Cloudwatch.Type.
type CloudwatchType string

// CloudwatchFormCreate AWS Cloudwatch creation form.
type CloudwatchFormCreate struct {
	// AccessKeyId An AWS IAM user ID. This user can use the managed policy `CloudWatchReadOnlyAccess`.
	// Alternatively, create an inline policy with the required actions (`cloudwatch:Get*`, `cloudwatch:Describe*`).
	AccessKeyId string `json:"access_key_id"`

	// InstanceId The AWS EC2 instance ID to monitor.
	InstanceId string `json:"instance_id"`

	// Region The AWS region that the given EC2 instance resides in.
	Region CLOUDWATCHREGION `json:"region"`

	// SecretAccessKey The secret access key for the given AWS IAM user.
	SecretAccessKey string                   `json:"secret_access_key"`
	Type            CloudwatchFormCreateType `json:"type"`
}

// CloudwatchFormCreateType defines model for CloudwatchFormCreate.Type.
type CloudwatchFormCreateType string

// CloudwatchFormUpdate AWS Cloudwatch creation form.
type CloudwatchFormUpdate struct {
	// AccessKeyId An AWS IAM user ID. This user can use the managed policy `CloudWatchReadOnlyAccess`.
	// Alternatively, create an inline policy with the required actions (`cloudwatch:Get*`, `cloudwatch:Describe*`).
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// InstanceId The AWS EC2 instance ID to monitor.
	InstanceId *string `json:"instance_id,omitempty"`

	// Region The AWS region that the given EC2 instance resides in.
	Region *CLOUDWATCHREGION `json:"region,omitempty"`

	// SecretAccessKey The secret access key for the given AWS IAM user.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}

// Component An object representing a specific part of a service, which is potentially subject to downtime.
type Component struct {
	// Links An object describing the various link relations for this type.
	Links *Component_Links `json:"_links,omitempty"`

	// CreatedAt The UNIX timestamp at which this Component was created.
	CreatedAt Timestamp `json:"created_at"`

	// Description A description of this Component, potentially with markdown formatting.
	Description MaybeI18nString `json:"description"`

	// DescriptionHtml An HTML rendering of the markdown-formatted `description`.
	DescriptionHtml I18nString `json:"description_html"`

	// ExcludeFromGlobalHistory Exclude this Component from appearing in the global history.
	ExcludeFromGlobalHistory bool `json:"exclude_from_global_history"`

	// ExcludeFromGlobalUptime Exclude this Component's uptime percentage from being factored into the global
	// percent uptime calculation.
	ExcludeFromGlobalUptime bool `json:"exclude_from_global_uptime"`

	// Group The Group that this Component belongs to.
	Group *string `json:"group,omitempty"`

	// Id The ObjectId of this Component.
	Id ObjectId `json:"id"`

	// LastEventAt A UNIX timestamp at which the last event for this Component occurred. This
	// includes automated status changes, as well as issue creation and update.
	LastEventAt MaybeTimestamp `json:"last_event_at"`

	// Name The name of this Component.
	Name I18nString `json:"name"`

	// PercentUptime The rolling 30-day percent uptime of this Component.
	PercentUptime float32       `json:"percent_uptime"`
	Type          ComponentType `json:"type"`

	// UpdatedAt The UNIX timestamp at which this Component was last updated.
	UpdatedAt Timestamp `json:"updated_at"`

	// Watchdog The Watchdog that supplies the current status and metrics for this Component.
	Watchdog string `json:"watchdog"`
}

// Component_Links An object describing the various link relations for this type.
type Component_Links struct {
	Events               HALLink            `json:"events"`
	EventsByContext      HALLink            `json:"events:by-context"`
	Group                *HALLink           `json:"group,omitempty"`
	Self                 HALLink            `json:"self"`
	SelfView             HALLink            `json:"self-view"`
	Timeline             HALLink            `json:"timeline"`
	UpdateForm           HALLink            `json:"update-form"`
	Watchdog             HALLink            `json:"watchdog"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// ComponentType defines model for Component.Type.
type ComponentType string

// ComponentExpansionary An object representing a specific part of a service, which is potentially subject to downtime.
type ComponentExpansionary struct {
	// Links An object describing the various link relations for this type.
	Links *ComponentExpansionary_Links `json:"_links,omitempty"`

	// CreatedAt The UNIX timestamp at which this Component was created.
	CreatedAt Timestamp `json:"created_at"`

	// Description A description of this Component, potentially with markdown formatting.
	Description MaybeI18nString `json:"description"`

	// DescriptionHtml An HTML rendering of the markdown-formatted `description`.
	DescriptionHtml I18nString `json:"description_html"`

	// ExcludeFromGlobalHistory Exclude this Component from appearing in the global history.
	ExcludeFromGlobalHistory bool `json:"exclude_from_global_history"`

	// ExcludeFromGlobalUptime Exclude this Component's uptime percentage from being factored into the global
	// percent uptime calculation.
	ExcludeFromGlobalUptime bool `json:"exclude_from_global_uptime"`

	// Group The Group that this Component belongs to.
	Group *ComponentExpansionary_Group `json:"group,omitempty"`

	// Id The ObjectId of this Component.
	Id ObjectId `json:"id"`

	// LastEventAt A UNIX timestamp at which the last event for this Component occurred. This
	// includes automated status changes, as well as issue creation and update.
	LastEventAt MaybeTimestamp `json:"last_event_at"`

	// Name The name of this Component.
	Name I18nString `json:"name"`

	// PercentUptime The rolling 30-day percent uptime of this Component.
	PercentUptime float32                   `json:"percent_uptime"`
	Type          ComponentExpansionaryType `json:"type"`

	// UpdatedAt The UNIX timestamp at which this Component was last updated.
	UpdatedAt Timestamp `json:"updated_at"`

	// Watchdog The Watchdog that supplies the current status and metrics for this Component.
	Watchdog ComponentExpansionary_Watchdog `json:"watchdog"`
}

// ComponentExpansionary_Links An object describing the various link relations for this type.
type ComponentExpansionary_Links struct {
	Events               HALLink            `json:"events"`
	EventsByContext      HALLink            `json:"events:by-context"`
	Group                *HALLink           `json:"group,omitempty"`
	Self                 HALLink            `json:"self"`
	SelfView             HALLink            `json:"self-view"`
	Timeline             HALLink            `json:"timeline"`
	UpdateForm           HALLink            `json:"update-form"`
	Watchdog             HALLink            `json:"watchdog"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// ComponentExpansionaryGroup0 defines model for .
type ComponentExpansionaryGroup0 = ObjectId

// ComponentExpansionaryGroup1 A logical grouping of Components.
type ComponentExpansionaryGroup1 = Group

// ComponentExpansionary_Group The Group that this Component belongs to.
type ComponentExpansionary_Group struct {
	union json.RawMessage
}

// ComponentExpansionaryType defines model for ComponentExpansionary.Type.
type ComponentExpansionaryType string

// ComponentExpansionaryWatchdog0 defines model for .
type ComponentExpansionaryWatchdog0 = ObjectId

// ComponentExpansionaryWatchdog1 Watchdogs determine the method by which component availability is calculated,
// and generate statuses at the configured frequency (regular or high).
type ComponentExpansionaryWatchdog1 = Watchdog

// ComponentExpansionary_Watchdog The Watchdog that supplies the current status and metrics for this Component.
type ComponentExpansionary_Watchdog struct {
	union json.RawMessage
}

// ComponentExpansionaryPagedArray A cursor-like array object that allows paging through an array of objects.
type ComponentExpansionaryPagedArray struct {
	// Links An object describing the various link relations for this type.
	Links *ComponentExpansionaryPagedArray_Links `json:"_links,omitempty"`

	// Data An array of the objects in this page.
	Data []ComponentExpansionary `json:"data"`

	// HasMore Whether or not there are more objects after this page in descending order.
	// When false, this page is the final page of objects in descending order.
	HasMore bool `json:"has_more"`

	// TotalCount The total number of objects in `data`.
	TotalCount int                                 `json:"total_count"`
	Type       ComponentExpansionaryPagedArrayType `json:"type"`
}

// ComponentExpansionaryPagedArray_Links An object describing the various link relations for this type.
type ComponentExpansionaryPagedArray_Links struct {
	Beginning            HALLink            `json:"beginning"`
	CreateForm           *HALLink           `json:"create-form,omitempty"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// ComponentExpansionaryPagedArrayType defines model for ComponentExpansionaryPagedArray.Type.
type ComponentExpansionaryPagedArrayType string

// ComponentFormCreate Component creation form.
type ComponentFormCreate struct {
	// Description A description of this Component, potentially with markdown formatting.
	Description *MaybeI18nString `json:"description,omitempty"`

	// ExcludeFromGlobalHistory Exclude this Component from appearing in the global history.
	ExcludeFromGlobalHistory *bool `json:"exclude_from_global_history,omitempty"`

	// ExcludeFromGlobalUptime Exclude this Component's uptime percentage from being factored into the global
	// percent uptime calculation.
	ExcludeFromGlobalUptime *bool `json:"exclude_from_global_uptime,omitempty"`

	// Group The Group that this Component belongs to.
	Group ObjectId `json:"group"`

	// Name The name of this Component.
	Name I18nString `json:"name"`

	// Watchdog The Watchdog that supplies the current status and metrics for this Component.
	Watchdog WatchdogFormCreate `json:"watchdog"`
}

// ComponentFormUpdate Component update form.
type ComponentFormUpdate struct {
	// Description A description of this Component, potentially with markdown formatting.
	Description *MaybeI18nString `json:"description,omitempty"`

	// ExcludeFromGlobalHistory Exclude this Component from appearing in the global history.
	ExcludeFromGlobalHistory *bool `json:"exclude_from_global_history,omitempty"`

	// ExcludeFromGlobalUptime Exclude this Component's uptime percentage from being factored into the global
	// percent uptime calculation.
	ExcludeFromGlobalUptime *bool `json:"exclude_from_global_uptime,omitempty"`

	// Group The Group that this Component belongs to.
	Group *ObjectId `json:"group,omitempty"`

	// Name The name of this Component.
	Name *I18nString `json:"name,omitempty"`

	// Watchdog The Watchdog that supplies the current status and metrics for this Component.
	Watchdog *WatchdogFormUpdate `json:"watchdog,omitempty"`
}

// ComponentPagedArray A cursor-like array object that allows paging through an array of objects.
type ComponentPagedArray struct {
	// Links An object describing the various link relations for this type.
	Links *ComponentPagedArray_Links `json:"_links,omitempty"`

	// Data An array of the objects in this page.
	Data []Component `json:"data"`

	// HasMore Whether or not there are more objects after this page in descending order.
	// When false, this page is the final page of objects in descending order.
	HasMore bool `json:"has_more"`

	// TotalCount The total number of objects in `data`.
	TotalCount int                     `json:"total_count"`
	Type       ComponentPagedArrayType `json:"type"`
}

// ComponentPagedArray_Links An object describing the various link relations for this type.
type ComponentPagedArray_Links struct {
	Beginning            HALLink            `json:"beginning"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// ComponentPagedArrayType defines model for ComponentPagedArray.Type.
type ComponentPagedArrayType string

// DNS A Hund Native Monitoring DNS Check.
type DNS struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold NonnegativeInteger `json:"consecutive_check_outage_threshold"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency int `json:"frequency"`

	// Method The method to use to check the target.
	Method DNSMethod `json:"method"`

	// Nameservers An optional list of nameservers to make DNS queries with. This field is
	// ignored by SOA queries since they use the nameservers yielded by querying NS
	// on the target.
	Nameservers []string `json:"nameservers"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold Percentage `json:"percentage_regions_failed_threshold"`

	// RecordType The type of DNS record to query for on the target.
	RecordType NATIVEDNSRECORDTYPE `json:"record_type"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseContainment Whether `all` of the assertions in the given list must match the DNS response,
	// or rather just `any` of them (i.e. at least one).
	ResponseContainment NATIVEDNSRESPONSECONTAINMENT `json:"response_containment"`

	// ResponsesMustContain A list of assertions to make against the records yielded by the query. The
	// format of these assertions is *similar* to DNS record syntax, but is
	// slightly simplified and allows for only asserting parts of a record's RDATA,
	// rather than the entire thing. The check will fail depending on the value of
	// `response_containment`.
	//
	// This field is ignored by the SOA check, as it does not use assertions to
	// determine the validity of SOA records. Instead, we ensure that every
	// nameserver reported by querying NS on the target reports the same SOA serial.
	// If your target's nameservers report conflicting SOA serials, we consider the
	// check failed.
	//
	// **Example Assertions (for MX record type):**
	// ```json
	// [
	//   "10 mail.example.com",
	//   "spool.example.com",
	//   "mail2.example.com"
	// ]
	// ```
	//
	// Note above how we can assert both the priority and domain (*without* the
	// terminating period required by canonical DNS) of an MX record, or instead
	// simply the domain.
	ResponsesMustContain []string `json:"responses_must_contain"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout int     `json:"timeout"`
	Type    DNSType `json:"type"`
}

// DNSMethod The method to use to check the target.
type DNSMethod string

// DNSType defines model for DNS.Type.
type DNSType string

// DNSFormCreate Hund Native Monitoring DNS Check creation form.
type DNSFormCreate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *int `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// Method The method to use to check the target.
	Method DNSFormCreateMethod `json:"method"`

	// Nameservers An optional list of nameservers to make DNS queries with. This field is
	// ignored by SOA queries since they use the nameservers yielded by querying NS
	// on the target.
	Nameservers *[]string `json:"nameservers,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *float32 `json:"percentage_regions_failed_threshold,omitempty"`

	// RecordType The type of DNS record to query for on the target.
	RecordType NATIVEDNSRECORDTYPE `json:"record_type"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseContainment Whether `all` of the assertions in the given list must match the DNS response,
	// or rather just `any` of them (i.e. at least one).
	ResponseContainment *DNSFormCreateResponseContainment `json:"response_containment,omitempty"`

	// ResponsesMustContain A list of assertions to make against the records yielded by the query. The
	// format of these assertions is *similar* to DNS record syntax, but is
	// slightly simplified and allows for only asserting parts of a record's RDATA,
	// rather than the entire thing. The check will fail depending on the value of
	// `response_containment`.
	//
	// This field is ignored by the SOA check, as it does not use assertions to
	// determine the validity of SOA records. Instead, we ensure that every
	// nameserver reported by querying NS on the target reports the same SOA serial.
	// If your target's nameservers report conflicting SOA serials, we consider the
	// check failed.
	//
	// **Example Assertions (for MX record type):**
	// ```json
	// [
	//   "10 mail.example.com",
	//   "spool.example.com",
	//   "mail2.example.com"
	// ]
	// ```
	//
	// Note above how we can assert both the priority and domain (*without* the
	// terminating period required by canonical DNS) of an MX record, or instead
	// simply the domain.
	ResponsesMustContain *[]string `json:"responses_must_contain,omitempty"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int              `json:"timeout,omitempty"`
	Type    DNSFormCreateType `json:"type"`
}

// DNSFormCreateMethod The method to use to check the target.
type DNSFormCreateMethod string

// DNSFormCreateResponseContainment Whether `all` of the assertions in the given list must match the DNS response,
// or rather just `any` of them (i.e. at least one).
type DNSFormCreateResponseContainment string

// DNSFormCreateType defines model for DNSFormCreate.Type.
type DNSFormCreateType string

// DNSFormUpdate Hund Native Monitoring DNS Check update form.
type DNSFormUpdate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *NonnegativeInteger `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// Nameservers An optional list of nameservers to make DNS queries with. This field is
	// ignored by SOA queries since they use the nameservers yielded by querying NS
	// on the target.
	Nameservers *[]string `json:"nameservers,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *Percentage `json:"percentage_regions_failed_threshold,omitempty"`

	// RecordType The type of DNS record to query for on the target.
	RecordType *NATIVEDNSRECORDTYPE `json:"record_type,omitempty"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions *[]NATIVEREGION `json:"regions,omitempty"`

	// ResponseContainment Whether `all` of the assertions in the given list must match the DNS response,
	// or rather just `any` of them (i.e. at least one).
	ResponseContainment *NATIVEDNSRESPONSECONTAINMENT `json:"response_containment,omitempty"`

	// ResponsesMustContain A list of assertions to make against the records yielded by the query. The
	// format of these assertions is *similar* to DNS record syntax, but is
	// slightly simplified and allows for only asserting parts of a record's RDATA,
	// rather than the entire thing. The check will fail depending on the value of
	// `response_containment`.
	//
	// This field is ignored by the SOA check, as it does not use assertions to
	// determine the validity of SOA records. Instead, we ensure that every
	// nameserver reported by querying NS on the target reports the same SOA serial.
	// If your target's nameservers report conflicting SOA serials, we consider the
	// check failed.
	//
	// **Example Assertions (for MX record type):**
	// ```json
	// [
	//   "10 mail.example.com",
	//   "spool.example.com",
	//   "mail2.example.com"
	// ]
	// ```
	//
	// Note above how we can assert both the priority and domain (*without* the
	// terminating period required by canonical DNS) of an MX record, or instead
	// simply the domain.
	ResponsesMustContain *[]string `json:"responses_must_contain,omitempty"`

	// Target The host the check will make calls to.
	Target *string `json:"target,omitempty"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int `json:"timeout,omitempty"`
}

// Error A [vnd.error](https://github.com/blongden/vnd.error) object.
type Error struct {
	Embedded *struct {
		// Errors Additional embedded error objects, for granular detail in case of a
		// multi-faceted error (e.g. field validation errors).
		Errors []struct {
			// Links An object describing the various link relations for this type.
			Links   *Default `json:"_links,omitempty"`
			Message string   `json:"message"`
			Path    *string  `json:"path,omitempty"`
		} `json:"errors"`
	} `json:"_embedded,omitempty"`

	// Links An object describing the various link relations for this type.
	Links *Default `json:"_links,omitempty"`

	// Logref The ID of this specific request. This ID should be supplied in support requests.
	Logref string `json:"logref"`

	// Message A descriptive message detailing the returned error.
	Message string  `json:"message"`
	Path    *string `json:"path,omitempty"`
}

// FormMetricProviderCreate defines model for Form::MetricProvider::Create.
type FormMetricProviderCreate struct {
	union json.RawMessage
}

// FormMetricProviderCreate0 Builtin service creation form.
type FormMetricProviderCreate0 = BuiltinFormCreate

// FormMetricProviderCreate1 Updown service creation form.
type FormMetricProviderCreate1 = UpdownFormCreate

// FormMetricProviderCreate2 Uptime Robot service creation form.
type FormMetricProviderCreate2 = UptimerobotFormCreate

// FormMetricProviderCreate3 Webhook service creation form.
type FormMetricProviderCreate3 = WebhookFormCreate

// FormMetricProviderCreate4 Pingdom service creation form.
type FormMetricProviderCreate4 = PingdomFormCreate

// FormMetricProviderCreate5 Hund Native Monitoring service creation form.
type FormMetricProviderCreate5 = NativeFormCreate

// FormMetricProviderUpdate defines model for Form::MetricProvider::Update.
type FormMetricProviderUpdate struct {
	union json.RawMessage
}

// FormMetricProviderUpdate0 Builtin service update form.
type FormMetricProviderUpdate0 = BuiltinFormUpdate

// FormMetricProviderUpdate1 Updown service update form.
type FormMetricProviderUpdate1 = UpdownFormUpdate

// FormMetricProviderUpdate2 Uptime Robot service update form.
type FormMetricProviderUpdate2 = UptimerobotFormUpdate

// FormMetricProviderUpdate3 Webhook service update form.
type FormMetricProviderUpdate3 = WebhookFormUpdate

// FormMetricProviderUpdate4 Pingdom service update form.
type FormMetricProviderUpdate4 = PingdomFormUpdate

// FormMetricProviderUpdate5 Hund Native Monitoring service update form.
type FormMetricProviderUpdate5 = NativeFormUpdate

// FormMetricProviderUpdate6 Pingdom (legacy API v2) update form.
type FormMetricProviderUpdate6 = PingdomLegacyV2FormUpdate

// FormWatchdogCreate defines model for Form::Watchdog::Create.
type FormWatchdogCreate struct {
	union json.RawMessage
}

// FormWatchdogCreate0 Manual service creation form.
type FormWatchdogCreate0 = ManualFormCreate

// FormWatchdogCreate1 Updown service creation form.
type FormWatchdogCreate1 = UpdownFormCreate

// FormWatchdogCreate2 Uptime Robot service creation form.
type FormWatchdogCreate2 = UptimerobotWatchdogFormCreate

// FormWatchdogCreate3 Webhook service creation form.
type FormWatchdogCreate3 = WebhookWatchdogFormCreate

// FormWatchdogCreate4 Pingdom service creation form.
type FormWatchdogCreate4 = PingdomWatchdogFormCreate

// FormWatchdogCreate5 AWS Cloudwatch creation form.
type FormWatchdogCreate5 = CloudwatchFormCreate

// FormWatchdogCreate6 New Relic service creation form.
type FormWatchdogCreate6 = NewrelicFormCreate

// FormWatchdogCreate7 PagerDuty creation form.
type FormWatchdogCreate7 = PagerdutyFormCreate

// FormWatchdogCreate8 Hund Native Monitoring service creation form.
type FormWatchdogCreate8 = NativeFormCreate

// FormWatchdogUpdate defines model for Form::Watchdog::Update.
type FormWatchdogUpdate struct {
	union json.RawMessage
}

// FormWatchdogUpdate0 Manual service update form.
type FormWatchdogUpdate0 = ManualFormUpdate

// FormWatchdogUpdate1 Updown service update form.
type FormWatchdogUpdate1 = UpdownFormUpdate

// FormWatchdogUpdate2 Uptime Robot service update form.
type FormWatchdogUpdate2 = UptimerobotWatchdogFormUpdate

// FormWatchdogUpdate3 Webhook service update form.
type FormWatchdogUpdate3 = WebhookWatchdogFormUpdate

// FormWatchdogUpdate4 Pingdom service update form.
type FormWatchdogUpdate4 = PingdomWatchdogFormUpdate

// FormWatchdogUpdate5 AWS Cloudwatch creation form.
type FormWatchdogUpdate5 = CloudwatchFormUpdate

// FormWatchdogUpdate6 New Relic service update form.
type FormWatchdogUpdate6 = NewrelicFormUpdate

// FormWatchdogUpdate7 PagerDuty update form.
type FormWatchdogUpdate7 = PagerdutyFormUpdate

// FormWatchdogUpdate8 Hund Native Monitoring service update form.
type FormWatchdogUpdate8 = NativeFormUpdate

// FormWatchdogUpdate9 Pingdom (legacy API v2) update form.
type FormWatchdogUpdate9 = PingdomLegacyV2FormUpdate

// Group A logical grouping of Components.
type Group struct {
	// Links An object describing the various link relations for this type.
	Links *Group_Links `json:"_links,omitempty"`

	// Collapsed Whether or not this group is displayed collapsed by default on the status page.
	Collapsed bool `json:"collapsed"`

	// Components A PagedArray of the Components contained within this Group.
	Components Group_Components `json:"components"`

	// CreatedAt The UNIX timestamp at which this Group was created.
	CreatedAt Timestamp `json:"created_at"`

	// Description A description of this Component, potentially with markdown formatting.
	Description MaybeI18nString `json:"description"`

	// DescriptionHtml An HTML rendering of the markdown-formatted `description`.
	DescriptionHtml I18nString `json:"description_html"`

	// Id The ObjectId of this Group.
	Id ObjectId `json:"id"`

	// Name The name of this Group.
	Name I18nString `json:"name"`

	// Position An integer representing the position of this Group. Groups are displayed on
	// the status page in ascending order according to this value.
	Position int       `json:"position"`
	Type     GroupType `json:"type"`

	// UpdatedAt The UNIX timestamp at which this Group was last updated.
	UpdatedAt Timestamp `json:"updated_at"`
}

// Group_Links An object describing the various link relations for this type.
type Group_Links struct {
	ActionReorder        HALLink            `json:"action:reorder"`
	Components           HALLink            `json:"components"`
	Self                 HALLink            `json:"self"`
	Timeline             HALLink            `json:"timeline"`
	UpdateForm           HALLink            `json:"update-form"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// GroupComponents1 defines model for .
type GroupComponents1 = []ObjectId

// Group_Components A PagedArray of the Components contained within this Group.
type Group_Components struct {
	union json.RawMessage
}

// GroupType defines model for Group.Type.
type GroupType string

// GroupFormCreate Group creation form.
type GroupFormCreate struct {
	// Collapsed Whether or not this group is displayed collapsed by default on the status page.
	Collapsed *bool `json:"collapsed,omitempty"`

	// Description A description of this Group, potentially with markdown formatting.
	Description *MaybeI18nString `json:"description,omitempty"`

	// Name The name of this Group.
	Name I18nString `json:"name"`

	// Position An integer representing the position of this Group. Groups are displayed on
	// the status page in ascending order according to this value.
	Position *int `json:"position,omitempty"`
}

// GroupFormUpdate Group update form.
type GroupFormUpdate struct {
	// Collapsed Whether or not this group is displayed collapsed by default on the status page.
	Collapsed *bool `json:"collapsed,omitempty"`

	// Description A description of this Group, potentially with markdown formatting.
	Description *MaybeI18nString `json:"description,omitempty"`

	// Name The name of this Group.
	Name *I18nString `json:"name,omitempty"`

	// Position An integer representing the position of this Group. Groups are displayed on
	// the status page in ascending order according to this value.
	Position *int `json:"position,omitempty"`
}

// GroupPagedArray A cursor-like array object that allows paging through an array of objects.
type GroupPagedArray struct {
	// Links An object describing the various link relations for this type.
	Links *GroupPagedArray_Links `json:"_links,omitempty"`

	// Data An array of the objects in this page.
	Data []Group `json:"data"`

	// HasMore Whether or not there are more objects after this page in descending order.
	// When false, this page is the final page of objects in descending order.
	HasMore bool `json:"has_more"`

	// TotalCount The total number of objects in `data`.
	TotalCount int                 `json:"total_count"`
	Type       GroupPagedArrayType `json:"type"`
}

// GroupPagedArray_Links An object describing the various link relations for this type.
type GroupPagedArray_Links struct {
	Beginning            HALLink            `json:"beginning"`
	CreateForm           *HALLink           `json:"create-form,omitempty"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// GroupPagedArrayType defines model for GroupPagedArray.Type.
type GroupPagedArrayType string

// HALLink defines model for HAL::Link.
type HALLink struct {
	Href                 string                 `json:"href"`
	Templated            *bool                  `json:"templated,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// HTTP A Hund Native Monitoring HTTP Check.
type HTTP struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold NonnegativeInteger `json:"consecutive_check_outage_threshold"`

	// FollowRedirects Follow any HTTP redirects given by the requested target. Please note that this
	// check will only follow up to 9 redirects.
	FollowRedirects bool `json:"follow_redirects"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency int `json:"frequency"`

	// Headers A list of additional HTTP headers to send to the target. The following list of
	// header names are reserved and cannot be set by a check:
	//
	// * `Accept-Charset`
	// * `Accept-Encoding`
	// * `Authentication`
	// * `Connection`
	// * `Content-Length`
	// * `Date`
	// * `Host`
	// * `Keep-Alive`
	// * `Origin`
	// * `Proxy-.*`
	// * `Sec-.*`
	// * `Referer`
	// * `TE`
	// * `Trailer`
	// * `Transfer-Encoding`
	// * `User-Agent`
	// * `Via`
	Headers HTTPHeaders `json:"headers"`

	// Method The method to use to check the target.
	Method HTTPMethod `json:"method"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold Percentage `json:"percentage_regions_failed_threshold"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseBodyMustContain This field supports two different matching modes (given by
	// `response_body_must_contain_mode`):
	//
	// `exact`: If the requested page does not contain this exact (case-sensitive)
	// string, then the check will fail.
	//
	// `regex`: If the requested page does not match against the given regex, then
	// the check will fail. [Click here](https://hund.io/help/documentation/regular-expressions) for
	// more information on the use and supported syntax of Hund regexes.
	ResponseBodyMustContain MaybeString `json:"response_body_must_contain"`

	// ResponseBodyMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_body_must_contain`.
	ResponseBodyMustContainMode NATIVESTRINGCONTAINMENTMODE `json:"response_body_must_contain_mode"`

	// ResponseCodeMustBe If the requested page does not return this response code, then the check will
	// fail.
	ResponseCodeMustBe MaybeHTTPResponseCode `json:"response_code_must_be"`

	// SslVerifyPeer Require the target's TLS certificate to be valid.
	SslVerifyPeer bool `json:"ssl_verify_peer"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout int      `json:"timeout"`
	Type    HTTPType `json:"type"`

	// Username An optional HTTP Basic Authentication username.
	Username MaybeString `json:"username"`
}

// HTTPMethod The method to use to check the target.
type HTTPMethod string

// HTTPType defines model for HTTP.Type.
type HTTPType string

// HTTPFormCreate Hund Native Monitoring HTTP Check creation form.
type HTTPFormCreate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *int `json:"consecutive_check_outage_threshold,omitempty"`

	// FollowRedirects Follow any HTTP redirects given by the requested target. Please note that this
	// check will only follow up to 9 redirects.
	FollowRedirects *bool `json:"follow_redirects,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// Headers A list of additional HTTP headers to send to the target. The following list of
	// header names are reserved and cannot be set by a check:
	//
	// * `Accept-Charset`
	// * `Accept-Encoding`
	// * `Authentication`
	// * `Connection`
	// * `Content-Length`
	// * `Date`
	// * `Host`
	// * `Keep-Alive`
	// * `Origin`
	// * `Proxy-.*`
	// * `Sec-.*`
	// * `Referer`
	// * `TE`
	// * `Trailer`
	// * `Transfer-Encoding`
	// * `User-Agent`
	// * `Via`
	Headers *HTTPHeaders `json:"headers,omitempty"`

	// Method The method to use to check the target.
	Method HTTPFormCreateMethod `json:"method"`

	// Password An optional HTTP Basic Authentication password.
	Password *MaybeString `json:"password,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *float32 `json:"percentage_regions_failed_threshold,omitempty"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseBodyMustContain This field supports two different matching modes (given by
	// `response_body_must_contain_mode`):
	//
	// `exact`: If the requested page does not contain this exact (case-sensitive)
	// string, then the check will fail.
	//
	// `regex`: If the requested page does not match against the given regex, then
	// the check will fail. [Click here](https://hund.io/help/documentation/regular-expressions) for
	// more information on the use and supported syntax of Hund regexes.
	ResponseBodyMustContain *MaybeString `json:"response_body_must_contain,omitempty"`

	// ResponseBodyMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_body_must_contain`.
	ResponseBodyMustContainMode *HTTPFormCreateResponseBodyMustContainMode `json:"response_body_must_contain_mode,omitempty"`

	// ResponseCodeMustBe If the requested page does not return this response code, then the check will
	// fail.
	ResponseCodeMustBe *MaybeHTTPResponseCode `json:"response_code_must_be,omitempty"`

	// SslVerifyPeer Require the target's TLS certificate to be valid.
	SslVerifyPeer *bool `json:"ssl_verify_peer,omitempty"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int               `json:"timeout,omitempty"`
	Type    HTTPFormCreateType `json:"type"`

	// Username An optional HTTP Basic Authentication username.
	Username *MaybeString `json:"username,omitempty"`
}

// HTTPFormCreateMethod The method to use to check the target.
type HTTPFormCreateMethod string

// HTTPFormCreateResponseBodyMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
// under `response_body_must_contain`.
type HTTPFormCreateResponseBodyMustContainMode string

// HTTPFormCreateType defines model for HTTPFormCreate.Type.
type HTTPFormCreateType string

// HTTPFormUpdate Hund Native Monitoring HTTP Check creation form.
type HTTPFormUpdate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *NonnegativeInteger `json:"consecutive_check_outage_threshold,omitempty"`

	// FollowRedirects Follow any HTTP redirects given by the requested target. Please note that this
	// check will only follow up to 9 redirects.
	FollowRedirects *bool `json:"follow_redirects,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// Headers A list of additional HTTP headers to send to the target. The following list of
	// header names are reserved and cannot be set by a check:
	//
	// * `Accept-Charset`
	// * `Accept-Encoding`
	// * `Authentication`
	// * `Connection`
	// * `Content-Length`
	// * `Date`
	// * `Host`
	// * `Keep-Alive`
	// * `Origin`
	// * `Proxy-.*`
	// * `Sec-.*`
	// * `Referer`
	// * `TE`
	// * `Trailer`
	// * `Transfer-Encoding`
	// * `User-Agent`
	// * `Via`
	Headers *HTTPHeaders `json:"headers,omitempty"`

	// Password An optional HTTP Basic Authentication password.
	Password *MaybeString `json:"password,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *Percentage `json:"percentage_regions_failed_threshold,omitempty"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions *[]NATIVEREGION `json:"regions,omitempty"`

	// ResponseBodyMustContain This field supports two different matching modes (given by
	// `response_body_must_contain_mode`):
	//
	// `exact`: If the requested page does not contain this exact (case-sensitive)
	// string, then the check will fail.
	//
	// `regex`: If the requested page does not match against the given regex, then
	// the check will fail. [Click here](https://hund.io/help/documentation/regular-expressions) for
	// more information on the use and supported syntax of Hund regexes.
	ResponseBodyMustContain *MaybeString `json:"response_body_must_contain,omitempty"`

	// ResponseBodyMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_body_must_contain`.
	ResponseBodyMustContainMode *NATIVESTRINGCONTAINMENTMODE `json:"response_body_must_contain_mode,omitempty"`

	// ResponseCodeMustBe If the requested page does not return this response code, then the check will
	// fail.
	ResponseCodeMustBe *MaybeHTTPResponseCode `json:"response_code_must_be,omitempty"`

	// SslVerifyPeer Require the target's TLS certificate to be valid.
	SslVerifyPeer *bool `json:"ssl_verify_peer,omitempty"`

	// Target The host the check will make calls to.
	Target *string `json:"target,omitempty"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int `json:"timeout,omitempty"`

	// Username An optional HTTP Basic Authentication username.
	Username *MaybeString `json:"username,omitempty"`
}

// HTTPHeaders defines model for HTTP::Headers.
type HTTPHeaders map[string]string

// HTTPResponseCode defines model for HTTP::ResponseCode.
type HTTPResponseCode = int

// ICMP A Hund Native Monitoring ICMP Check.
type ICMP struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold NonnegativeInteger `json:"consecutive_check_outage_threshold"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency int `json:"frequency"`

	// IpVersion The IP version to use when pinging.
	IpVersion NATIVEIPVERSION `json:"ip_version"`

	// Method The method to use to check the target.
	Method ICMPMethod `json:"method"`

	// PercentageFailedThreshold The percentage of addresses at the given target that must fail for a region to
	// be counted as failed. This option only matters when there are multiple IP
	// addresses behind the target when the target is a domain.
	PercentageFailedThreshold Percentage `json:"percentage_failed_threshold"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold Percentage `json:"percentage_regions_failed_threshold"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout int      `json:"timeout"`
	Type    ICMPType `json:"type"`
}

// ICMPMethod The method to use to check the target.
type ICMPMethod string

// ICMPType defines model for ICMP.Type.
type ICMPType string

// ICMPFormCreate Hund Native Monitoring ICMP Check creation form.
type ICMPFormCreate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *int `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// IpVersion The IP version to use when pinging.
	IpVersion *ICMPFormCreateIpVersion `json:"ip_version,omitempty"`

	// Method The method to use to check the target.
	Method ICMPFormCreateMethod `json:"method"`

	// PercentageFailedThreshold The percentage of addresses at the given target that must fail for a region to
	// be counted as failed. This option only matters when there are multiple IP
	// addresses behind the target when the target is a domain.
	PercentageFailedThreshold *float32 `json:"percentage_failed_threshold,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *float32 `json:"percentage_regions_failed_threshold,omitempty"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int               `json:"timeout,omitempty"`
	Type    ICMPFormCreateType `json:"type"`
}

// ICMPFormCreateIpVersion The IP version to use when pinging.
type ICMPFormCreateIpVersion string

// ICMPFormCreateMethod The method to use to check the target.
type ICMPFormCreateMethod string

// ICMPFormCreateType defines model for ICMPFormCreate.Type.
type ICMPFormCreateType string

// ICMPFormUpdate Hund Native Monitoring ICMP Check update form.
type ICMPFormUpdate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *NonnegativeInteger `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// IpVersion The IP version to use when pinging.
	IpVersion *NATIVEIPVERSION `json:"ip_version,omitempty"`

	// PercentageFailedThreshold The percentage of addresses at the given target that must fail for a region to
	// be counted as failed. This option only matters when there are multiple IP
	// addresses behind the target when the target is a domain.
	PercentageFailedThreshold *Percentage `json:"percentage_failed_threshold,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *Percentage `json:"percentage_regions_failed_threshold,omitempty"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions *[]NATIVEREGION `json:"regions,omitempty"`

	// Target The host the check will make calls to.
	Target *string `json:"target,omitempty"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int `json:"timeout,omitempty"`
}

// ISSUELABEL defines model for ISSUE_LABEL.
type ISSUELABEL string

// ISSUEPRIORITY defines model for ISSUE_PRIORITY.
type ISSUEPRIORITY int

// ISSUESPECIALIZATION defines model for ISSUE_SPECIALIZATION.
type ISSUESPECIALIZATION string

// ISSUETEMPLATEKIND defines model for ISSUE_TEMPLATE_KIND.
type ISSUETEMPLATEKIND string

// ISSUETEMPLATELABEL defines model for ISSUE_TEMPLATE_LABEL.
type ISSUETEMPLATELABEL string

// ISSUETEMPLATEVARIABLETYPE defines model for ISSUE_TEMPLATE_VARIABLE_TYPE.
type ISSUETEMPLATEVARIABLETYPE string

// Issue Issues represent an evolving incident in time. Issues have updates, which
// describe the evolution of an issue, often up to resolution. Issues may also
// set a schedule, which allows automatically starting and ending the issue.
type Issue struct {
	// Links An object describing the various link relations for this type.
	Links *Issue_Links `json:"_links,omitempty"`

	// BeganAt The UNIX timestamp at which this Issue began affecting its given Components.
	BeganAt Timestamp `json:"began_at"`

	// Body The initial body text of the issue in raw markdown.
	Body I18nString `json:"body"`

	// BodyHtml An HTML rendered view of the markdown in `body`.
	BodyHtml I18nString `json:"body_html"`

	// Cancelled Whether this Issue has been cancelled. Note that this field is `null` if the
	// Issue is not scheduled.
	Cancelled MaybeBoolean `json:"cancelled"`

	// CancelledAt The time at which this Issue was cancelled. This field is `null` if the Issue
	// has not been cancelled or is not scheduled.
	CancelledAt MaybeTimestamp `json:"cancelled_at"`

	// Components The Components affected by this Issue.
	Components struct {
		// Links An object describing the various link relations for this type.
		Links *Issue_Components_Links `json:"_links,omitempty"`

		// Data An array of the objects in this page.
		Data []Component `json:"data"`

		// HasMore Whether or not there are more objects after this page in descending order.
		// When false, this page is the final page of objects in descending order.
		HasMore bool `json:"has_more"`

		// TotalCount The total number of objects in `data`.
		TotalCount int                 `json:"total_count"`
		Type       IssueComponentsType `json:"type"`
	} `json:"components"`

	// CreatedAt The UNIX timestamp at which this Issue was created.
	CreatedAt Timestamp `json:"created_at"`

	// Duration The effective duration of this Issue in seconds. That is, the total amount of
	// time for which this Issue affects its Components. Thus, this field only
	// accumulates while the Issue is ongoing/open.
	//
	// **Note:** This value is zero for cancelled and informational Issues. For
	// scheduled Issues, this field will remain zero until the Issue begins according
	// to the Schedule.
	Duration NonnegativeInteger `json:"duration"`

	// EndedAt The UNIX timestamp at which this Issue stopped affecting its given Components. This
	// field is `null` if it has not ended yet.
	EndedAt MaybeTimestamp `json:"ended_at"`

	// Id The ObjectId of this Issue.
	Id ObjectId `json:"id"`

	// Label The initial label applied to the issue. The "current" label of the entire
	// issue may be updated by the labels of Issue Updates, though this must be taken
	// from the latest Update in `updates`.
	Label MaybeISSUELABEL `json:"label"`

	// OpenGraphImageUrl The URL to an image which will be displayed alongside this issue when shared
	// on social media websites.
	OpenGraphImageUrl MaybeString `json:"open_graph_image_url"`

	// Priority The integer priority of the Issue. Priority pertains to how notifications are
	// triggered for this Issue: -1 indicates **low priority**, meaning no
	// notifications whatsoever will be triggered for this issue; 0 indicates
	// **normal priority**, which is the default behavior; and, 1 indicates
	// **high priority**, meaning all subscriptions across all notifiers will receive
	// notifications for this Issue regardless of their notification preferences.
	Priority ISSUEPRIORITY `json:"priority"`

	// Resolved Whether this Issue is currently resolved, thus no longer affecting its given
	// Components.
	Resolved bool `json:"resolved"`

	// Retrospective Whether this Issue is retrospective; that is, the Issue was created both resolved
	// *and* backdated.
	Retrospective bool `json:"retrospective"`

	// Schedule An object detailing the Schedule of this issue if it is scheduled. This field
	// is `null` if the Issue is not scheduled.
	Schedule MaybeSchedule `json:"schedule"`

	// Scheduled Whether this Issue has a Schedule.
	Scheduled bool `json:"scheduled"`

	// Specialization Whether this Issue has special abilities or connotations. `general` is the
	// default behavior, indicating no specialization. Other values include
	// `maintenance`, which indicates an Issue shows affected components as
	// "under maintenance," and `informational`, which indicates that the Issue is an
	// informational bulletin.
	Specialization ISSUESPECIALIZATION `json:"specialization"`

	// Standing Whether this Issue is currently active and affecting its given Components.
	Standing bool `json:"standing"`

	// StateOverride The integer state which overrides the state of affected Components in
	// `component`. A value of `null` indicates no override is present.
	StateOverride MaybeIntegerState `json:"state_override"`

	// Template The IssueTemplateApplication that this Issue is applied against, which controls
	// the values of `title`, `body`, and `label` when set.
	Template MaybeIssueTemplateApplicationIssue `json:"template"`

	// Title The title of the Issue.
	Title I18nString `json:"title"`
	Type  IssueType  `json:"type"`

	// UpdatedAt The UNIX timestamp at which this Issue was last updated.
	UpdatedAt Timestamp `json:"updated_at"`

	// Updates A PagedArray whose `data` field contains an array of Issue Update objects.
	// This PagedArray will always be completely paged in, so expect `has_more` to
	// always be `false`. The first element of this array is the *latest* Update for
	// this Issue, and should be considered the current status of this Issue.
	Updates struct {
		// Links An object describing the various link relations for this type.
		Links *Issue_Updates_Links `json:"_links,omitempty"`

		// Data An array of the objects in this page.
		Data []Update `json:"data"`

		// HasMore Whether or not there are more objects after this page in descending order.
		// When false, this page is the final page of objects in descending order.
		HasMore bool `json:"has_more"`

		// TotalCount The total number of objects in `data`.
		TotalCount int              `json:"total_count"`
		Type       IssueUpdatesType `json:"type"`
	} `json:"updates"`
}

// Issue_Links An object describing the various link relations for this type.
type Issue_Links struct {
	ActionCancel         *HALLink           `json:"action:cancel,omitempty"`
	Components           HALLink            `json:"components"`
	Events               HALLink            `json:"events"`
	OgImage              *HALLink           `json:"og:image,omitempty"`
	Self                 HALLink            `json:"self"`
	SelfView             HALLink            `json:"self-view"`
	UpdateForm           HALLink            `json:"update-form"`
	Updates              HALLink            `json:"updates"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// Issue_Components_Links An object describing the various link relations for this type.
type Issue_Components_Links struct {
	Beginning            HALLink            `json:"beginning"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// IssueComponentsType defines model for Issue.Components.Type.
type IssueComponentsType string

// IssueType defines model for Issue.Type.
type IssueType string

// Issue_Updates_Links An object describing the various link relations for this type.
type Issue_Updates_Links struct {
	Beginning            HALLink            `json:"beginning"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// IssueUpdatesType defines model for Issue.Updates.Type.
type IssueUpdatesType string

// IssueFormCancel Issue cancellation form.
type IssueFormCancel struct {
	// Body An optional Issue Update body describing the cancellation.
	Body *IssueFormCancel_Body `json:"body,omitempty"`

	// Template An optional Issue Template which will create an Issue Update describing
	// the cancellation. This field takes precedence over `body`.
	Template *IssueFormCancel_Template `json:"template,omitempty"`
}

// IssueFormCancelBody0 defines model for .
type IssueFormCancelBody0 = string

// IssueFormCancelBody1 defines model for .
type IssueFormCancelBody1 = I18n

// IssueFormCancel_Body An optional Issue Update body describing the cancellation.
type IssueFormCancel_Body struct {
	union json.RawMessage
}

// IssueFormCancelTemplate0 defines model for .
type IssueFormCancelTemplate0 = ObjectId

// IssueFormCancelTemplate1 IssueTemplateApplication creation form.
type IssueFormCancelTemplate1 = IssueTemplateApplicationFormCreate

// IssueFormCancel_Template An optional Issue Template which will create an Issue Update describing
// the cancellation. This field takes precedence over `body`.
type IssueFormCancel_Template struct {
	union json.RawMessage
}

// IssueFormCreate Issue creation form.
type IssueFormCreate struct {
	// BeganAt The UNIX timestamp at which this Issue began affecting its given Components.
	BeganAt *int64 `json:"began_at,omitempty"`

	// Body The initial body text of the issue in raw markdown.
	Body *I18nString `json:"body,omitempty"`

	// Components The Components affected by this Issue.
	Components []ObjectId `json:"components"`

	// EndedAt The UNIX timestamp at which this Issue stopped affecting its given Components. This
	// field is `null` if it has not ended yet.
	EndedAt *int64 `json:"ended_at,omitempty"`

	// Label The initial label applied to the issue. The "current" label of the entire
	// issue may be updated by the labels of Issue Updates, though this must be taken
	// from the latest Update in `updates`.
	Label *MaybeISSUELABEL `json:"label,omitempty"`

	// OpenGraphImageUrl The URL to an image which will be displayed alongside this issue when shared
	// on social media websites.
	OpenGraphImageUrl *MaybeString `json:"open_graph_image_url,omitempty"`

	// Priority The integer priority of the Issue. Priority pertains to how notifications are
	// triggered for this Issue: -1 indicates **low priority**, meaning no
	// notifications whatsoever will be triggered for this issue; 0 indicates
	// **normal priority**, which is the default behavior; and, 1 indicates
	// **high priority**, meaning all subscriptions across all notifiers will receive
	// notifications for this Issue regardless of their notification preferences.
	Priority *IssueFormCreatePriority `json:"priority,omitempty"`

	// Schedule An object detailing the Schedule of this issue if it is scheduled. This field
	// is `null` if the Issue is not scheduled.
	Schedule *ScheduleFormCreate `json:"schedule,omitempty"`

	// StateOverride The integer state which overrides the state of affected Components in
	// `component`. A value of `null` indicates no override is present.
	StateOverride *MaybeIntegerState `json:"state_override,omitempty"`

	// Template The IssueTemplateApplication that this Issue is applied against, which controls
	// the values of `title`, `body`, and `label` when set.
	Template *IssueFormCreate_Template `json:"template,omitempty"`

	// Title The title of the Issue.
	Title *I18nString `json:"title,omitempty"`

	// Updates A PagedArray whose `data` field contains an array of Issue Update objects.
	// This PagedArray will always be completely paged in, so expect `has_more` to
	// always be `false`. The first element of this array is the *latest* Update for
	// this Issue, and should be considered the current status of this Issue.
	Updates *[]UpdateFormCreate `json:"updates,omitempty"`
}

// IssueFormCreatePriority The integer priority of the Issue. Priority pertains to how notifications are
// triggered for this Issue: -1 indicates **low priority**, meaning no
// notifications whatsoever will be triggered for this issue; 0 indicates
// **normal priority**, which is the default behavior; and, 1 indicates
// **high priority**, meaning all subscriptions across all notifiers will receive
// notifications for this Issue regardless of their notification preferences.
type IssueFormCreatePriority int

// IssueFormCreateTemplate0 defines model for .
type IssueFormCreateTemplate0 = ObjectId

// IssueFormCreateTemplate1 IssueTemplateApplication creation form.
type IssueFormCreateTemplate1 = IssueTemplateApplicationIssueFormCreate

// IssueFormCreate_Template The IssueTemplateApplication that this Issue is applied against, which controls
// the values of `title`, `body`, and `label` when set.
type IssueFormCreate_Template struct {
	union json.RawMessage
}

// IssueFormUpdate Issue update form.
type IssueFormUpdate struct {
	// BeganAt The UNIX timestamp at which this Issue began affecting its given Components.
	BeganAt *int64 `json:"began_at,omitempty"`

	// Body The initial body text of the issue in raw markdown.
	Body *I18nString `json:"body,omitempty"`

	// Components The Components affected by this Issue.
	Components *[]ObjectId `json:"components,omitempty"`

	// Label The initial label applied to the issue. The "current" label of the entire
	// issue may be updated by the labels of Issue Updates, though this must be taken
	// from the latest Update in `updates`.
	Label *MaybeISSUELABEL `json:"label,omitempty"`

	// OpenGraphImageUrl The URL to an image which will be displayed alongside this issue when shared
	// on social media websites.
	OpenGraphImageUrl *MaybeString `json:"open_graph_image_url,omitempty"`

	// Priority The integer priority of the Issue. Priority pertains to how notifications are
	// triggered for this Issue: -1 indicates **low priority**, meaning no
	// notifications whatsoever will be triggered for this issue; 0 indicates
	// **normal priority**, which is the default behavior; and, 1 indicates
	// **high priority**, meaning all subscriptions across all notifiers will receive
	// notifications for this Issue regardless of their notification preferences.
	Priority *ISSUEPRIORITY `json:"priority,omitempty"`

	// Schedule An object detailing the Schedule of this issue if it is scheduled. This field
	// is `null` if the Issue is not scheduled.
	Schedule *ScheduleFormUpdate `json:"schedule,omitempty"`

	// StateOverride The integer state which overrides the state of affected Components in
	// `component`. A value of `null` indicates no override is present.
	StateOverride *MaybeIntegerState        `json:"state_override,omitempty"`
	Template      *IssueFormUpdate_Template `json:"template"`

	// Title The title of the Issue.
	Title *I18nString `json:"title,omitempty"`
}

// IssueFormUpdateTemplate0 defines model for .
type IssueFormUpdateTemplate0 = ObjectId

// IssueFormUpdateTemplate1 IssueTemplateApplication creation form.
type IssueFormUpdateTemplate1 = IssueTemplateApplicationIssueFormCreate

// IssueFormUpdateTemplate2 IssueTemplateApplication update form.
type IssueFormUpdateTemplate2 = IssueTemplateApplicationIssueFormUpdate

// IssueFormUpdate_Template defines model for IssueFormUpdate.Template.
type IssueFormUpdate_Template struct {
	union json.RawMessage
}

// IssuePagedArray A cursor-like array object that allows paging through an array of objects.
type IssuePagedArray struct {
	// Links An object describing the various link relations for this type.
	Links *IssuePagedArray_Links `json:"_links,omitempty"`

	// Data An array of the objects in this page.
	Data []Issue `json:"data"`

	// HasMore Whether or not there are more objects after this page in descending order.
	// When false, this page is the final page of objects in descending order.
	HasMore bool `json:"has_more"`

	// TotalCount The total number of objects in `data`.
	TotalCount int                 `json:"total_count"`
	Type       IssuePagedArrayType `json:"type"`
}

// IssuePagedArray_Links An object describing the various link relations for this type.
type IssuePagedArray_Links struct {
	Beginning            HALLink            `json:"beginning"`
	CreateForm           *HALLink           `json:"create-form,omitempty"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// IssuePagedArrayType defines model for IssuePagedArray.Type.
type IssuePagedArrayType string

// IssueTemplate A template for creating Issues, as well as Issue Updates.
type IssueTemplate struct {
	// Links An object describing the various link relations for this type.
	Links *IssueTemplate_Links `json:"_links,omitempty"`

	// Body The body to use for an Issue/Update applied against this template. This field
	// supports Liquid templating.
	Body      MaybeI18nString `json:"body"`
	CreatedAt Timestamp       `json:"created_at"`

	// Id The ObjectId of the IssueTemplate.
	Id ObjectId `json:"id"`

	// Kind The "kind" of this IssueTemplate. This field can be either `issue` or `update`,
	// depending on whether this IssueTemplate can be applied to an Issue or Issue Update,
	// respectively.
	Kind ISSUETEMPLATEKIND `json:"kind"`

	// Label The label to use for an Issue/Update applied against this template.
	Label MaybeISSUETEMPLATELABEL `json:"label"`

	// Name An internal name for identifying this IssueTemplate.
	Name string `json:"name"`

	// Title When `kind` is `issue`, then the applied Issue will take on this title. This
	// field supports Liquid templating.
	Title     MaybeI18nString   `json:"title"`
	Type      IssueTemplateType `json:"type"`
	UpdatedAt Timestamp         `json:"updated_at"`

	// Variables An object defining a set of typed variables that can be provided in an application
	// of this IssueTemplate. The variables can be accessed from any field in the
	// IssueTemplate supporting Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	Variables IssueTemplateVariables `json:"variables"`
}

// IssueTemplate_Links An object describing the various link relations for this type.
type IssueTemplate_Links struct {
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// IssueTemplateType defines model for IssueTemplate.Type.
type IssueTemplateType string

// IssueTemplateApplication An application of an IssueTemplate, which contains a copy of the template fields
// of the associated IssueTemplate, as well as an object of user-defined variables
// that parameterize the template.
//
// Alterations to an IssueTemplateApplication do not affect the associated
// IssueTemplate, and will update the Issue/Update's content accordingly.
// Conversely, modification/deletion of the associated IssueTemplate do not affect
// the IssueTemplateApplication.
type IssueTemplateApplication struct {
	// Links An object describing the various link relations for this type.
	Links *IssueTemplateApplication_Links `json:"_links,omitempty"`

	// Body The Liquid template for the `body` of the applied Issue/Update.
	Body MaybeI18nString `json:"body"`

	// Id The ObjectId of the IssueTemplateApplication.
	Id ObjectId `json:"id"`

	// IssueTemplate The ObjectId of an IssueTemplate to use as the basis of this Application, which
	// will inform the values for `body`, `label`, and `title` (when `kind` == `issue`).
	//
	// If this value is changed in a request, then the application will be re-created
	// according to the values of the given IssueTemplate.
	IssueTemplate ObjectId `json:"issue_template"`

	// Label The template for the `label` of the applied Issue/Update.
	Label MaybeISSUETEMPLATELABEL `json:"label"`

	// Schema An object defining a set of typed variables that can be provided in `variables`.
	// The variables can be accessed from any field in the IssueTemplate supporting
	// Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	//
	// **Note:** this field is normally copied from the underlying `issue_template`,
	// but can be overridden here as necessary. In any case, `variables` must adhere
	// to `schema`.
	Schema IssueTemplateVariables       `json:"schema"`
	Type   IssueTemplateApplicationType `json:"type"`

	// Variables An object of variable assignments used to parameterize the associated IssueTemplate.
	//
	// If the associated IssueTemplate marks a variable as `required`, then it must appear
	// here with an appropriate value.
	Variables IssueTemplateVariablesApplication `json:"variables"`
}

// IssueTemplateApplication_Links An object describing the various link relations for this type.
type IssueTemplateApplication_Links struct {
	IssueTemplate        HALLink            `json:"issue_template"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// IssueTemplateApplicationType defines model for IssueTemplateApplication.Type.
type IssueTemplateApplicationType string

// IssueTemplateApplicationFormCreate IssueTemplateApplication creation form.
type IssueTemplateApplicationFormCreate struct {
	// Body The Liquid template for the `body` of the applied Issue/Update.
	Body *I18nString `json:"body,omitempty"`

	// IssueTemplate The ObjectId of an IssueTemplate to use as the basis of this Application, which
	// will inform the values for `body`, `label`, and `title` (when `kind` == `issue`).
	//
	// If this value is changed in a request, then the application will be re-created
	// according to the values of the given IssueTemplate.
	IssueTemplate ObjectId `json:"issue_template"`

	// Label The template for the `label` of the applied Issue/Update.
	Label *MaybeISSUETEMPLATELABEL `json:"label,omitempty"`

	// Schema An object defining a set of typed variables that can be provided in `variables`.
	// The variables can be accessed from any field in the IssueTemplate supporting
	// Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	//
	// **Note:** this field is normally copied from the underlying `issue_template`,
	// but can be overridden here as necessary. In any case, `variables` must adhere
	// to `schema`.
	Schema *IssueTemplateVariablesForm `json:"schema,omitempty"`

	// Variables An object of variable assignments used to parameterize the associated IssueTemplate.
	//
	// If the associated IssueTemplate marks a variable as `required`, then it must appear
	// here with an appropriate value.
	Variables *IssueTemplateVariablesApplication `json:"variables,omitempty"`
}

// IssueTemplateApplicationFormUpdate IssueTemplateApplication update form.
type IssueTemplateApplicationFormUpdate struct {
	// Body The Liquid template for the `body` of the applied Issue/Update.
	Body *I18nString `json:"body,omitempty"`

	// Label The template for the `label` of the applied Issue/Update.
	Label *MaybeISSUETEMPLATELABEL `json:"label,omitempty"`

	// Schema An object defining a set of typed variables that can be provided in `variables`.
	// The variables can be accessed from any field in the IssueTemplate supporting
	// Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	//
	// **Note:** this field is normally copied from the underlying `issue_template`,
	// but can be overridden here as necessary. In any case, `variables` must adhere
	// to `schema`.
	Schema *IssueTemplateVariablesForm `json:"schema,omitempty"`

	// SyncWithIssueTemplate When true, and given that the `issue_template` field is not changed, causes the
	// request to resynchronize this application's fields with the original `issue_template`.
	//
	// This can be useful to update an Issue or Update according to changes made in
	// the underlying IssueTemplate, when normally an application's fields are allowed
	// to diverge from the template as necessary.
	//
	// **Note:** If the original `issue_template` referenced by this application no
	// longer exists, then a request with `sync_with_issue_template` set true will fail
	// with a 404 error.
	SyncWithIssueTemplate *bool `json:"sync_with_issue_template,omitempty"`

	// Variables An object of variable assignments used to parameterize the associated IssueTemplate.
	//
	// If the associated IssueTemplate marks a variable as `required`, then it must appear
	// here with an appropriate value.
	Variables *IssueTemplateVariablesApplication `json:"variables,omitempty"`
}

// IssueTemplateApplicationIssue An application of an IssueTemplate, which contains a copy of the template fields
// of the associated IssueTemplate, as well as an object of user-defined variables
// that parameterize the template.
//
// Alterations to an IssueTemplateApplication do not affect the associated
// IssueTemplate, and will update the Issue/Update's content accordingly.
// Conversely, modification/deletion of the associated IssueTemplate do not affect
// the IssueTemplateApplication.
type IssueTemplateApplicationIssue struct {
	// Links An object describing the various link relations for this type.
	Links *IssueTemplateApplicationIssue_Links `json:"_links,omitempty"`

	// Body The Liquid template for the `body` of the applied Issue/Update.
	Body MaybeI18nString `json:"body"`

	// Id The ObjectId of the IssueTemplateApplication.
	Id ObjectId `json:"id"`

	// IssueTemplate The ObjectId of an IssueTemplate to use as the basis of this Application, which
	// will inform the values for `body`, `label`, and `title` (when `kind` == `issue`).
	//
	// If this value is changed in a request, then the application will be re-created
	// according to the values of the given IssueTemplate.
	IssueTemplate ObjectId `json:"issue_template"`

	// Label The template for the `label` of the applied Issue/Update.
	Label MaybeISSUETEMPLATELABEL `json:"label"`

	// Schema An object defining a set of typed variables that can be provided in `variables`.
	// The variables can be accessed from any field in the IssueTemplate supporting
	// Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	//
	// **Note:** this field is normally copied from the underlying `issue_template`,
	// but can be overridden here as necessary. In any case, `variables` must adhere
	// to `schema`.
	Schema IssueTemplateVariables `json:"schema"`

	// Title The Liquid template for the `title` of the applied Issue.
	Title MaybeI18nString                   `json:"title"`
	Type  IssueTemplateApplicationIssueType `json:"type"`

	// Variables An object of variable assignments used to parameterize the associated IssueTemplate.
	//
	// If the associated IssueTemplate marks a variable as `required`, then it must appear
	// here with an appropriate value.
	Variables IssueTemplateVariablesApplication `json:"variables"`
}

// IssueTemplateApplicationIssue_Links An object describing the various link relations for this type.
type IssueTemplateApplicationIssue_Links struct {
	IssueTemplate        HALLink            `json:"issue_template"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// IssueTemplateApplicationIssueType defines model for IssueTemplateApplicationIssue.Type.
type IssueTemplateApplicationIssueType string

// IssueTemplateApplicationIssueFormCreate IssueTemplateApplication creation form.
type IssueTemplateApplicationIssueFormCreate struct {
	// Body The Liquid template for the `body` of the applied Issue/Update.
	Body *I18nString `json:"body,omitempty"`

	// IssueTemplate The ObjectId of an IssueTemplate to use as the basis of this Application, which
	// will inform the values for `body`, `label`, and `title` (when `kind` == `issue`).
	//
	// If this value is changed in a request, then the application will be re-created
	// according to the values of the given IssueTemplate.
	IssueTemplate ObjectId `json:"issue_template"`

	// Label The template for the `label` of the applied Issue/Update.
	Label *MaybeISSUETEMPLATELABEL `json:"label,omitempty"`

	// Schema An object defining a set of typed variables that can be provided in `variables`.
	// The variables can be accessed from any field in the IssueTemplate supporting
	// Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	//
	// **Note:** this field is normally copied from the underlying `issue_template`,
	// but can be overridden here as necessary. In any case, `variables` must adhere
	// to `schema`.
	Schema *IssueTemplateVariablesForm `json:"schema,omitempty"`

	// Title The Liquid template for the `title` of the applied Issue.
	Title *I18nString `json:"title,omitempty"`

	// Variables An object of variable assignments used to parameterize the associated IssueTemplate.
	//
	// If the associated IssueTemplate marks a variable as `required`, then it must appear
	// here with an appropriate value.
	Variables *IssueTemplateVariablesApplication `json:"variables,omitempty"`
}

// IssueTemplateApplicationIssueFormUpdate IssueTemplateApplication update form.
type IssueTemplateApplicationIssueFormUpdate struct {
	// Body The Liquid template for the `body` of the applied Issue/Update.
	Body *I18nString `json:"body,omitempty"`

	// Label The template for the `label` of the applied Issue/Update.
	Label *MaybeISSUETEMPLATELABEL `json:"label,omitempty"`

	// Schema An object defining a set of typed variables that can be provided in `variables`.
	// The variables can be accessed from any field in the IssueTemplate supporting
	// Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	//
	// **Note:** this field is normally copied from the underlying `issue_template`,
	// but can be overridden here as necessary. In any case, `variables` must adhere
	// to `schema`.
	Schema *IssueTemplateVariablesForm `json:"schema,omitempty"`

	// SyncWithIssueTemplate When true, and given that the `issue_template` field is not changed, causes the
	// request to resynchronize this application's fields with the original `issue_template`.
	//
	// This can be useful to update an Issue or Update according to changes made in
	// the underlying IssueTemplate, when normally an application's fields are allowed
	// to diverge from the template as necessary.
	//
	// **Note:** If the original `issue_template` referenced by this application no
	// longer exists, then a request with `sync_with_issue_template` set true will fail
	// with a 404 error.
	SyncWithIssueTemplate *bool `json:"sync_with_issue_template,omitempty"`

	// Title The Liquid template for the `title` of the applied Issue.
	Title *I18nString `json:"title,omitempty"`

	// Variables An object of variable assignments used to parameterize the associated IssueTemplate.
	//
	// If the associated IssueTemplate marks a variable as `required`, then it must appear
	// here with an appropriate value.
	Variables *IssueTemplateVariablesApplication `json:"variables,omitempty"`
}

// IssueTemplateFormCreate IssueTemplate creation form.
type IssueTemplateFormCreate struct {
	// Body The body to use for an Issue/Update applied against this template. This field
	// supports Liquid templating.
	Body *I18nString `json:"body,omitempty"`

	// Kind The "kind" of this IssueTemplate. This field can be either `issue` or `update`,
	// depending on whether this IssueTemplate can be applied to an Issue or Issue Update,
	// respectively.
	Kind ISSUETEMPLATEKIND `json:"kind"`

	// Label The label to use for an Issue/Update applied against this template.
	Label *ISSUETEMPLATELABEL `json:"label,omitempty"`

	// Name An internal name for identifying this IssueTemplate.
	Name string `json:"name"`

	// Title When `kind` is `issue`, then the applied Issue will take on this title. This
	// field supports Liquid templating.
	Title *I18nString `json:"title,omitempty"`

	// Variables An object defining a set of typed variables that can be provided in an application
	// of this IssueTemplate. The variables can be accessed from any field in the
	// IssueTemplate supporting Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	Variables *IssueTemplateVariablesForm `json:"variables,omitempty"`
}

// IssueTemplateFormUpdate IssueTemplate update form.
type IssueTemplateFormUpdate struct {
	// Body The body to use for an Issue/Update applied against this template. This field
	// supports Liquid templating.
	Body *I18nString `json:"body,omitempty"`

	// Label The label to use for an Issue/Update applied against this template.
	Label *ISSUETEMPLATELABEL `json:"label,omitempty"`

	// Name An internal name for identifying this IssueTemplate.
	Name *string `json:"name,omitempty"`

	// Title When `kind` is `issue`, then the applied Issue will take on this title. This
	// field supports Liquid templating.
	Title *I18nString `json:"title,omitempty"`

	// Variables An object defining a set of typed variables that can be provided in an application
	// of this IssueTemplate. The variables can be accessed from any field in the
	// IssueTemplate supporting Liquid.
	//
	// Each defined variable can be given an expected type, and can be marked as required.
	Variables *IssueTemplateVariablesForm `json:"variables,omitempty"`
}

// IssueTemplatePagedArray A cursor-like array object that allows paging through an array of objects.
type IssueTemplatePagedArray struct {
	// Links An object describing the various link relations for this type.
	Links *IssueTemplatePagedArray_Links `json:"_links,omitempty"`

	// Data An array of the objects in this page.
	Data []IssueTemplate `json:"data"`

	// HasMore Whether or not there are more objects after this page in descending order.
	// When false, this page is the final page of objects in descending order.
	HasMore bool `json:"has_more"`

	// TotalCount The total number of objects in `data`.
	TotalCount int                         `json:"total_count"`
	Type       IssueTemplatePagedArrayType `json:"type"`
}

// IssueTemplatePagedArray_Links An object describing the various link relations for this type.
type IssueTemplatePagedArray_Links struct {
	Beginning            HALLink            `json:"beginning"`
	CreateForm           *HALLink           `json:"create-form,omitempty"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// IssueTemplatePagedArrayType defines model for IssueTemplatePagedArray.Type.
type IssueTemplatePagedArrayType string

// IssueTemplateVariable defines model for IssueTemplateVariable.
type IssueTemplateVariable struct {
	Required bool                      `json:"required"`
	Type     ISSUETEMPLATEVARIABLETYPE `json:"type"`
}

// IssueTemplateVariableApplication defines model for IssueTemplateVariable::Application.
type IssueTemplateVariableApplication struct {
	union json.RawMessage
}

// IssueTemplateVariableApplication0 defines model for .
type IssueTemplateVariableApplication0 = IssueTemplateVariableApplicationNumber

// IssueTemplateVariableApplication1 defines model for .
type IssueTemplateVariableApplication1 = IssueTemplateVariableApplicationDatetime

// IssueTemplateVariableApplication2 defines model for .
type IssueTemplateVariableApplication2 = IssueTemplateVariableApplicationString

// IssueTemplateVariableApplication3 defines model for .
type IssueTemplateVariableApplication3 = IssueTemplateVariableApplicationI18nString

// IssueTemplateVariableApplicationDatetime defines model for IssueTemplateVariable::Application::Datetime.
type IssueTemplateVariableApplicationDatetime = int64

// IssueTemplateVariableApplicationI18nString defines model for IssueTemplateVariable::Application::I18nString.
type IssueTemplateVariableApplicationI18nString map[string]string

// IssueTemplateVariableApplicationNumber defines model for IssueTemplateVariable::Application::Number.
type IssueTemplateVariableApplicationNumber = float64

// IssueTemplateVariableApplicationString defines model for IssueTemplateVariable::Application::String.
type IssueTemplateVariableApplicationString = string

// IssueTemplateVariableForm defines model for IssueTemplateVariable::Form.
type IssueTemplateVariableForm struct {
	Required *bool                          `json:"required,omitempty"`
	Type     *IssueTemplateVariableFormType `json:"type,omitempty"`
}

// IssueTemplateVariableFormType defines model for IssueTemplateVariableForm.Type.
type IssueTemplateVariableFormType string

// IssueTemplateVariables defines model for IssueTemplateVariables.
type IssueTemplateVariables map[string]IssueTemplateVariable

// IssueTemplateVariablesApplication defines model for IssueTemplateVariables::Application.
type IssueTemplateVariablesApplication map[string]IssueTemplateVariableApplication

// IssueTemplateVariablesForm defines model for IssueTemplateVariables::Form.
type IssueTemplateVariablesForm map[string]IssueTemplateVariableForm

// METRICAGGREGATION defines model for METRIC_AGGREGATION.
type METRICAGGREGATION string

// METRICAXISTYPE defines model for METRIC_AXIS_TYPE.
type METRICAXISTYPE string

// METRICINTERPOLATION defines model for METRIC_INTERPOLATION.
type METRICINTERPOLATION string

// METRICPLOTTYPE defines model for METRIC_PLOT_TYPE.
type METRICPLOTTYPE string

// Manual A manually updated watchdog.
type Manual struct {
	State IntegerState `json:"state"`
	Type  ManualType   `json:"type"`
}

// ManualType defines model for Manual.Type.
type ManualType string

// ManualFormCreate Manual service creation form.
type ManualFormCreate struct {
	State IntegerState         `json:"state"`
	Type  ManualFormCreateType `json:"type"`
}

// ManualFormCreateType defines model for ManualFormCreate.Type.
type ManualFormCreateType string

// ManualFormUpdate Manual service update form.
type ManualFormUpdate struct {
	State *IntegerState `json:"state,omitempty"`
}

// MaybeHTTPResponseCode defines model for Maybe(HTTP::ResponseCode).
type MaybeHTTPResponseCode = *HTTPResponseCode

// MaybeISSUELABEL defines model for Maybe(ISSUE_LABEL).
type MaybeISSUELABEL = *ISSUELABEL

// MaybeISSUETEMPLATELABEL defines model for Maybe(ISSUE_TEMPLATE_LABEL).
type MaybeISSUETEMPLATELABEL = *ISSUETEMPLATELABEL

// MaybeIssueTemplateApplication An application of an IssueTemplate, which contains a copy of the template fields
// of the associated IssueTemplate, as well as an object of user-defined variables
// that parameterize the template.
//
// Alterations to an IssueTemplateApplication do not affect the associated
// IssueTemplate, and will update the Issue/Update's content accordingly.
// Conversely, modification/deletion of the associated IssueTemplate do not affect
// the IssueTemplateApplication.
type MaybeIssueTemplateApplication = *IssueTemplateApplication

// MaybeIssueTemplateApplicationIssue An application of an IssueTemplate, which contains a copy of the template fields
// of the associated IssueTemplate, as well as an object of user-defined variables
// that parameterize the template.
//
// Alterations to an IssueTemplateApplication do not affect the associated
// IssueTemplate, and will update the Issue/Update's content accordingly.
// Conversely, modification/deletion of the associated IssueTemplate do not affect
// the IssueTemplateApplication.
type MaybeIssueTemplateApplicationIssue = *IssueTemplateApplicationIssue

// MaybeObjectId defines model for Maybe(ObjectId).
type MaybeObjectId = *ObjectId

// MaybeSchedule An Issue Schedule, which describes the schedule of an issue, including start
// and end times, in addition to an optional "upcoming" notification.
type MaybeSchedule = *Schedule

// MaybeUPDATELABEL defines model for Maybe(UPDATE_LABEL).
type MaybeUPDATELABEL = *UPDATELABEL

// MaybeDeadmanConsecutiveChecks defines model for Maybe(deadman-consecutive-checks).
type MaybeDeadmanConsecutiveChecks = *DeadmanConsecutiveChecks

// MaybeDeadmanReportingInterval defines model for Maybe(deadman-reporting-interval).
type MaybeDeadmanReportingInterval = *DeadmanReportingInterval

// MaybeIntegerState An integer denoting operational state (1 => operational, 0 => degraded, -1 => outage).
type MaybeIntegerState = *IntegerState

// MaybeNonnegativeInteger defines model for Maybe(nonnegative-integer).
type MaybeNonnegativeInteger = *NonnegativeInteger

// MetricInstance MetricInstances describe the particular structure and options for a metric
// provided by a MetricProvider.
type MetricInstance struct {
	// Aggregation The kind of aggregation method to use in case multiple displayed data points
	// share the same time-axis value (depending on the axis configured for time, by
	// default x). **Note:** this field does not have any effect on the underlying
	// data; it is purely cosmetic, and applied only when viewing the data on the
	// status page.
	Aggregation METRICAGGREGATION `json:"aggregation"`

	// DefinitionSlug A descriptive string that identifies the metric definition this instance
	// derives from (e.g. `http.tcp_connection_time`, `apdex`, etc.).
	DefinitionSlug NamespacedSlug `json:"definition_slug"`

	// Enabled Whether or not to show this metric on the Component that uses it (through
	// the Watchdog).
	Enabled bool `json:"enabled"`

	// Id The ObjectId of the MetricInstance.
	Id ObjectId `json:"id"`

	// Interpolation The kind of interpolation to use between points displayed in the graph (line
	// plots only).
	Interpolation METRICINTERPOLATION `json:"interpolation"`

	// PlotType The kind of visualization to display the metric with.
	PlotType METRICPLOTTYPE `json:"plot_type"`

	// Slug A string that uniquely identifies this MetricInstance by referencing the
	// definition slug and MetricProvider ObjectId.
	Slug string `json:"slug"`

	// Title The title of the metric, displayed above its graph on the status page.
	Title I18nString `json:"title"`

	// TopLevelEnabled Whether or not to show this metric on the status page home.
	TopLevelEnabled bool               `json:"top_level_enabled"`
	Type            MetricInstanceType `json:"type"`

	// XTitle The title of the x-axis of this metric.
	XTitle I18nString `json:"x_title"`

	// XType The type of quantity represented by the x-axis.
	XType METRICAXISTYPE `json:"x_type"`

	// YSupremum The least upper bound to display the y-axis on. The metric will always display
	// up to at least this value on the y-axis regardless of the graphed data. If the
	// graph exceeds this value, then the bound will be raised as much as necessary
	// to accommodate the data.
	YSupremum NonnegativeNumber `json:"y_supremum"`

	// YTitle The title of the y-axis of this metric.
	YTitle I18nString `json:"y_title"`

	// YType The type of quantity represented by the y-axis.
	YType METRICAXISTYPE `json:"y_type"`
}

// MetricInstanceType defines model for MetricInstance.Type.
type MetricInstanceType string

// MetricInstanceFormCreate MetricInstance creation form.
type MetricInstanceFormCreate struct {
	// Aggregation The kind of aggregation method to use in case multiple displayed data points
	// share the same time-axis value (depending on the axis configured for time, by
	// default x). **Note:** this field does not have any effect on the underlying
	// data; it is purely cosmetic, and applied only when viewing the data on the
	// status page.
	Aggregation *METRICAGGREGATION `json:"aggregation,omitempty"`

	// DefinitionSlug A descriptive string that identifies the metric definition this instance
	// derives from (e.g. `http.tcp_connection_time`, `apdex`, etc.).
	DefinitionSlug string `json:"definition_slug"`

	// Enabled Whether or not to show this metric on the Component that uses it (through
	// the Watchdog).
	Enabled *bool `json:"enabled,omitempty"`

	// PlotType The kind of visualization to display the metric with.
	PlotType *METRICPLOTTYPE `json:"plot_type,omitempty"`

	// Title The title of the metric, displayed above its graph on the status page.
	Title *MetricInstanceFormCreate_Title `json:"title,omitempty"`

	// TopLevelEnabled Whether or not to show this metric on the status page home.
	TopLevelEnabled *bool `json:"top_level_enabled,omitempty"`

	// XTitle The title of the x-axis of this metric.
	XTitle *I18nString `json:"x_title,omitempty"`

	// XType The type of quantity represented by the x-axis.
	XType *METRICAXISTYPE `json:"x_type,omitempty"`

	// YSupremum The least upper bound to display the y-axis on. The metric will always display
	// up to at least this value on the y-axis regardless of the graphed data. If the
	// graph exceeds this value, then the bound will be raised as much as necessary
	// to accommodate the data.
	YSupremum *NonnegativeNumber `json:"y_supremum,omitempty"`

	// YTitle The title of the y-axis of this metric.
	YTitle *I18nString `json:"y_title,omitempty"`

	// YType The type of quantity represented by the y-axis.
	YType *METRICAXISTYPE `json:"y_type,omitempty"`
}

// MetricInstanceFormCreateTitle0 defines model for .
type MetricInstanceFormCreateTitle0 = string

// MetricInstanceFormCreateTitle1 defines model for .
type MetricInstanceFormCreateTitle1 = I18n

// MetricInstanceFormCreate_Title The title of the metric, displayed above its graph on the status page.
type MetricInstanceFormCreate_Title struct {
	union json.RawMessage
}

// MetricInstanceFormEmbeddedUpdate MetricInstance embedded update form, for use in MetricProvider updates.
type MetricInstanceFormEmbeddedUpdate struct {
	// Aggregation The kind of aggregation method to use in case multiple displayed data points
	// share the same time-axis value (depending on the axis configured for time, by
	// default x). **Note:** this field does not have any effect on the underlying
	// data; it is purely cosmetic, and applied only when viewing the data on the
	// status page.
	Aggregation *METRICAGGREGATION `json:"aggregation,omitempty"`

	// DefinitionSlug A descriptive string that identifies the metric definition this instance
	// derives from (e.g. `http.tcp_connection_time`, `apdex`, etc.).
	DefinitionSlug string `json:"definition_slug"`

	// Deleted If this field is set to true, then this MetricInstance given by `id` will
	// be deleted from the MetricProvider.
	Deleted *bool `json:"deleted,omitempty"`

	// Enabled Whether or not to show this metric on the Component that uses it (through
	// the Watchdog).
	Enabled *bool `json:"enabled,omitempty"`

	// PlotType The kind of visualization to display the metric with.
	PlotType *METRICPLOTTYPE `json:"plot_type,omitempty"`

	// Title The title of the metric, displayed above its graph on the status page.
	Title *I18nString `json:"title,omitempty"`

	// TopLevelEnabled Whether or not to show this metric on the status page home.
	TopLevelEnabled *bool `json:"top_level_enabled,omitempty"`

	// XTitle The title of the x-axis of this metric.
	XTitle *I18nString `json:"x_title,omitempty"`

	// XType The type of quantity represented by the x-axis.
	XType *METRICAXISTYPE `json:"x_type,omitempty"`

	// YSupremum The least upper bound to display the y-axis on. The metric will always display
	// up to at least this value on the y-axis regardless of the graphed data. If the
	// graph exceeds this value, then the bound will be raised as much as necessary
	// to accommodate the data.
	YSupremum *NonnegativeNumber `json:"y_supremum,omitempty"`

	// YTitle The title of the y-axis of this metric.
	YTitle *I18nString `json:"y_title,omitempty"`

	// YType The type of quantity represented by the y-axis.
	YType *METRICAXISTYPE `json:"y_type,omitempty"`
}

// MetricProvider MetricProviders gather metrics from a configured service for viewing on the
// Status Page.
type MetricProvider struct {
	// Links An object describing the various link relations for this type.
	Links *MetricProvider_Links `json:"_links,omitempty"`

	// Default When true, denotes that this MetricProvider is the default MetricProvider of
	// the Watchdog. This means that they share the same service configuration, which
	// the MetricProvider inherits from the Watchdog. This MetricProvider is created
	// automatically depending on the Watchdog, and cannot be deleted without also
	// deleting the Watchdog.
	Default bool `json:"default"`

	// Id The ObjectId of this MetricProvider.
	Id ObjectId `json:"id"`

	// Instances An array of MetricInstances, which describe each Metric that the
	// MetricProvider provides.
	Instances []MetricInstance `json:"instances"`

	// Service The service configuration for this MetricProvider, which describes how the
	// given `instances` are provided.
	Service ServicesMetricProvider `json:"service"`
	Type    MetricProviderType     `json:"type"`

	// Watchdog The Watchdog that owns this MetricProvider.
	Watchdog string `json:"watchdog"`
}

// MetricProvider_Links An object describing the various link relations for this type.
type MetricProvider_Links struct {
	Events               HALLink            `json:"events"`
	Self                 HALLink            `json:"self"`
	Watchdog             HALLink            `json:"watchdog"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// MetricProviderType defines model for MetricProvider.Type.
type MetricProviderType string

// MetricProviderFormCreate MetricProvider creation form.
type MetricProviderFormCreate struct {
	// Instances An array of MetricInstances, which describe each Metric that the
	// MetricProvider provides.
	Instances []MetricInstanceFormCreate `json:"instances"`

	// Service The service configuration for this MetricProvider, which describes how the
	// given `instances` are provided.
	Service FormMetricProviderCreate `json:"service"`

	// Watchdog The Watchdog that owns this MetricProvider.
	Watchdog ObjectId `json:"watchdog"`
}

// MetricProviderFormDefaultCreate MetricProvider creation form.
type MetricProviderFormDefaultCreate struct {
	// Instances An array of MetricInstances, which describe each Metric that the
	// MetricProvider provides.
	Instances []MetricInstanceFormCreate `json:"instances"`
}

// MetricProviderFormDefaultUpdate MetricProvider update form.
type MetricProviderFormDefaultUpdate struct {
	// Instances An array of MetricInstances, which describe each Metric that the
	// MetricProvider provides.
	Instances *[]MetricProviderFormDefaultUpdate_Instances_Item `json:"instances,omitempty"`
}

// MetricProviderFormDefaultUpdateInstances0 MetricInstance creation form.
type MetricProviderFormDefaultUpdateInstances0 = MetricInstanceFormCreate

// MetricProviderFormDefaultUpdateInstances1 MetricInstance embedded update form, for use in MetricProvider updates.
type MetricProviderFormDefaultUpdateInstances1 = MetricInstanceFormEmbeddedUpdate

// MetricProviderFormDefaultUpdate_Instances_Item defines model for MetricProvider::Form::DefaultUpdate.instances.Item.
type MetricProviderFormDefaultUpdate_Instances_Item struct {
	union json.RawMessage
}

// MetricProviderFormEmbeddedCreate MetricProvider creation form.
type MetricProviderFormEmbeddedCreate struct {
	// Instances An array of MetricInstances, which describe each Metric that the
	// MetricProvider provides.
	Instances []MetricInstanceFormCreate `json:"instances"`

	// Service The service configuration for this MetricProvider, which describes how the
	// given `instances` are provided.
	Service FormMetricProviderCreate `json:"service"`
}

// MetricProviderFormEmbeddedUpdate MetricProvider update form.
type MetricProviderFormEmbeddedUpdate struct {
	// Id The ObjectId of this MetricProvider.
	Id ObjectId `json:"id"`

	// Instances An array of MetricInstances, which describe each Metric that the
	// MetricProvider provides.
	Instances *[]MetricProviderFormEmbeddedUpdate_Instances_Item `json:"instances,omitempty"`

	// Service The service configuration for this MetricProvider, which describes how the
	// given `instances` are provided.
	Service *FormMetricProviderUpdate `json:"service,omitempty"`
}

// MetricProviderFormEmbeddedUpdateInstances0 MetricInstance creation form.
type MetricProviderFormEmbeddedUpdateInstances0 = MetricInstanceFormCreate

// MetricProviderFormEmbeddedUpdateInstances1 MetricInstance embedded update form, for use in MetricProvider updates.
type MetricProviderFormEmbeddedUpdateInstances1 = MetricInstanceFormEmbeddedUpdate

// MetricProviderFormEmbeddedUpdate_Instances_Item defines model for MetricProvider::Form::EmbeddedUpdate.instances.Item.
type MetricProviderFormEmbeddedUpdate_Instances_Item struct {
	union json.RawMessage
}

// MetricProviderFormUpdate MetricProvider update form.
type MetricProviderFormUpdate struct {
	// Instances An array of MetricInstances, which describe each Metric that the
	// MetricProvider provides.
	Instances *[]MetricProviderFormUpdate_Instances_Item `json:"instances,omitempty"`

	// Service The service configuration for this MetricProvider, which describes how the
	// given `instances` are provided.
	Service *FormMetricProviderUpdate `json:"service,omitempty"`
}

// MetricProviderFormUpdateInstances0 MetricInstance creation form.
type MetricProviderFormUpdateInstances0 = MetricInstanceFormCreate

// MetricProviderFormUpdateInstances1 MetricInstance embedded update form, for use in MetricProvider updates.
type MetricProviderFormUpdateInstances1 = MetricInstanceFormEmbeddedUpdate

// MetricProviderFormUpdate_Instances_Item defines model for MetricProvider::Form::Update.instances.Item.
type MetricProviderFormUpdate_Instances_Item struct {
	union json.RawMessage
}

// MetricProviderPagedArray A cursor-like array object that allows paging through an array of objects.
type MetricProviderPagedArray struct {
	// Links An object describing the various link relations for this type.
	Links *MetricProviderPagedArray_Links `json:"_links,omitempty"`

	// Data An array of the objects in this page.
	Data []MetricProvider `json:"data"`

	// HasMore Whether or not there are more objects after this page in descending order.
	// When false, this page is the final page of objects in descending order.
	HasMore bool `json:"has_more"`

	// TotalCount The total number of objects in `data`.
	TotalCount int                          `json:"total_count"`
	Type       MetricProviderPagedArrayType `json:"type"`
}

// MetricProviderPagedArray_Links An object describing the various link relations for this type.
type MetricProviderPagedArray_Links struct {
	Beginning            HALLink            `json:"beginning"`
	CreateForm           *HALLink           `json:"create-form,omitempty"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// MetricProviderPagedArrayType defines model for MetricProviderPagedArray.Type.
type MetricProviderPagedArrayType string

// NATIVEDNSRECORDTYPE defines model for NATIVE_DNS_RECORD_TYPE.
type NATIVEDNSRECORDTYPE string

// NATIVEDNSRESPONSECONTAINMENT defines model for NATIVE_DNS_RESPONSE_CONTAINMENT.
type NATIVEDNSRESPONSECONTAINMENT string

// NATIVEIPVERSION defines model for NATIVE_IP_VERSION.
type NATIVEIPVERSION string

// NATIVEREGION defines model for NATIVE_REGION.
type NATIVEREGION string

// NATIVESTRINGCONTAINMENTMODE defines model for NATIVE_STRING_CONTAINMENT_MODE.
type NATIVESTRINGCONTAINMENTMODE string

// NEWRELICAPIREGION defines model for NEWRELIC_API_REGION.
type NEWRELICAPIREGION string

// Native Hund's builtin monitoring service, offered free-of-charge with a Hund status
// page. This service can watch the status of any ICMP, HTTP, DNS, TCP, or UDP
// endpoint. For more information about this service, visit our
// [knowledge base](https://hund.io/help/integrations/hund-native-monitoring).
type Native struct {
	union json.RawMessage
}

// Native0 A Hund Native Monitoring ICMP Check.
type Native0 = ICMP

// Native1 A Hund Native Monitoring HTTP Check.
type Native1 = HTTP

// Native2 A Hund Native Monitoring DNS Check.
type Native2 = DNS

// Native3 A Hund Native Monitoring TCP Check.
type Native3 = TCP

// Native4 A Hund Native Monitoring UDP Check.
type Native4 = UDP

// NativeFormCreate Hund Native Monitoring service creation form.
type NativeFormCreate struct {
	union json.RawMessage
}

// NativeFormCreate0 Hund Native Monitoring ICMP Check creation form.
type NativeFormCreate0 = ICMPFormCreate

// NativeFormCreate1 Hund Native Monitoring HTTP Check creation form.
type NativeFormCreate1 = HTTPFormCreate

// NativeFormCreate2 Hund Native Monitoring DNS Check creation form.
type NativeFormCreate2 = DNSFormCreate

// NativeFormCreate3 Hund Native Monitoring TCP Check creation form.
type NativeFormCreate3 = TCPFormCreate

// NativeFormCreate4 Hund Native Monitoring UDP Check creation form.
type NativeFormCreate4 = UDPFormCreate

// NativeFormUpdate Hund Native Monitoring service update form.
type NativeFormUpdate struct {
	union json.RawMessage
}

// NativeFormUpdate0 Hund Native Monitoring ICMP Check update form.
type NativeFormUpdate0 = ICMPFormUpdate

// NativeFormUpdate1 Hund Native Monitoring HTTP Check creation form.
type NativeFormUpdate1 = HTTPFormUpdate

// NativeFormUpdate2 Hund Native Monitoring DNS Check update form.
type NativeFormUpdate2 = DNSFormUpdate

// NativeFormUpdate3 Hund Native Monitoring TCP Check update form.
type NativeFormUpdate3 = TCPFormUpdate

// NativeFormUpdate4 Hund Native Monitoring UDP Check update form.
type NativeFormUpdate4 = UDPFormUpdate

// Newrelic A [New Relic Alerts](https://docs.newrelic.com/docs/alerts) service. This watchdog can
// create/resolve issues based on New Relic Alerts.
type Newrelic struct {
	// AlertPolicies The specific New Relic Alerts policy IDs to track on this Watchdog.
	AlertPolicies []string `json:"alert_policies"`

	// ApiRegion The API region to access.
	ApiRegion NEWRELICAPIREGION `json:"api_region"`

	// IssueTemplates An object of IssueTemplate IDs to create Issues/Updates whenever this Watchdog
	// changes state. This Watchdog will create Issues from the `degraded` template
	// for violations with warning severity, and `outage` for those with critical severity.
	//
	// When multiple violations are present, the highest severity of the violations will be used.
	//
	// Once a Watchdog in degraded/outage finds that there are no longer unresolved
	// violations, it will resolve Issues via the `operational` template.
	//
	// If any of the given templates are `null`, then the Watchdog will not create
	// an Issue/Update in that case.
	IssueTemplates WatchdogIssueTemplates `json:"issue_templates"`

	// SuppressFutureIssues When `true`, suppresses newly triggered violations from Alerts when a New
	// Relic issue is already ongoing for the policy.
	SuppressFutureIssues bool `json:"suppress_future_issues"`

	// SuppressWarningViolations When `true`, suppresses all warning violations from New Relic Alerts.
	SuppressWarningViolations bool         `json:"suppress_warning_violations"`
	Type                      NewrelicType `json:"type"`
}

// NewrelicType defines model for Newrelic.Type.
type NewrelicType string

// NewrelicFormCreate New Relic service creation form.
type NewrelicFormCreate struct {
	// AlertPolicies The specific New Relic Alerts policy IDs to track on this Watchdog.
	AlertPolicies []string `json:"alert_policies"`

	// ApiKey The New Relic API key.
	ApiKey string `json:"api_key"`

	// ApiRegion The API region to access.
	ApiRegion *NewrelicFormCreateApiRegion `json:"api_region,omitempty"`

	// IssueTemplates An object of IssueTemplate IDs to create Issues/Updates whenever this Watchdog
	// changes state. This Watchdog will create Issues from the `degraded` template
	// for violations with warning severity, and `outage` for those with critical severity.
	//
	// When multiple violations are present, the highest severity of the violations will be used.
	//
	// Once a Watchdog in degraded/outage finds that there are no longer unresolved
	// violations, it will resolve Issues via the `operational` template.
	//
	// If any of the given templates are `null`, then the Watchdog will not create
	// an Issue/Update in that case.
	IssueTemplates *WatchdogIssueTemplates `json:"issue_templates,omitempty"`

	// SuppressFutureIssues When `true`, suppresses newly triggered violations from Alerts when a New
	// Relic issue is already ongoing for the policy.
	SuppressFutureIssues *bool `json:"suppress_future_issues,omitempty"`

	// SuppressWarningViolations When `true`, suppresses all warning violations from New Relic Alerts.
	SuppressWarningViolations *bool                  `json:"suppress_warning_violations,omitempty"`
	Type                      NewrelicFormCreateType `json:"type"`
}

// NewrelicFormCreateApiRegion The API region to access.
type NewrelicFormCreateApiRegion string

// NewrelicFormCreateType defines model for NewrelicFormCreate.Type.
type NewrelicFormCreateType string

// NewrelicFormUpdate New Relic service update form.
type NewrelicFormUpdate struct {
	// AlertPolicies The specific New Relic Alerts policy IDs to track on this Watchdog.
	AlertPolicies *[]string `json:"alert_policies,omitempty"`

	// ApiKey The New Relic API key.
	ApiKey *string `json:"api_key,omitempty"`

	// ApiRegion The API region to access.
	ApiRegion *NEWRELICAPIREGION `json:"api_region,omitempty"`

	// IssueTemplates An object of IssueTemplate IDs to create Issues/Updates whenever this Watchdog
	// changes state. This Watchdog will create Issues from the `degraded` template
	// for violations with warning severity, and `outage` for those with critical severity.
	//
	// When multiple violations are present, the highest severity of the violations will be used.
	//
	// Once a Watchdog in degraded/outage finds that there are no longer unresolved
	// violations, it will resolve Issues via the `operational` template.
	//
	// If any of the given templates are `null`, then the Watchdog will not create
	// an Issue/Update in that case.
	IssueTemplates *WatchdogIssueTemplates `json:"issue_templates,omitempty"`

	// SuppressFutureIssues When `true`, suppresses newly triggered violations from Alerts when a New
	// Relic issue is already ongoing for the policy.
	SuppressFutureIssues *bool `json:"suppress_future_issues,omitempty"`

	// SuppressWarningViolations When `true`, suppresses all warning violations from New Relic Alerts.
	SuppressWarningViolations *bool `json:"suppress_warning_violations,omitempty"`
}

// ObjectId defines model for ObjectId.
type ObjectId = string

// PINGDOMCHECKTYPE defines model for PINGDOM_CHECK_TYPE.
type PINGDOMCHECKTYPE string

// Pagerduty A [PagerDuty](https://www.pagerduty.com/) service. This watchdog can
// create/resolve issues based on PagerDuty incidents.
type Pagerduty struct {
	// IssueTemplates An object of IssueTemplate IDs to create Issues/Updates whenever this Watchdog
	// changes state. This Watchdog will create Issues from the `degraded` template
	// for incidents with low urgency, and `outage` for those with high urgency.
	//
	// When multiple incidents are present, the highest urgency of the incidents will be used.
	//
	// Once a Watchdog in degraded/outage finds that there are no longer unresolved
	// incidents, it will resolve Issues via the `operational` template.
	//
	// If any of the given templates are `null`, then the Watchdog will not create
	// an Issue/Update in that case.
	IssueTemplates WatchdogIssueTemplates `json:"issue_templates"`

	// Services An array of PagerDuty service IDs to track on this Watchdog.
	Services []string `json:"services"`

	// SuppressFutureIssues When `true`, suppresses newly triggered incidents when a PagerDuty issue is
	// already ongoing for the component.
	SuppressFutureIssues bool          `json:"suppress_future_issues"`
	Type                 PagerdutyType `json:"type"`
}

// PagerdutyType defines model for Pagerduty.Type.
type PagerdutyType string

// PagerdutyFormCreate PagerDuty creation form.
type PagerdutyFormCreate struct {
	// ApiKey The PagerDuty API key.
	ApiKey string `json:"api_key"`

	// IssueTemplates An object of IssueTemplate IDs to create Issues/Updates whenever this Watchdog
	// changes state. This Watchdog will create Issues from the `degraded` template
	// for incidents with low urgency, and `outage` for those with high urgency.
	//
	// When multiple incidents are present, the highest urgency of the incidents will be used.
	//
	// Once a Watchdog in degraded/outage finds that there are no longer unresolved
	// incidents, it will resolve Issues via the `operational` template.
	//
	// If any of the given templates are `null`, then the Watchdog will not create
	// an Issue/Update in that case.
	IssueTemplates *WatchdogIssueTemplates `json:"issue_templates,omitempty"`

	// Services An array of PagerDuty service IDs to track on this Watchdog.
	Services []string `json:"services"`

	// SuppressFutureIssues When `true`, suppresses newly triggered incidents when a PagerDuty issue is
	// already ongoing for the component.
	SuppressFutureIssues *bool                   `json:"suppress_future_issues,omitempty"`
	Type                 PagerdutyFormCreateType `json:"type"`
}

// PagerdutyFormCreateType defines model for PagerdutyFormCreate.Type.
type PagerdutyFormCreateType string

// PagerdutyFormUpdate PagerDuty update form.
type PagerdutyFormUpdate struct {
	// ApiKey The PagerDuty API key.
	ApiKey *string `json:"api_key,omitempty"`

	// IssueTemplates An object of IssueTemplate IDs to create Issues/Updates whenever this Watchdog
	// changes state. This Watchdog will create Issues from the `degraded` template
	// for incidents with low urgency, and `outage` for those with high urgency.
	//
	// When multiple incidents are present, the highest urgency of the incidents will be used.
	//
	// Once a Watchdog in degraded/outage finds that there are no longer unresolved
	// incidents, it will resolve Issues via the `operational` template.
	//
	// If any of the given templates are `null`, then the Watchdog will not create
	// an Issue/Update in that case.
	IssueTemplates *WatchdogIssueTemplates `json:"issue_templates,omitempty"`

	// Services An array of PagerDuty service IDs to track on this Watchdog.
	Services *[]string `json:"services,omitempty"`

	// SuppressFutureIssues When `true`, suppresses newly triggered incidents when a PagerDuty issue is
	// already ongoing for the component.
	SuppressFutureIssues *bool `json:"suppress_future_issues,omitempty"`
}

// Pingdom A [pingdom](https://www.pingdom.com) service.
type Pingdom struct {
	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId string `json:"check_id"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType PINGDOMCHECKTYPE `json:"check_type"`
	Type      PingdomType      `json:"type"`
}

// PingdomType defines model for Pingdom.Type.
type PingdomType string

// PingdomFormCreate Pingdom service creation form.
type PingdomFormCreate struct {
	// ApiToken The Pingdom API v3 key.
	ApiToken string `json:"api_token"`

	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId string `json:"check_id"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType *PingdomFormCreateCheckType `json:"check_type,omitempty"`
	Type      PingdomFormCreateType       `json:"type"`
}

// PingdomFormCreateCheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
// and `transactional` denotes a Pingdom TMS check.
type PingdomFormCreateCheckType string

// PingdomFormCreateType defines model for PingdomFormCreate.Type.
type PingdomFormCreateType string

// PingdomFormUpdate Pingdom service update form.
type PingdomFormUpdate struct {
	// ApiToken The Pingdom API v3 key.
	ApiToken *string `json:"api_token,omitempty"`

	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId *string `json:"check_id,omitempty"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType *PingdomFormUpdateCheckType `json:"check_type,omitempty"`
}

// PingdomFormUpdateCheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
// and `transactional` denotes a Pingdom TMS check.
type PingdomFormUpdateCheckType string

// PingdomWatchdog A [pingdom](https://www.pingdom.com) service.
type PingdomWatchdog struct {
	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId string `json:"check_id"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType PINGDOMCHECKTYPE    `json:"check_type"`
	Type      PingdomWatchdogType `json:"type"`

	// UnconfirmedIsDown When true, triggers Watchdog outage when Pingdom reports a yet unconfirmed
	// outage.
	UnconfirmedIsDown bool `json:"unconfirmed_is_down"`
}

// PingdomWatchdogType defines model for PingdomWatchdog.Type.
type PingdomWatchdogType string

// PingdomWatchdogFormCreate Pingdom service creation form.
type PingdomWatchdogFormCreate struct {
	// ApiToken The Pingdom API v3 key.
	ApiToken string `json:"api_token"`

	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId string `json:"check_id"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType *PingdomWatchdogFormCreateCheckType `json:"check_type,omitempty"`
	Type      PingdomWatchdogFormCreateType       `json:"type"`

	// UnconfirmedIsDown When true, triggers Watchdog outage when Pingdom reports a yet unconfirmed
	// outage.
	UnconfirmedIsDown *bool `json:"unconfirmed_is_down,omitempty"`
}

// PingdomWatchdogFormCreateCheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
// and `transactional` denotes a Pingdom TMS check.
type PingdomWatchdogFormCreateCheckType string

// PingdomWatchdogFormCreateType defines model for PingdomWatchdogFormCreate.Type.
type PingdomWatchdogFormCreateType string

// PingdomWatchdogFormUpdate Pingdom service update form.
type PingdomWatchdogFormUpdate struct {
	// ApiToken The Pingdom API v3 key.
	ApiToken *string `json:"api_token,omitempty"`

	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId *string `json:"check_id,omitempty"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType *PingdomWatchdogFormUpdateCheckType `json:"check_type,omitempty"`

	// UnconfirmedIsDown When true, triggers Watchdog outage when Pingdom reports a yet unconfirmed
	// outage.
	UnconfirmedIsDown *bool `json:"unconfirmed_is_down,omitempty"`
}

// PingdomWatchdogFormUpdateCheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
// and `transactional` denotes a Pingdom TMS check.
type PingdomWatchdogFormUpdateCheckType string

// PingdomLegacyV2 A [pingdom](https://www.pingdom.com) service (legacy API v2). Watchdogs of this
// type may only be updated, not created. Please create a new Pingdom watchdog
// instead, which uses the newer v3.1 API.
type PingdomLegacyV2 struct {
	// AccountEmail The "Team Email" for the given username, if one exists.
	AccountEmail MaybeString `json:"account_email"`

	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId string `json:"check_id"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType PINGDOMCHECKTYPE    `json:"check_type"`
	Type      PingdomLegacyV2Type `json:"type"`

	// Username The Pingdom username to log into.
	Username string `json:"username"`
}

// PingdomLegacyV2Type defines model for PingdomLegacyV2.Type.
type PingdomLegacyV2Type string

// PingdomLegacyV2FormUpdate Pingdom (legacy API v2) update form.
type PingdomLegacyV2FormUpdate struct {
	// AccountEmail The "Team Email" for the given username, if one exists.
	AccountEmail *string `json:"account_email,omitempty"`

	// ApplicationKey The Pingdom API v2 application key.
	ApplicationKey *string `json:"application_key,omitempty"`

	// CheckId The ID of the check to pull status from on Pingdom.
	CheckId *string `json:"check_id,omitempty"`

	// CheckType The type of the Pingdom check. `check` denotes a normal Pingdom uptime check,
	// and `transactional` denotes a Pingdom TMS check.
	CheckType *PINGDOMCHECKTYPE `json:"check_type,omitempty"`

	// Password The Pingdom password for the given username.
	Password *string `json:"password,omitempty"`

	// Username The Pingdom username to log into.
	Username *string `json:"username,omitempty"`
}

// Schedule An Issue Schedule, which describes the schedule of an issue, including start
// and end times, in addition to an optional "upcoming" notification.
type Schedule struct {
	// Ended Whether this scheduled Issue has ended.
	Ended bool `json:"ended"`

	// EndsAt The time at which this scheduled Issue will end.
	EndsAt Timestamp `json:"ends_at"`

	// Id The ObjectId of this Schedule.
	Id ObjectId `json:"id"`

	// Notified Whether this scheduled Issue has fired an `issue_upcoming` notification.
	Notified bool `json:"notified"`

	// NotifySubscribersAt The time at which this scheduled Issue will fire a "heads-up" `issue_upcoming`
	// notification, informing subscribers that the Issue will begin soon. This field
	// is `null` if the Issue will not be sending an `issue_upcoming` notification.
	//
	// **Note:** this field cannot be changed once the Issue has emitted an
	// `issue_upcoming` notification. Consider creating a new Update if you'd like to
	// remind subscribers additional times apart from this automated notification.
	NotifySubscribersAt MaybeTimestamp `json:"notify_subscribers_at"`

	// Started Whether this scheduled Issue has started.
	Started bool `json:"started"`

	// StartsAt The time at which this scheduled Issue will begin.
	StartsAt Timestamp    `json:"starts_at"`
	Type     ScheduleType `json:"type"`
}

// ScheduleType defines model for Schedule.Type.
type ScheduleType string

// ScheduleFormCreate Issue Schedule creation form.
type ScheduleFormCreate struct {
	// EndsAt The time at which this scheduled Issue will end.
	EndsAt Timestamp `json:"ends_at"`

	// NotifySubscribersAt The time at which this scheduled Issue will fire a "heads-up" `issue_upcoming`
	// notification, informing subscribers that the Issue will begin soon. This field
	// is `null` if the Issue will not be sending an `issue_upcoming` notification.
	//
	// **Note:** this field cannot be changed once the Issue has emitted an
	// `issue_upcoming` notification. Consider creating a new Update if you'd like to
	// remind subscribers additional times apart from this automated notification.
	NotifySubscribersAt *Timestamp `json:"notify_subscribers_at,omitempty"`

	// StartsAt The time at which this scheduled Issue will begin.
	StartsAt Timestamp `json:"starts_at"`
}

// ScheduleFormUpdate Issue Schedule update form.
type ScheduleFormUpdate struct {
	// EndsAt The time at which this scheduled Issue will end.
	EndsAt *Timestamp `json:"ends_at,omitempty"`

	// NotifySubscribersAt The time at which this scheduled Issue will fire a "heads-up" `issue_upcoming`
	// notification, informing subscribers that the Issue will begin soon. This field
	// is `null` if the Issue will not be sending an `issue_upcoming` notification.
	//
	// **Note:** this field cannot be changed once the Issue has emitted an
	// `issue_upcoming` notification. Consider creating a new Update if you'd like to
	// remind subscribers additional times apart from this automated notification.
	NotifySubscribersAt *Timestamp `json:"notify_subscribers_at,omitempty"`

	// StartsAt The time at which this scheduled Issue will begin.
	StartsAt *Timestamp `json:"starts_at,omitempty"`
}

// ServicesMetricProvider defines model for Services::MetricProvider.
type ServicesMetricProvider struct {
	union json.RawMessage
}

// ServicesMetricProvider0 The builtin Hund metric provider, which provides metrics based on recorded
// uptime and incidents.
type ServicesMetricProvider0 = Builtin

// ServicesMetricProvider1 An [Updown.io](https://updown.io) service.
type ServicesMetricProvider1 = Updown

// ServicesMetricProvider2 An [Uptime Robot](https://uptimerobot.com) service.
type ServicesMetricProvider2 = Uptimerobot

// ServicesMetricProvider3 A [webhook](https://hund.io/help/integrations/webhooks) service.
type ServicesMetricProvider3 = Webhook

// ServicesMetricProvider4 A [pingdom](https://www.pingdom.com) service.
type ServicesMetricProvider4 = Pingdom

// ServicesMetricProvider5 A [pingdom](https://www.pingdom.com) service (legacy API v2). Watchdogs of this
// type may only be updated, not created. Please create a new Pingdom watchdog
// instead, which uses the newer v3.1 API.
type ServicesMetricProvider5 = PingdomLegacyV2

// ServicesMetricProvider6 Hund's builtin monitoring service, offered free-of-charge with a Hund status
// page. This service can watch the status of any ICMP, HTTP, DNS, TCP, or UDP
// endpoint. For more information about this service, visit our
// [knowledge base](https://hund.io/help/integrations/hund-native-monitoring).
type ServicesMetricProvider6 = Native

// ServicesWatchdog defines model for Services::Watchdog.
type ServicesWatchdog struct {
	union json.RawMessage
}

// ServicesWatchdog0 A manually updated watchdog.
type ServicesWatchdog0 = Manual

// ServicesWatchdog1 An [Updown.io](https://updown.io) service.
type ServicesWatchdog1 = Updown

// ServicesWatchdog2 An [Uptime Robot](https://uptimerobot.com) service.
type ServicesWatchdog2 = UptimerobotWatchdog

// ServicesWatchdog3 A [webhook](https://hund.io/help/integrations/webhooks) service.
type ServicesWatchdog3 = WebhookWatchdog

// ServicesWatchdog4 A [pingdom](https://www.pingdom.com) service.
type ServicesWatchdog4 = PingdomWatchdog

// ServicesWatchdog5 A [pingdom](https://www.pingdom.com) service (legacy API v2). Watchdogs of this
// type may only be updated, not created. Please create a new Pingdom watchdog
// instead, which uses the newer v3.1 API.
type ServicesWatchdog5 = PingdomLegacyV2

// ServicesWatchdog6 An [AWS CloudWatch](https://aws.amazon.com/cloudwatch/) service. This watchdog
// will monitor the `StatusCheckFailed` metric of an AWS EC2 instance reported by
// AWS CloudWatch.
type ServicesWatchdog6 = Cloudwatch

// ServicesWatchdog7 A [New Relic Alerts](https://docs.newrelic.com/docs/alerts) service. This watchdog can
// create/resolve issues based on New Relic Alerts.
type ServicesWatchdog7 = Newrelic

// ServicesWatchdog8 A [PagerDuty](https://www.pagerduty.com/) service. This watchdog can
// create/resolve issues based on PagerDuty incidents.
type ServicesWatchdog8 = Pagerduty

// ServicesWatchdog9 Hund's builtin monitoring service, offered free-of-charge with a Hund status
// page. This service can watch the status of any ICMP, HTTP, DNS, TCP, or UDP
// endpoint. For more information about this service, visit our
// [knowledge base](https://hund.io/help/integrations/hund-native-monitoring).
type ServicesWatchdog9 = Native

// TCP A Hund Native Monitoring TCP Check.
type TCP struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold NonnegativeInteger `json:"consecutive_check_outage_threshold"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency int `json:"frequency"`

	// IpVersion The IP version to use when calling the target.
	IpVersion NATIVEIPVERSION `json:"ip_version"`

	// Method The method to use to check the target.
	Method TCPMethod `json:"method"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold Percentage `json:"percentage_regions_failed_threshold"`

	// Port The port at the target to connect to.
	Port Port `json:"port"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseMustContain This field supports two different matching modes (given by `response_must_contain_mode`):
	//
	// `exact`: Text that the response from the target must contain exactly
	// (case-sensitive). In exact match mode, this field supports
	// [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	//
	// `regex`: A regex that the response from the target must match against.
	// [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
	// the use and supported syntax of Hund regexes.
	//
	// If you send data and expect the target to reply, you must populate this field.
	// Leaving this field blank will prevent the check from receiving data from the
	// target unless forced to wait for an initial response.
	//
	// The "response" from the target that this text is asserted against will be the
	// response from the target *after* sending data. If data is not sent to the
	// target, this text is asserted against the *initial* response.
	ResponseMustContain MaybeString `json:"response_must_contain"`

	// ResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_must_contain`.
	ResponseMustContainMode NATIVESTRINGCONTAINMENTMODE `json:"response_must_contain_mode"`

	// SendData Optional data to send to the target after connecting. If this field is left
	// blank, nothing is sent to the target after connecting.
	//
	// This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	SendData MaybeString `json:"send_data"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout int     `json:"timeout"`
	Type    TCPType `json:"type"`

	// WaitForInitialResponse Whether or not to wait for an initial response from the target before sending
	// data or closing the connection.
	WaitForInitialResponse bool `json:"wait_for_initial_response"`
}

// TCPMethod The method to use to check the target.
type TCPMethod string

// TCPType defines model for TCP.Type.
type TCPType string

// TCPFormCreate Hund Native Monitoring TCP Check creation form.
type TCPFormCreate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *int `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// IpVersion The IP version to use when calling the target.
	IpVersion *TCPFormCreateIpVersion `json:"ip_version,omitempty"`

	// Method The method to use to check the target.
	Method TCPFormCreateMethod `json:"method"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *float32 `json:"percentage_regions_failed_threshold,omitempty"`

	// Port The port at the target to connect to.
	Port Port `json:"port"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseMustContain This field supports two different matching modes (given by `response_must_contain_mode`):
	//
	// `exact`: Text that the response from the target must contain exactly
	// (case-sensitive). In exact match mode, this field supports
	// [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	//
	// `regex`: A regex that the response from the target must match against.
	// [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
	// the use and supported syntax of Hund regexes.
	//
	// If you send data and expect the target to reply, you must populate this field.
	// Leaving this field blank will prevent the check from receiving data from the
	// target unless forced to wait for an initial response.
	//
	// The "response" from the target that this text is asserted against will be the
	// response from the target *after* sending data. If data is not sent to the
	// target, this text is asserted against the *initial* response.
	ResponseMustContain *MaybeString `json:"response_must_contain,omitempty"`

	// ResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_must_contain`.
	ResponseMustContainMode *TCPFormCreateResponseMustContainMode `json:"response_must_contain_mode,omitempty"`

	// SendData Optional data to send to the target after connecting. If this field is left
	// blank, nothing is sent to the target after connecting.
	//
	// This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	SendData *MaybeString `json:"send_data,omitempty"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int              `json:"timeout,omitempty"`
	Type    TCPFormCreateType `json:"type"`

	// WaitForInitialResponse Whether or not to wait for an initial response from the target before sending
	// data or closing the connection.
	WaitForInitialResponse *bool `json:"wait_for_initial_response,omitempty"`
}

// TCPFormCreateIpVersion The IP version to use when calling the target.
type TCPFormCreateIpVersion string

// TCPFormCreateMethod The method to use to check the target.
type TCPFormCreateMethod string

// TCPFormCreateResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
// under `response_must_contain`.
type TCPFormCreateResponseMustContainMode string

// TCPFormCreateType defines model for TCPFormCreate.Type.
type TCPFormCreateType string

// TCPFormUpdate Hund Native Monitoring TCP Check update form.
type TCPFormUpdate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *NonnegativeInteger `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// IpVersion The IP version to use when calling the target.
	IpVersion *NATIVEIPVERSION `json:"ip_version,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *Percentage `json:"percentage_regions_failed_threshold,omitempty"`

	// Port The port at the target to connect to.
	Port *Port `json:"port,omitempty"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions *[]NATIVEREGION `json:"regions,omitempty"`

	// ResponseMustContain This field supports two different matching modes (given by `response_must_contain_mode`):
	//
	// `exact`: Text that the response from the target must contain exactly
	// (case-sensitive). In exact match mode, this field supports
	// [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	//
	// `regex`: A regex that the response from the target must match against.
	// [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
	// the use and supported syntax of Hund regexes.
	//
	// If you send data and expect the target to reply, you must populate this field.
	// Leaving this field blank will prevent the check from receiving data from the
	// target unless forced to wait for an initial response.
	//
	// The "response" from the target that this text is asserted against will be the
	// response from the target *after* sending data. If data is not sent to the
	// target, this text is asserted against the *initial* response.
	ResponseMustContain *MaybeString `json:"response_must_contain,omitempty"`

	// ResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_must_contain`.
	ResponseMustContainMode *NATIVESTRINGCONTAINMENTMODE `json:"response_must_contain_mode,omitempty"`

	// SendData Optional data to send to the target after connecting. If this field is left
	// blank, nothing is sent to the target after connecting.
	//
	// This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	SendData *MaybeString `json:"send_data,omitempty"`

	// Target The host the check will make calls to.
	Target *string `json:"target,omitempty"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int `json:"timeout,omitempty"`

	// WaitForInitialResponse Whether or not to wait for an initial response from the target before sending
	// data or closing the connection.
	WaitForInitialResponse *bool `json:"wait_for_initial_response,omitempty"`
}

// UDP A Hund Native Monitoring UDP Check.
type UDP struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold NonnegativeInteger `json:"consecutive_check_outage_threshold"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency int `json:"frequency"`

	// IpVersion The IP version to use when calling the target.
	IpVersion NATIVEIPVERSION `json:"ip_version"`

	// Method The method to use to check the target.
	Method UDPMethod `json:"method"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold Percentage `json:"percentage_regions_failed_threshold"`

	// Port The port at the target to connect to.
	Port Port `json:"port"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseMustContain This field supports two different matching modes (given by `response_must_contain_mode`):
	//
	// `exact`: Text that the response from the target must contain exactly
	// (case-sensitive). In exact match mode, this field supports
	// [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	//
	// `regex`: A regex that the response from the target must match against.
	// [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
	// the use and supported syntax of Hund regexes.
	//
	// Leaving this field blank will still cause the check to wait for a response
	// from the target after sending data, though no assertions will be made about
	// the payload of the response.
	ResponseMustContain MaybeString `json:"response_must_contain"`

	// ResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_must_contain`.
	ResponseMustContainMode NATIVESTRINGCONTAINMENTMODE `json:"response_must_contain_mode"`

	// SendData Data to send to the target after connecting. Unlike in `tcp`, this
	// field is required.
	//
	// This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	SendData string `json:"send_data"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout int     `json:"timeout"`
	Type    UDPType `json:"type"`
}

// UDPMethod The method to use to check the target.
type UDPMethod string

// UDPType defines model for UDP.Type.
type UDPType string

// UDPFormCreate Hund Native Monitoring UDP Check creation form.
type UDPFormCreate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *int `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// IpVersion The IP version to use when calling the target.
	IpVersion *UDPFormCreateIpVersion `json:"ip_version,omitempty"`

	// Method The method to use to check the target.
	Method UDPFormCreateMethod `json:"method"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *float32 `json:"percentage_regions_failed_threshold,omitempty"`

	// Port The port at the target to connect to.
	Port Port `json:"port"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions []NATIVEREGION `json:"regions"`

	// ResponseMustContain This field supports two different matching modes (given by `response_must_contain_mode`):
	//
	// `exact`: Text that the response from the target must contain exactly
	// (case-sensitive). In exact match mode, this field supports
	// [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	//
	// `regex`: A regex that the response from the target must match against.
	// [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
	// the use and supported syntax of Hund regexes.
	//
	// Leaving this field blank will still cause the check to wait for a response
	// from the target after sending data, though no assertions will be made about
	// the payload of the response.
	ResponseMustContain *MaybeString `json:"response_must_contain,omitempty"`

	// ResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_must_contain`.
	ResponseMustContainMode *UDPFormCreateResponseMustContainMode `json:"response_must_contain_mode,omitempty"`

	// SendData Data to send to the target after connecting. Unlike in `tcp`, this
	// field is required.
	//
	// This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	SendData string `json:"send_data"`

	// Target The host the check will make calls to.
	Target string `json:"target"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int              `json:"timeout,omitempty"`
	Type    UDPFormCreateType `json:"type"`
}

// UDPFormCreateIpVersion The IP version to use when calling the target.
type UDPFormCreateIpVersion string

// UDPFormCreateMethod The method to use to check the target.
type UDPFormCreateMethod string

// UDPFormCreateResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
// under `response_must_contain`.
type UDPFormCreateResponseMustContainMode string

// UDPFormCreateType defines model for UDPFormCreate.Type.
type UDPFormCreateType string

// UDPFormUpdate Hund Native Monitoring UDP Check update form.
type UDPFormUpdate struct {
	// ConsecutiveCheckDegradedThreshold The number of consecutive failed checks required before posting a "degraded"
	// status.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When `null`, denotes that this check will not use a "degraded" stage
	// when encountering check failures.
	//
	// When 0, denotes that this check will post "degraded" upon the first check failure.
	ConsecutiveCheckDegradedThreshold *MaybeNonnegativeInteger `json:"consecutive_check_degraded_threshold,omitempty"`

	// ConsecutiveCheckOutageThreshold The number of consecutive failed checks required before posting an "outage"
	// status. If `consecutive_check_degraded_threshold` is non-null, then the outage
	// will only be posted after degraded has posted according to its own threshold.
	//
	// Note that regardless of threshold settings, a component will post "operational"
	// whenever a check succeeds, thus resetting the consecutive check failure count.
	//
	// When 0, denotes that this check will post "outage" upon the first check failure
	// (or the first check failure after "degraded" has been posted in case
	// `consecutive_check_degraded_threshold` is set).
	ConsecutiveCheckOutageThreshold *NonnegativeInteger `json:"consecutive_check_outage_threshold,omitempty"`

	// Frequency The frequency of the check in milliseconds. The maximum frequency is every 30
	// seconds.
	//
	// **Note:** Any frequency greater than every 60 seconds will force the component
	// to become High-Frequency, at an additional cost. For specific pricing
	// information, please visit the [pricing](https://hund.io/pricing) page.
	Frequency *int `json:"frequency,omitempty"`

	// IpVersion The IP version to use when calling the target.
	IpVersion *NATIVEIPVERSION `json:"ip_version,omitempty"`

	// PercentageRegionsFailedThreshold The percentage of regions that must report a failed check before the entire
	// check can be considered failed. Requiring at least two regions for this
	// threshold is recommended in order to confirm failures across regions.
	PercentageRegionsFailedThreshold *Percentage `json:"percentage_regions_failed_threshold,omitempty"`

	// Port The port at the target to connect to.
	Port *Port `json:"port,omitempty"`

	// Regions The regions you would like the target to be checked from. All regions are
	// weighted equally when calculating the outcome of a check. Currently, a single
	// check can use up to 8 regions simultaneously. Using at least two regions for a
	// single check is recommended in order to confirm failures across regions.
	//
	// **Note:** Each check may use up to three regions at no extra cost. Each region
	// added to this check beyond the base three will incur an additional cost.
	// For specific pricing information, please visit the [pricing](https://hund.io/pricing)
	// page.
	Regions *[]NATIVEREGION `json:"regions,omitempty"`

	// ResponseMustContain This field supports two different matching modes (given by `response_must_contain_mode`):
	//
	// `exact`: Text that the response from the target must contain exactly
	// (case-sensitive). In exact match mode, this field supports
	// [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	//
	// `regex`: A regex that the response from the target must match against.
	// [Click here](https://hund.io/help/documentation/regular-expressions) for more information on
	// the use and supported syntax of Hund regexes.
	//
	// Leaving this field blank will still cause the check to wait for a response
	// from the target after sending data, though no assertions will be made about
	// the payload of the response.
	ResponseMustContain *MaybeString `json:"response_must_contain,omitempty"`

	// ResponseMustContainMode The response containment mode; either `exact` or `regex`. The modes are discussed
	// under `response_must_contain`.
	ResponseMustContainMode *NATIVESTRINGCONTAINMENTMODE `json:"response_must_contain_mode,omitempty"`

	// SendData Data to send to the target after connecting. Unlike in `tcp`, this
	// field is required.
	//
	// This field supports [escape codes](https://hund.io/help/documentation/text-field-escape-codes).
	SendData *string `json:"send_data,omitempty"`

	// Target The host the check will make calls to.
	Target *string `json:"target,omitempty"`

	// Timeout The maximum number of milliseconds the check should wait on the host before
	// failing.
	Timeout *int `json:"timeout,omitempty"`
}

// UPDATELABEL defines model for UPDATE_LABEL.
type UPDATELABEL string

// Update Issue Updates describe a particular phase in the evolution of an issue. Updates
// have their own bodies and label, and can also change the current state override
// of the Issue. Updates are also responsible for resolving/reopening Issues, as
// well as adding addendums/postmortems to the end of an Issue.
type Update struct {
	// Links An object describing the various link relations for this type.
	Links *Update_Links `json:"_links,omitempty"`

	// Body The body text of this Update in raw markdown.
	Body MaybeI18nString `json:"body"`

	// BodyHtml An HTML rendered view of the markdown in `body`.
	BodyHtml I18nString `json:"body_html"`

	// CreatedAt The UNIX timestamp at which this Update was created.
	CreatedAt Timestamp `json:"created_at"`

	// Effective When true, denotes that this Update is the latest update on this Issue (hence,
	// the "effective" Update according to `effective_after`).
	Effective bool `json:"effective"`

	// EffectiveAfter The time after which this Update is considered the latest Update on its Issue,
	// until the `effective_after` time of the Update succeeding this one, if one
	// exists.
	EffectiveAfter Timestamp `json:"effective_after"`

	// Id The ObjectId of this Update.
	Id ObjectId `json:"id"`

	// Issue The Issue that this Update pertains to.
	Issue string `json:"issue"`

	// Label The label applied to this update, as well as the issue at large when this
	// Update is the *latest* Update in the Issue. The label can be thought of as the
	// "state" of the Issue as of this Update (e.g. "Problem Identified", "Monitoring",
	// "Resolved").
	Label MaybeUPDATELABEL `json:"label"`

	// Reopening Whether this Update reopened the Issue if it was already resolved in an Update
	// before this one.
	Reopening bool `json:"reopening"`

	// StateOverride The integer state which overrides the state of affected Components in
	// `component`. A value of `null` indicates no override is present.
	StateOverride MaybeIntegerState `json:"state_override"`

	// Template The IssueTemplateApplication that this Update is applied against, which controls
	// the values of `body`, and `label` when set.
	Template MaybeIssueTemplateApplication `json:"template"`
	Type     UpdateType                    `json:"type"`

	// UpdatedAt The UNIX timestamp at which this Update was last revised.
	UpdatedAt Timestamp `json:"updated_at"`
}

// Update_Links An object describing the various link relations for this type.
type Update_Links struct {
	EventsByContext      HALLink            `json:"events:by-context"`
	Issue                HALLink            `json:"issue"`
	Self                 HALLink            `json:"self"`
	UpdateForm           HALLink            `json:"update-form"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// UpdateType defines model for Update.Type.
type UpdateType string

// UpdateExpansionary Issue Updates describe a particular phase in the evolution of an issue. Updates
// have their own bodies and label, and can also change the current state override
// of the Issue. Updates are also responsible for resolving/reopening Issues, as
// well as adding addendums/postmortems to the end of an Issue.
type UpdateExpansionary struct {
	// Links An object describing the various link relations for this type.
	Links *UpdateExpansionary_Links `json:"_links,omitempty"`

	// Body The body text of this Update in raw markdown.
	Body MaybeI18nString `json:"body"`

	// BodyHtml An HTML rendered view of the markdown in `body`.
	BodyHtml I18nString `json:"body_html"`

	// CreatedAt The UNIX timestamp at which this Update was created.
	CreatedAt Timestamp `json:"created_at"`

	// Effective When true, denotes that this Update is the latest update on this Issue (hence,
	// the "effective" Update according to `effective_after`).
	Effective bool `json:"effective"`

	// EffectiveAfter The time after which this Update is considered the latest Update on its Issue,
	// until the `effective_after` time of the Update succeeding this one, if one
	// exists.
	EffectiveAfter Timestamp `json:"effective_after"`

	// Id The ObjectId of this Update.
	Id ObjectId `json:"id"`

	// Issue The Issue that this Update pertains to.
	Issue UpdateExpansionary_Issue `json:"issue"`

	// Label The label applied to this update, as well as the issue at large when this
	// Update is the *latest* Update in the Issue. The label can be thought of as the
	// "state" of the Issue as of this Update (e.g. "Problem Identified", "Monitoring",
	// "Resolved").
	Label MaybeUPDATELABEL `json:"label"`

	// Reopening Whether this Update reopened the Issue if it was already resolved in an Update
	// before this one.
	Reopening bool `json:"reopening"`

	// StateOverride The integer state which overrides the state of affected Components in
	// `component`. A value of `null` indicates no override is present.
	StateOverride MaybeIntegerState `json:"state_override"`

	// Template The IssueTemplateApplication that this Update is applied against, which controls
	// the values of `body`, and `label` when set.
	Template MaybeIssueTemplateApplication `json:"template"`
	Type     UpdateExpansionaryType        `json:"type"`

	// UpdatedAt The UNIX timestamp at which this Update was last revised.
	UpdatedAt Timestamp `json:"updated_at"`
}

// UpdateExpansionary_Links An object describing the various link relations for this type.
type UpdateExpansionary_Links struct {
	EventsByContext      HALLink            `json:"events:by-context"`
	Issue                HALLink            `json:"issue"`
	Self                 HALLink            `json:"self"`
	UpdateForm           HALLink            `json:"update-form"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// UpdateExpansionaryIssue0 defines model for .
type UpdateExpansionaryIssue0 = ObjectId

// UpdateExpansionaryIssue1 Issues represent an evolving incident in time. Issues have updates, which
// describe the evolution of an issue, often up to resolution. Issues may also
// set a schedule, which allows automatically starting and ending the issue.
type UpdateExpansionaryIssue1 = Issue

// UpdateExpansionary_Issue The Issue that this Update pertains to.
type UpdateExpansionary_Issue struct {
	union json.RawMessage
}

// UpdateExpansionaryType defines model for UpdateExpansionary.Type.
type UpdateExpansionaryType string

// UpdateExpansionaryPagedArray A cursor-like array object that allows paging through an array of objects.
type UpdateExpansionaryPagedArray struct {
	// Links An object describing the various link relations for this type.
	Links *UpdateExpansionaryPagedArray_Links `json:"_links,omitempty"`

	// Data An array of the objects in this page.
	Data []UpdateExpansionary `json:"data"`

	// HasMore Whether or not there are more objects after this page in descending order.
	// When false, this page is the final page of objects in descending order.
	HasMore bool `json:"has_more"`

	// TotalCount The total number of objects in `data`.
	TotalCount int                              `json:"total_count"`
	Type       UpdateExpansionaryPagedArrayType `json:"type"`
}

// UpdateExpansionaryPagedArray_Links An object describing the various link relations for this type.
type UpdateExpansionaryPagedArray_Links struct {
	Beginning            HALLink            `json:"beginning"`
	CreateForm           *HALLink           `json:"create-form,omitempty"`
	Next                 *HALLink           `json:"next,omitempty"`
	Prev                 HALLink            `json:"prev"`
	Self                 HALLink            `json:"self"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// UpdateExpansionaryPagedArrayType defines model for UpdateExpansionaryPagedArray.Type.
type UpdateExpansionaryPagedArrayType string

// UpdateFormCreate Issue Updates creation form.
type UpdateFormCreate struct {
	// Body The body text of this Update in raw markdown.
	Body *MaybeI18nString `json:"body,omitempty"`

	// EffectiveAfter The time after which this Update is considered the latest Update on its Issue,
	// until the `effective_after` time of the Update succeeding this one, if one
	// exists.
	EffectiveAfter *int64 `json:"effective_after,omitempty"`

	// Label The label applied to this update, as well as the issue at large when this
	// Update is the *latest* Update in the Issue. The label can be thought of as the
	// "state" of the Issue as of this Update (e.g. "Problem Identified", "Monitoring",
	// "Resolved").
	Label *MaybeUPDATELABEL `json:"label,omitempty"`

	// StateOverride The integer state which overrides the state of affected Components in
	// `component`. A value of `null` indicates no override is present.
	StateOverride *MaybeIntegerState `json:"state_override,omitempty"`

	// Template The IssueTemplateApplication that this Update is applied against, which controls
	// the values of `body`, and `label` when set.
	Template *UpdateFormCreate_Template `json:"template,omitempty"`
}

// UpdateFormCreateTemplate0 defines model for .
type UpdateFormCreateTemplate0 = ObjectId

// UpdateFormCreateTemplate1 IssueTemplateApplication creation form.
type UpdateFormCreateTemplate1 = IssueTemplateApplicationFormCreate

// UpdateFormCreate_Template The IssueTemplateApplication that this Update is applied against, which controls
// the values of `body`, and `label` when set.
type UpdateFormCreate_Template struct {
	union json.RawMessage
}

// UpdateFormUpdate Issue Updates update form.
type UpdateFormUpdate struct {
	// Body The body text of this Update in raw markdown.
	Body *MaybeI18nString `json:"body,omitempty"`

	// EffectiveAfter The time after which this Update is considered the latest Update on its Issue,
	// until the `effective_after` time of the Update succeeding this one, if one
	// exists.
	EffectiveAfter *int64 `json:"effective_after,omitempty"`

	// Label The label applied to this update, as well as the issue at large when this
	// Update is the *latest* Update in the Issue. The label can be thought of as the
	// "state" of the Issue as of this Update (e.g. "Problem Identified", "Monitoring",
	// "Resolved").
	Label *MaybeUPDATELABEL `json:"label,omitempty"`

	// StateOverride The integer state which overrides the state of affected Components in
	// `component`. A value of `null` indicates no override is present.
	StateOverride *MaybeIntegerState         `json:"state_override,omitempty"`
	Template      *UpdateFormUpdate_Template `json:"template"`
}

// UpdateFormUpdateTemplate0 defines model for .
type UpdateFormUpdateTemplate0 = ObjectId

// UpdateFormUpdateTemplate1 IssueTemplateApplication creation form.
type UpdateFormUpdateTemplate1 = IssueTemplateApplicationFormCreate

// UpdateFormUpdateTemplate2 IssueTemplateApplication update form.
type UpdateFormUpdateTemplate2 = IssueTemplateApplicationFormUpdate

// UpdateFormUpdate_Template defines model for UpdateFormUpdate.Template.
type UpdateFormUpdate_Template struct {
	union json.RawMessage
}

// Updown An [Updown.io](https://updown.io) service.
type Updown struct {
	// MonitorToken An Updown.io monitor token to retrieve status from.
	MonitorToken string     `json:"monitor_token"`
	Type         UpdownType `json:"type"`
}

// UpdownType defines model for Updown.Type.
type UpdownType string

// UpdownFormCreate Updown service creation form.
type UpdownFormCreate struct {
	// MonitorApiKey An Updown.io monitor API key. This API key can be read-only.
	MonitorApiKey string `json:"monitor_api_key"`

	// MonitorToken An Updown.io monitor token to retrieve status from.
	MonitorToken string               `json:"monitor_token"`
	Type         UpdownFormCreateType `json:"type"`
}

// UpdownFormCreateType defines model for UpdownFormCreate.Type.
type UpdownFormCreateType string

// UpdownFormUpdate Updown service update form.
type UpdownFormUpdate struct {
	// MonitorApiKey An Updown.io monitor API key. This API key can be read-only.
	MonitorApiKey *string `json:"monitor_api_key,omitempty"`

	// MonitorToken An Updown.io monitor token to retrieve status from.
	MonitorToken *string `json:"monitor_token,omitempty"`
}

// Uptimerobot An [Uptime Robot](https://uptimerobot.com) service.
type Uptimerobot struct {
	Type UptimerobotType `json:"type"`
}

// UptimerobotType defines model for Uptimerobot.Type.
type UptimerobotType string

// UptimerobotFormCreate Uptime Robot service creation form.
type UptimerobotFormCreate struct {
	// MonitorApiKey An Uptime Robot monitor API key to retrieve status from.
	MonitorApiKey string                    `json:"monitor_api_key"`
	Type          UptimerobotFormCreateType `json:"type"`
}

// UptimerobotFormCreateType defines model for UptimerobotFormCreate.Type.
type UptimerobotFormCreateType string

// UptimerobotFormUpdate Uptime Robot service update form.
type UptimerobotFormUpdate struct {
	// MonitorApiKey An Uptime Robot monitor API key to retrieve status from.
	MonitorApiKey *string `json:"monitor_api_key,omitempty"`
}

// UptimerobotWatchdog An [Uptime Robot](https://uptimerobot.com) service.
type UptimerobotWatchdog struct {
	Type UptimerobotWatchdogType `json:"type"`

	// UnconfirmedIsDown When true, triggers Watchdog outage when UptimeRobot reports a yet unconfirmed
	// outage.
	UnconfirmedIsDown bool `json:"unconfirmed_is_down"`
}

// UptimerobotWatchdogType defines model for UptimerobotWatchdog.Type.
type UptimerobotWatchdogType string

// UptimerobotWatchdogFormCreate Uptime Robot service creation form.
type UptimerobotWatchdogFormCreate struct {
	// MonitorApiKey An Uptime Robot monitor API key to retrieve status from.
	MonitorApiKey string                            `json:"monitor_api_key"`
	Type          UptimerobotWatchdogFormCreateType `json:"type"`

	// UnconfirmedIsDown When true, triggers Watchdog outage when UptimeRobot reports a yet unconfirmed
	// outage.
	UnconfirmedIsDown *bool `json:"unconfirmed_is_down,omitempty"`
}

// UptimerobotWatchdogFormCreateType defines model for UptimerobotWatchdogFormCreate.Type.
type UptimerobotWatchdogFormCreateType string

// UptimerobotWatchdogFormUpdate Uptime Robot service update form.
type UptimerobotWatchdogFormUpdate struct {
	// MonitorApiKey An Uptime Robot monitor API key to retrieve status from.
	MonitorApiKey *string `json:"monitor_api_key,omitempty"`

	// UnconfirmedIsDown When true, triggers Watchdog outage when UptimeRobot reports a yet unconfirmed
	// outage.
	UnconfirmedIsDown *bool `json:"unconfirmed_is_down,omitempty"`
}

// Watchdog Watchdogs determine the method by which component availability is calculated,
// and generate statuses at the configured frequency (regular or high).
type Watchdog struct {
	// Links An object describing the various link relations for this type.
	Links *Watchdog_Links `json:"_links,omitempty"`

	// HighFrequency When true, this Watchdog will run every 30 seconds, instead of the standard
	// 1 minute.
	//
	// **Note:** you are billed extra for each high frequency Watchdog. Please see
	// our [pricing page](https://hund.io/pricing) for more details.
	HighFrequency bool `json:"high_frequency"`

	// Id The ObjectId of this Watchdog.
	Id ObjectId `json:"id"`

	// LatestStatus The ObjectId of the latest Status object generated by this Watchdog. When `null`,
	// this Watchdog is still pending initial status.
	LatestStatus MaybeObjectId `json:"latest_status"`

	// Service The service configuration for this Watchdog, which describes how the Watchdog
	// determines current status.
	Service ServicesWatchdog `json:"service"`
	Type    WatchdogType     `json:"type"`
}

// Watchdog_Links An object describing the various link relations for this type.
type Watchdog_Links struct {
	ActionConvert        HALLink            `json:"action:convert"`
	LatestStatus         *HALLink           `json:"latest_status,omitempty"`
	MetricProviders      HALLink            `json:"metric_providers"`
	Self                 HALLink            `json:"self"`
	Statuses             HALLink            `json:"statuses"`
	AdditionalProperties map[string]HALLink `json:"-"`
}

// WatchdogType defines model for Watchdog.Type.
type WatchdogType string

// WatchdogFormConvert The Watchdog creation form object.
type WatchdogFormConvert struct {
	DefaultMetricProvider *MetricProviderFormDefaultCreate `json:"default_metric_provider,omitempty"`

	// HighFrequency When true, this Watchdog will run every 30 seconds, instead of the standard
	// 1 minute.
	//
	// **Note:** you are billed extra for each high frequency Watchdog. Please see
	// our [pricing page](https://hund.io/pricing) for more details.
	HighFrequency *bool `json:"high_frequency,omitempty"`

	// KeepOriginalDefaultMetricProvider When true, the default MetricProvider (if one exists) for the Watchdog before
	// conversion will be kept as a normal MetricProvider of the Watchdog after
	// conversion. When false, the default MetricProvider will be deleted after
	// conversion.
	KeepOriginalDefaultMetricProvider *bool `json:"keep_original_default_metric_provider,omitempty"`

	// Service The service configuration for this Watchdog, which describes how the Watchdog
	// determines current status.
	Service FormWatchdogCreate `json:"service"`
}

// WatchdogFormCreate The Watchdog creation form object.
type WatchdogFormCreate struct {
	DefaultMetricProvider *MetricProviderFormDefaultCreate `json:"default_metric_provider,omitempty"`

	// HighFrequency When true, this Watchdog will run every 30 seconds, instead of the standard
	// 1 minute.
	//
	// **Note:** you are billed extra for each high frequency Watchdog. Please see
	// our [pricing page](https://hund.io/pricing) for more details.
	HighFrequency   *bool                               `json:"high_frequency,omitempty"`
	MetricProviders *[]MetricProviderFormEmbeddedCreate `json:"metric_providers,omitempty"`

	// Service The service configuration for this Watchdog, which describes how the Watchdog
	// determines current status.
	Service FormWatchdogCreate `json:"service"`
}

// WatchdogFormUpdate The Watchdog update form object.
type WatchdogFormUpdate struct {
	DefaultMetricProvider *MetricProviderFormDefaultUpdate `json:"default_metric_provider,omitempty"`

	// HighFrequency When true, this Watchdog will run every 30 seconds, instead of the standard
	// 1 minute.
	//
	// **Note:** you are billed extra for each high frequency Watchdog. Please see
	// our [pricing page](https://hund.io/pricing) for more details.
	HighFrequency   *bool                               `json:"high_frequency,omitempty"`
	MetricProviders *[]MetricProviderFormEmbeddedUpdate `json:"metric_providers,omitempty"`

	// Service The service configuration for this Watchdog, which describes how the Watchdog
	// determines current status.
	Service FormWatchdogUpdate `json:"service"`
}

// WatchdogIssueTemplates defines model for WatchdogIssueTemplates.
type WatchdogIssueTemplates struct {
	Degraded    MaybeObjectId `json:"degraded"`
	Operational MaybeObjectId `json:"operational"`
	Outage      MaybeObjectId `json:"outage"`
}

// Webhook A [webhook](https://hund.io/help/integrations/webhooks) service.
type Webhook struct {
	Type WebhookType `json:"type"`

	// WebhookKey The key to use for this webhook, expected in request headers.
	WebhookKey *string `json:"webhook_key,omitempty"`
}

// WebhookType defines model for Webhook.Type.
type WebhookType string

// WebhookFormCreate Webhook service creation form.
type WebhookFormCreate struct {
	Type WebhookFormCreateType `json:"type"`

	// WebhookKey The key to use for this webhook, expected in request headers.
	WebhookKey *string `json:"webhook_key,omitempty"`
}

// WebhookFormCreateType defines model for WebhookFormCreate.Type.
type WebhookFormCreateType string

// WebhookFormUpdate Webhook service update form.
type WebhookFormUpdate struct {
	// WebhookKey The key to use for this webhook, expected in request headers.
	WebhookKey *string `json:"webhook_key,omitempty"`
}

// WebhookWatchdog A [webhook](https://hund.io/help/integrations/webhooks) service.
type WebhookWatchdog struct {
	// ConsecutiveChecks This property is only required when `deadman: true`. This property configures
	// how many checks (i.e. the number of times `reporting_interval` elapses) must
	// fail (i.e. no status reported to the webhook) before triggering the "Dead Man's
	// Switch."
	//
	// For example, if `deadman: true` and `reporting_interval: 60`, then a setting
	// of `consecutive_checks: 5` would cause the Watchdog to wait for 5 consecutive
	// minutes to receive a webhook call before triggering outage. Since the count is
	// consecutive, it is reset whenever a new webhook call comes through to the Watchdog.
	ConsecutiveChecks MaybeDeadmanConsecutiveChecks `json:"consecutive_checks"`

	// Deadman When true, turns on a "Dead Man's Switch" for the Watchdog, according to the
	// configuration set by `reporting_interval` and `consecutive_checks`. The Watchdog
	// will trigger an "outage" state if the webhook does not receive a call after
	// the configured number of consecutive checks (according to the reporting interval).
	//
	// This switch can be useful when a lack of webhook reporting from the specific
	// component should be taken to mean that the component itself is down.
	Deadman bool `json:"deadman"`

	// ReportingInterval This property is only required when `deadman: true`. This property configures
	// how often (in seconds) that you expect to POST status to the webhook.
	ReportingInterval MaybeDeadmanReportingInterval `json:"reporting_interval"`
	Type              WebhookWatchdogType           `json:"type"`

	// WebhookKey The key to use for this webhook, expected in request headers.
	WebhookKey *string `json:"webhook_key,omitempty"`
}

// WebhookWatchdogType defines model for WebhookWatchdog.Type.
type WebhookWatchdogType string

// WebhookWatchdogFormCreate Webhook service creation form.
type WebhookWatchdogFormCreate struct {
	// ConsecutiveChecks This property is only required when `deadman: true`. This property configures
	// how many checks (i.e. the number of times `reporting_interval` elapses) must
	// fail (i.e. no status reported to the webhook) before triggering the "Dead Man's
	// Switch."
	//
	// For example, if `deadman: true` and `reporting_interval: 60`, then a setting
	// of `consecutive_checks: 5` would cause the Watchdog to wait for 5 consecutive
	// minutes to receive a webhook call before triggering outage. Since the count is
	// consecutive, it is reset whenever a new webhook call comes through to the Watchdog.
	ConsecutiveChecks *MaybeDeadmanConsecutiveChecks `json:"consecutive_checks,omitempty"`

	// Deadman When true, turns on a "Dead Man's Switch" for the Watchdog, according to the
	// configuration set by `reporting_interval` and `consecutive_checks`. The Watchdog
	// will trigger an "outage" state if the webhook does not receive a call after
	// the configured number of consecutive checks (according to the reporting interval).
	//
	// This switch can be useful when a lack of webhook reporting from the specific
	// component should be taken to mean that the component itself is down.
	Deadman *bool `json:"deadman,omitempty"`

	// ReportingInterval This property is only required when `deadman: true`. This property configures
	// how often (in seconds) that you expect to POST status to the webhook.
	ReportingInterval *MaybeDeadmanReportingInterval `json:"reporting_interval,omitempty"`
	Type              WebhookWatchdogFormCreateType  `json:"type"`

	// WebhookKey The key to use for this webhook, expected in request headers.
	WebhookKey *string `json:"webhook_key,omitempty"`
}

// WebhookWatchdogFormCreateType defines model for WebhookWatchdogFormCreate.Type.
type WebhookWatchdogFormCreateType string

// WebhookWatchdogFormUpdate Webhook service update form.
type WebhookWatchdogFormUpdate struct {
	// ConsecutiveChecks This property is only required when `deadman: true`. This property configures
	// how many checks (i.e. the number of times `reporting_interval` elapses) must
	// fail (i.e. no status reported to the webhook) before triggering the "Dead Man's
	// Switch."
	//
	// For example, if `deadman: true` and `reporting_interval: 60`, then a setting
	// of `consecutive_checks: 5` would cause the Watchdog to wait for 5 consecutive
	// minutes to receive a webhook call before triggering outage. Since the count is
	// consecutive, it is reset whenever a new webhook call comes through to the Watchdog.
	ConsecutiveChecks *MaybeDeadmanConsecutiveChecks `json:"consecutive_checks,omitempty"`

	// Deadman When true, turns on a "Dead Man's Switch" for the Watchdog, according to the
	// configuration set by `reporting_interval` and `consecutive_checks`. The Watchdog
	// will trigger an "outage" state if the webhook does not receive a call after
	// the configured number of consecutive checks (according to the reporting interval).
	//
	// This switch can be useful when a lack of webhook reporting from the specific
	// component should be taken to mean that the component itself is down.
	Deadman *bool `json:"deadman,omitempty"`

	// ReportingInterval This property is only required when `deadman: true`. This property configures
	// how often (in seconds) that you expect to POST status to the webhook.
	ReportingInterval *MaybeDeadmanReportingInterval `json:"reporting_interval,omitempty"`

	// WebhookKey The key to use for this webhook, expected in request headers.
	WebhookKey *string `json:"webhook_key,omitempty"`
}

// DeadmanConsecutiveChecks defines model for deadman-consecutive-checks.
type DeadmanConsecutiveChecks = int

// DeadmanReportingInterval defines model for deadman-reporting-interval.
type DeadmanReportingInterval = int

// Default An object describing the various link relations for this type.
type Default map[string]HALLink

// I18n defines model for i18n.
type I18n map[string]string

// I18nString A localized string. The particular translation used on this string depends
// on the given `Accept-Language` header. Given an `Accept-Language` header
// value of `*`, this value will be the full object of translations. If a
// translation does not exist for the requested language, the Status Page
// *Default Language* is used as a fallback.
type I18nString struct {
	union json.RawMessage
}

// I18nString0 defines model for .
type I18nString0 = string

// I18nString1 defines model for .
type I18nString1 = I18n

// IntegerState An integer denoting operational state (1 => operational, 0 => degraded, -1 => outage).
type IntegerState int

// MaybeBoolean defines model for maybe-boolean.
type MaybeBoolean = *bool

// MaybeI18nString A localized string. The particular translation used on this string depends
// on the given `Accept-Language` header. Given an `Accept-Language` header
// value of `*`, this value will be the full object of translations. If a
// translation does not exist for the requested language, the Status Page
// *Default Language* is used as a fallback.
type MaybeI18nString = *I18nString

// MaybeString defines model for maybe-string.
type MaybeString = *string

// MaybeTimestamp defines model for maybe-timestamp.
type MaybeTimestamp = *Timestamp

// NamespacedSlug An alphanumeric (plus underscore) string, separated by zero or more dots,
// denoting namespaces.
type NamespacedSlug = string

// NonnegativeInteger defines model for nonnegative-integer.
type NonnegativeInteger = int

// NonnegativeNumber defines model for nonnegative-number.
type NonnegativeNumber = float32

// Percentage defines model for percentage.
type Percentage = float32

// Port defines model for port.
type Port = int

// Timestamp defines model for timestamp.
type Timestamp = int64

// GetAllComponentsParams defines parameters for GetAllComponents.
type GetAllComponentsParams struct {
	// Group Return the Components for the provided Group ObjectId.
	Group *string `form:"group,omitempty" json:"group,omitempty"`

	// Issue Return the Components for the provided Issue ObjectId.
	Issue *string `form:"issue,omitempty" json:"issue,omitempty"`

	// Event Return the Components of the provided Event's `context.component_ids`.
	Event *string `form:"event,omitempty" json:"event,omitempty"`

	// TimelineItem Return the Components for the provided TimelineItem UUID.
	TimelineItem *string `form:"timeline_item,omitempty" json:"timeline_item,omitempty"`

	// Limit The number of Components to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter A Component ObjectId after which the returned array of
	// Components will begin in descending order.
	// Typically, this is used to retrieve the next page of Components
	// in descending order.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore A Component ObjectId before which the returned array of
	// Components will end in descending order.
	// Typically, this is used to retrieve the previous page of Components
	// in descending order.
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// CreateAComponentJSONBody defines parameters for CreateAComponent.
type CreateAComponentJSONBody = ComponentFormCreate

// UpdateAComponentJSONBody defines parameters for UpdateAComponent.
type UpdateAComponentJSONBody = ComponentFormUpdate

// GetAllGroupsParams defines parameters for GetAllGroups.
type GetAllGroupsParams struct {
	// Limit The number of Groups to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter A Group ObjectId after which the returned array of
	// Groups will begin in descending order.
	// Typically, this is used to retrieve the next page of Groups
	// in descending order.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore A Group ObjectId before which the returned array of
	// Groups will end in descending order.
	// Typically, this is used to retrieve the previous page of Groups
	// in descending order.
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// CreateAGroupJSONBody defines parameters for CreateAGroup.
type CreateAGroupJSONBody = GroupFormCreate

// UpdateAGroupJSONBody defines parameters for UpdateAGroup.
type UpdateAGroupJSONBody = GroupFormUpdate

// ReorderAGroupsComponentsJSONBody defines parameters for ReorderAGroupsComponents.
type ReorderAGroupsComponentsJSONBody = []ObjectId

// GetAllIssueTemplatesParams defines parameters for GetAllIssueTemplates.
type GetAllIssueTemplatesParams struct {
	// Kind Return only IssueTemplates for the given kind (i.e. Issue or Update).
	Kind *GetAllIssueTemplatesParamsKind `form:"kind,omitempty" json:"kind,omitempty"`

	// Limit The number of IssueTemplates to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter A IssueTemplate ObjectId after which the returned array of
	// IssueTemplates will begin in descending order.
	// Typically, this is used to retrieve the next page of IssueTemplates
	// in descending order.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore A IssueTemplate ObjectId before which the returned array of
	// IssueTemplates will end in descending order.
	// Typically, this is used to retrieve the previous page of IssueTemplates
	// in descending order.
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// GetAllIssueTemplatesParamsKind defines parameters for GetAllIssueTemplates.
type GetAllIssueTemplatesParamsKind string

// CreateAIssueTemplateJSONBody defines parameters for CreateAIssueTemplate.
type CreateAIssueTemplateJSONBody = IssueTemplateFormCreate

// UpdateAIssueTemplateJSONBody defines parameters for UpdateAIssueTemplate.
type UpdateAIssueTemplateJSONBody = IssueTemplateFormUpdate

// GetAllIssuesParams defines parameters for GetAllIssues.
type GetAllIssuesParams struct {
	// Components One or more Components to return Issues for. To use this query parameter,
	// supply `components[]={component_id}` for each `{component_id}` you are
	// requesting Issues for.
	Components *[]ObjectId `form:"components[],omitempty" json:"components[],omitempty"`

	// Component A single Component to return Issues for. This field is ignored if
	// `components[]` is supplied.
	Component *string `form:"component,omitempty" json:"component,omitempty"`

	// Standing When true, returns only ongoing Issues.
	Standing *bool `form:"standing,omitempty" json:"standing,omitempty"`

	// Upcoming When true, returns only upcoming scheduled Issues.
	Upcoming *bool `form:"upcoming,omitempty" json:"upcoming,omitempty"`

	// Resolved When true, returns only resolved Issues.
	Resolved *bool `form:"resolved,omitempty" json:"resolved,omitempty"`

	// Limit The number of Issues to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter A Issue ObjectId after which the returned array of
	// Issues will begin in descending order.
	// Typically, this is used to retrieve the next page of Issues
	// in descending order.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore A Issue ObjectId before which the returned array of
	// Issues will end in descending order.
	// Typically, this is used to retrieve the previous page of Issues
	// in descending order.
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// CreateAIssueJSONBody defines parameters for CreateAIssue.
type CreateAIssueJSONBody = IssueFormCreate

// PreviewAIssueJSONBody defines parameters for PreviewAIssue.
type PreviewAIssueJSONBody = IssueFormCreate

// ReviseAnIssueJSONBody defines parameters for ReviseAnIssue.
type ReviseAnIssueJSONBody = IssueFormUpdate

// CancelAScheduledIssueJSONBody defines parameters for CancelAScheduledIssue.
type CancelAScheduledIssueJSONBody = IssueFormCancel

// GetAllUpdatesParams defines parameters for GetAllUpdates.
type GetAllUpdatesParams struct {
	// Limit The number of Updates to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter A Update ObjectId after which the returned array of
	// Updates will begin in descending order.
	// Typically, this is used to retrieve the next page of Updates
	// in descending order.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore A Update ObjectId before which the returned array of
	// Updates will end in descending order.
	// Typically, this is used to retrieve the previous page of Updates
	// in descending order.
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// CreateAUpdateJSONBody defines parameters for CreateAUpdate.
type CreateAUpdateJSONBody = UpdateFormCreate

// PreviewAUpdateJSONBody defines parameters for PreviewAUpdate.
type PreviewAUpdateJSONBody = UpdateFormCreate

// ReviseAnUpdateJSONBody defines parameters for ReviseAnUpdate.
type ReviseAnUpdateJSONBody = UpdateFormUpdate

// GetAllMetricProvidersParams defines parameters for GetAllMetricProviders.
type GetAllMetricProvidersParams struct {
	// Watchdog ObjectId for a particular Watchdog to retrieve MetricProviders on.
	Watchdog *string `form:"watchdog,omitempty" json:"watchdog,omitempty"`

	// Default When true, returns only MetricProviders for which `default` is true (i.e.
	// returns MetricProviders that are considered the "default" for their
	// respective Watchdogs).
	//
	// When used in conjunction with the `watchdog` parameter, returns the
	// *single* default MetricProvider of that Watchdog, if it exists.
	Default *bool `form:"default,omitempty" json:"default,omitempty"`

	// Limit The number of MetricProviders to return per page.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// StartingAfter A MetricProvider ObjectId after which the returned array of
	// MetricProviders will begin in descending order.
	// Typically, this is used to retrieve the next page of MetricProviders
	// in descending order.
	StartingAfter *string `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore A MetricProvider ObjectId before which the returned array of
	// MetricProviders will end in descending order.
	// Typically, this is used to retrieve the previous page of MetricProviders
	// in descending order.
	EndingBefore *string `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// CreateAMetricProviderJSONBody defines parameters for CreateAMetricProvider.
type CreateAMetricProviderJSONBody = MetricProviderFormCreate

// UpdateAMetricProviderJSONBody defines parameters for UpdateAMetricProvider.
type UpdateAMetricProviderJSONBody = MetricProviderFormUpdate

// UpdateAWatchdogJSONBody defines parameters for UpdateAWatchdog.
type UpdateAWatchdogJSONBody = WatchdogFormUpdate

// ConvertAWatchdogsServiceTypeJSONBody defines parameters for ConvertAWatchdogsServiceType.
type ConvertAWatchdogsServiceTypeJSONBody = WatchdogFormConvert

// CreateAComponentJSONRequestBody defines body for CreateAComponent for application/json ContentType.
type CreateAComponentJSONRequestBody = CreateAComponentJSONBody

// UpdateAComponentJSONRequestBody defines body for UpdateAComponent for application/json ContentType.
type UpdateAComponentJSONRequestBody = UpdateAComponentJSONBody

// CreateAGroupJSONRequestBody defines body for CreateAGroup for application/json ContentType.
type CreateAGroupJSONRequestBody = CreateAGroupJSONBody

// UpdateAGroupJSONRequestBody defines body for UpdateAGroup for application/json ContentType.
type UpdateAGroupJSONRequestBody = UpdateAGroupJSONBody

// ReorderAGroupsComponentsJSONRequestBody defines body for ReorderAGroupsComponents for application/json ContentType.
type ReorderAGroupsComponentsJSONRequestBody = ReorderAGroupsComponentsJSONBody

// CreateAIssueTemplateJSONRequestBody defines body for CreateAIssueTemplate for application/json ContentType.
type CreateAIssueTemplateJSONRequestBody = CreateAIssueTemplateJSONBody

// UpdateAIssueTemplateJSONRequestBody defines body for UpdateAIssueTemplate for application/json ContentType.
type UpdateAIssueTemplateJSONRequestBody = UpdateAIssueTemplateJSONBody

// CreateAIssueJSONRequestBody defines body for CreateAIssue for application/json ContentType.
type CreateAIssueJSONRequestBody = CreateAIssueJSONBody

// PreviewAIssueJSONRequestBody defines body for PreviewAIssue for application/json ContentType.
type PreviewAIssueJSONRequestBody = PreviewAIssueJSONBody

// ReviseAnIssueJSONRequestBody defines body for ReviseAnIssue for application/json ContentType.
type ReviseAnIssueJSONRequestBody = ReviseAnIssueJSONBody

// CancelAScheduledIssueJSONRequestBody defines body for CancelAScheduledIssue for application/json ContentType.
type CancelAScheduledIssueJSONRequestBody = CancelAScheduledIssueJSONBody

// CreateAUpdateJSONRequestBody defines body for CreateAUpdate for application/json ContentType.
type CreateAUpdateJSONRequestBody = CreateAUpdateJSONBody

// PreviewAUpdateJSONRequestBody defines body for PreviewAUpdate for application/json ContentType.
type PreviewAUpdateJSONRequestBody = PreviewAUpdateJSONBody

// ReviseAnUpdateJSONRequestBody defines body for ReviseAnUpdate for application/json ContentType.
type ReviseAnUpdateJSONRequestBody = ReviseAnUpdateJSONBody

// CreateAMetricProviderJSONRequestBody defines body for CreateAMetricProvider for application/json ContentType.
type CreateAMetricProviderJSONRequestBody = CreateAMetricProviderJSONBody

// UpdateAMetricProviderJSONRequestBody defines body for UpdateAMetricProvider for application/json ContentType.
type UpdateAMetricProviderJSONRequestBody = UpdateAMetricProviderJSONBody

// UpdateAWatchdogJSONRequestBody defines body for UpdateAWatchdog for application/json ContentType.
type UpdateAWatchdogJSONRequestBody = UpdateAWatchdogJSONBody

// ConvertAWatchdogsServiceTypeJSONRequestBody defines body for ConvertAWatchdogsServiceType for application/json ContentType.
type ConvertAWatchdogsServiceTypeJSONRequestBody = ConvertAWatchdogsServiceTypeJSONBody

// Getter for additional properties for Component_Links. Returns the specified
// element and whether it was found
func (a Component_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Component_Links
func (a *Component_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Component_Links to handle AdditionalProperties
func (a *Component_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["events"]; found {
		err = json.Unmarshal(raw, &a.Events)
		if err != nil {
			return fmt.Errorf("error reading 'events': %w", err)
		}
		delete(object, "events")
	}

	if raw, found := object["events:by-context"]; found {
		err = json.Unmarshal(raw, &a.EventsByContext)
		if err != nil {
			return fmt.Errorf("error reading 'events:by-context': %w", err)
		}
		delete(object, "events:by-context")
	}

	if raw, found := object["group"]; found {
		err = json.Unmarshal(raw, &a.Group)
		if err != nil {
			return fmt.Errorf("error reading 'group': %w", err)
		}
		delete(object, "group")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["self-view"]; found {
		err = json.Unmarshal(raw, &a.SelfView)
		if err != nil {
			return fmt.Errorf("error reading 'self-view': %w", err)
		}
		delete(object, "self-view")
	}

	if raw, found := object["timeline"]; found {
		err = json.Unmarshal(raw, &a.Timeline)
		if err != nil {
			return fmt.Errorf("error reading 'timeline': %w", err)
		}
		delete(object, "timeline")
	}

	if raw, found := object["update-form"]; found {
		err = json.Unmarshal(raw, &a.UpdateForm)
		if err != nil {
			return fmt.Errorf("error reading 'update-form': %w", err)
		}
		delete(object, "update-form")
	}

	if raw, found := object["watchdog"]; found {
		err = json.Unmarshal(raw, &a.Watchdog)
		if err != nil {
			return fmt.Errorf("error reading 'watchdog': %w", err)
		}
		delete(object, "watchdog")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Component_Links to handle AdditionalProperties
func (a Component_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["events"], err = json.Marshal(a.Events)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events': %w", err)
	}

	object["events:by-context"], err = json.Marshal(a.EventsByContext)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events:by-context': %w", err)
	}

	if a.Group != nil {
		object["group"], err = json.Marshal(a.Group)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group': %w", err)
		}
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["self-view"], err = json.Marshal(a.SelfView)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self-view': %w", err)
	}

	object["timeline"], err = json.Marshal(a.Timeline)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'timeline': %w", err)
	}

	object["update-form"], err = json.Marshal(a.UpdateForm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'update-form': %w", err)
	}

	object["watchdog"], err = json.Marshal(a.Watchdog)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'watchdog': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ComponentExpansionary_Links. Returns the specified
// element and whether it was found
func (a ComponentExpansionary_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ComponentExpansionary_Links
func (a *ComponentExpansionary_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ComponentExpansionary_Links to handle AdditionalProperties
func (a *ComponentExpansionary_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["events"]; found {
		err = json.Unmarshal(raw, &a.Events)
		if err != nil {
			return fmt.Errorf("error reading 'events': %w", err)
		}
		delete(object, "events")
	}

	if raw, found := object["events:by-context"]; found {
		err = json.Unmarshal(raw, &a.EventsByContext)
		if err != nil {
			return fmt.Errorf("error reading 'events:by-context': %w", err)
		}
		delete(object, "events:by-context")
	}

	if raw, found := object["group"]; found {
		err = json.Unmarshal(raw, &a.Group)
		if err != nil {
			return fmt.Errorf("error reading 'group': %w", err)
		}
		delete(object, "group")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["self-view"]; found {
		err = json.Unmarshal(raw, &a.SelfView)
		if err != nil {
			return fmt.Errorf("error reading 'self-view': %w", err)
		}
		delete(object, "self-view")
	}

	if raw, found := object["timeline"]; found {
		err = json.Unmarshal(raw, &a.Timeline)
		if err != nil {
			return fmt.Errorf("error reading 'timeline': %w", err)
		}
		delete(object, "timeline")
	}

	if raw, found := object["update-form"]; found {
		err = json.Unmarshal(raw, &a.UpdateForm)
		if err != nil {
			return fmt.Errorf("error reading 'update-form': %w", err)
		}
		delete(object, "update-form")
	}

	if raw, found := object["watchdog"]; found {
		err = json.Unmarshal(raw, &a.Watchdog)
		if err != nil {
			return fmt.Errorf("error reading 'watchdog': %w", err)
		}
		delete(object, "watchdog")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ComponentExpansionary_Links to handle AdditionalProperties
func (a ComponentExpansionary_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["events"], err = json.Marshal(a.Events)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events': %w", err)
	}

	object["events:by-context"], err = json.Marshal(a.EventsByContext)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events:by-context': %w", err)
	}

	if a.Group != nil {
		object["group"], err = json.Marshal(a.Group)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group': %w", err)
		}
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["self-view"], err = json.Marshal(a.SelfView)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self-view': %w", err)
	}

	object["timeline"], err = json.Marshal(a.Timeline)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'timeline': %w", err)
	}

	object["update-form"], err = json.Marshal(a.UpdateForm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'update-form': %w", err)
	}

	object["watchdog"], err = json.Marshal(a.Watchdog)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'watchdog': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ComponentExpansionaryPagedArray_Links. Returns the specified
// element and whether it was found
func (a ComponentExpansionaryPagedArray_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ComponentExpansionaryPagedArray_Links
func (a *ComponentExpansionaryPagedArray_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ComponentExpansionaryPagedArray_Links to handle AdditionalProperties
func (a *ComponentExpansionaryPagedArray_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["create-form"]; found {
		err = json.Unmarshal(raw, &a.CreateForm)
		if err != nil {
			return fmt.Errorf("error reading 'create-form': %w", err)
		}
		delete(object, "create-form")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ComponentExpansionaryPagedArray_Links to handle AdditionalProperties
func (a ComponentExpansionaryPagedArray_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.CreateForm != nil {
		object["create-form"], err = json.Marshal(a.CreateForm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create-form': %w", err)
		}
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ComponentPagedArray_Links. Returns the specified
// element and whether it was found
func (a ComponentPagedArray_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ComponentPagedArray_Links
func (a *ComponentPagedArray_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ComponentPagedArray_Links to handle AdditionalProperties
func (a *ComponentPagedArray_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ComponentPagedArray_Links to handle AdditionalProperties
func (a ComponentPagedArray_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Group_Links. Returns the specified
// element and whether it was found
func (a Group_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Group_Links
func (a *Group_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Group_Links to handle AdditionalProperties
func (a *Group_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["action:reorder"]; found {
		err = json.Unmarshal(raw, &a.ActionReorder)
		if err != nil {
			return fmt.Errorf("error reading 'action:reorder': %w", err)
		}
		delete(object, "action:reorder")
	}

	if raw, found := object["components"]; found {
		err = json.Unmarshal(raw, &a.Components)
		if err != nil {
			return fmt.Errorf("error reading 'components': %w", err)
		}
		delete(object, "components")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["timeline"]; found {
		err = json.Unmarshal(raw, &a.Timeline)
		if err != nil {
			return fmt.Errorf("error reading 'timeline': %w", err)
		}
		delete(object, "timeline")
	}

	if raw, found := object["update-form"]; found {
		err = json.Unmarshal(raw, &a.UpdateForm)
		if err != nil {
			return fmt.Errorf("error reading 'update-form': %w", err)
		}
		delete(object, "update-form")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Group_Links to handle AdditionalProperties
func (a Group_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["action:reorder"], err = json.Marshal(a.ActionReorder)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'action:reorder': %w", err)
	}

	object["components"], err = json.Marshal(a.Components)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'components': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["timeline"], err = json.Marshal(a.Timeline)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'timeline': %w", err)
	}

	object["update-form"], err = json.Marshal(a.UpdateForm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'update-form': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GroupPagedArray_Links. Returns the specified
// element and whether it was found
func (a GroupPagedArray_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GroupPagedArray_Links
func (a *GroupPagedArray_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GroupPagedArray_Links to handle AdditionalProperties
func (a *GroupPagedArray_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["create-form"]; found {
		err = json.Unmarshal(raw, &a.CreateForm)
		if err != nil {
			return fmt.Errorf("error reading 'create-form': %w", err)
		}
		delete(object, "create-form")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GroupPagedArray_Links to handle AdditionalProperties
func (a GroupPagedArray_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.CreateForm != nil {
		object["create-form"], err = json.Marshal(a.CreateForm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create-form': %w", err)
		}
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for HALLink. Returns the specified
// element and whether it was found
func (a HALLink) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for HALLink
func (a *HALLink) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for HALLink to handle AdditionalProperties
func (a *HALLink) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["href"]; found {
		err = json.Unmarshal(raw, &a.Href)
		if err != nil {
			return fmt.Errorf("error reading 'href': %w", err)
		}
		delete(object, "href")
	}

	if raw, found := object["templated"]; found {
		err = json.Unmarshal(raw, &a.Templated)
		if err != nil {
			return fmt.Errorf("error reading 'templated': %w", err)
		}
		delete(object, "templated")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for HALLink to handle AdditionalProperties
func (a HALLink) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["href"], err = json.Marshal(a.Href)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'href': %w", err)
	}

	if a.Templated != nil {
		object["templated"], err = json.Marshal(a.Templated)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'templated': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Issue_Links. Returns the specified
// element and whether it was found
func (a Issue_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Issue_Links
func (a *Issue_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Issue_Links to handle AdditionalProperties
func (a *Issue_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["action:cancel"]; found {
		err = json.Unmarshal(raw, &a.ActionCancel)
		if err != nil {
			return fmt.Errorf("error reading 'action:cancel': %w", err)
		}
		delete(object, "action:cancel")
	}

	if raw, found := object["components"]; found {
		err = json.Unmarshal(raw, &a.Components)
		if err != nil {
			return fmt.Errorf("error reading 'components': %w", err)
		}
		delete(object, "components")
	}

	if raw, found := object["events"]; found {
		err = json.Unmarshal(raw, &a.Events)
		if err != nil {
			return fmt.Errorf("error reading 'events': %w", err)
		}
		delete(object, "events")
	}

	if raw, found := object["og:image"]; found {
		err = json.Unmarshal(raw, &a.OgImage)
		if err != nil {
			return fmt.Errorf("error reading 'og:image': %w", err)
		}
		delete(object, "og:image")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["self-view"]; found {
		err = json.Unmarshal(raw, &a.SelfView)
		if err != nil {
			return fmt.Errorf("error reading 'self-view': %w", err)
		}
		delete(object, "self-view")
	}

	if raw, found := object["update-form"]; found {
		err = json.Unmarshal(raw, &a.UpdateForm)
		if err != nil {
			return fmt.Errorf("error reading 'update-form': %w", err)
		}
		delete(object, "update-form")
	}

	if raw, found := object["updates"]; found {
		err = json.Unmarshal(raw, &a.Updates)
		if err != nil {
			return fmt.Errorf("error reading 'updates': %w", err)
		}
		delete(object, "updates")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Issue_Links to handle AdditionalProperties
func (a Issue_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ActionCancel != nil {
		object["action:cancel"], err = json.Marshal(a.ActionCancel)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'action:cancel': %w", err)
		}
	}

	object["components"], err = json.Marshal(a.Components)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'components': %w", err)
	}

	object["events"], err = json.Marshal(a.Events)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events': %w", err)
	}

	if a.OgImage != nil {
		object["og:image"], err = json.Marshal(a.OgImage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'og:image': %w", err)
		}
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["self-view"], err = json.Marshal(a.SelfView)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self-view': %w", err)
	}

	object["update-form"], err = json.Marshal(a.UpdateForm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'update-form': %w", err)
	}

	object["updates"], err = json.Marshal(a.Updates)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'updates': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Issue_Components_Links. Returns the specified
// element and whether it was found
func (a Issue_Components_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Issue_Components_Links
func (a *Issue_Components_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Issue_Components_Links to handle AdditionalProperties
func (a *Issue_Components_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Issue_Components_Links to handle AdditionalProperties
func (a Issue_Components_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Issue_Updates_Links. Returns the specified
// element and whether it was found
func (a Issue_Updates_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Issue_Updates_Links
func (a *Issue_Updates_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Issue_Updates_Links to handle AdditionalProperties
func (a *Issue_Updates_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Issue_Updates_Links to handle AdditionalProperties
func (a Issue_Updates_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssuePagedArray_Links. Returns the specified
// element and whether it was found
func (a IssuePagedArray_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssuePagedArray_Links
func (a *IssuePagedArray_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssuePagedArray_Links to handle AdditionalProperties
func (a *IssuePagedArray_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["create-form"]; found {
		err = json.Unmarshal(raw, &a.CreateForm)
		if err != nil {
			return fmt.Errorf("error reading 'create-form': %w", err)
		}
		delete(object, "create-form")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssuePagedArray_Links to handle AdditionalProperties
func (a IssuePagedArray_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.CreateForm != nil {
		object["create-form"], err = json.Marshal(a.CreateForm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create-form': %w", err)
		}
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssueTemplate_Links. Returns the specified
// element and whether it was found
func (a IssueTemplate_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssueTemplate_Links
func (a *IssueTemplate_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssueTemplate_Links to handle AdditionalProperties
func (a *IssueTemplate_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssueTemplate_Links to handle AdditionalProperties
func (a IssueTemplate_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssueTemplateApplication_Links. Returns the specified
// element and whether it was found
func (a IssueTemplateApplication_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssueTemplateApplication_Links
func (a *IssueTemplateApplication_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssueTemplateApplication_Links to handle AdditionalProperties
func (a *IssueTemplateApplication_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["issue_template"]; found {
		err = json.Unmarshal(raw, &a.IssueTemplate)
		if err != nil {
			return fmt.Errorf("error reading 'issue_template': %w", err)
		}
		delete(object, "issue_template")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssueTemplateApplication_Links to handle AdditionalProperties
func (a IssueTemplateApplication_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["issue_template"], err = json.Marshal(a.IssueTemplate)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'issue_template': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssueTemplateApplicationIssue_Links. Returns the specified
// element and whether it was found
func (a IssueTemplateApplicationIssue_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssueTemplateApplicationIssue_Links
func (a *IssueTemplateApplicationIssue_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssueTemplateApplicationIssue_Links to handle AdditionalProperties
func (a *IssueTemplateApplicationIssue_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["issue_template"]; found {
		err = json.Unmarshal(raw, &a.IssueTemplate)
		if err != nil {
			return fmt.Errorf("error reading 'issue_template': %w", err)
		}
		delete(object, "issue_template")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssueTemplateApplicationIssue_Links to handle AdditionalProperties
func (a IssueTemplateApplicationIssue_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["issue_template"], err = json.Marshal(a.IssueTemplate)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'issue_template': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssueTemplatePagedArray_Links. Returns the specified
// element and whether it was found
func (a IssueTemplatePagedArray_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssueTemplatePagedArray_Links
func (a *IssueTemplatePagedArray_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssueTemplatePagedArray_Links to handle AdditionalProperties
func (a *IssueTemplatePagedArray_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["create-form"]; found {
		err = json.Unmarshal(raw, &a.CreateForm)
		if err != nil {
			return fmt.Errorf("error reading 'create-form': %w", err)
		}
		delete(object, "create-form")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssueTemplatePagedArray_Links to handle AdditionalProperties
func (a IssueTemplatePagedArray_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.CreateForm != nil {
		object["create-form"], err = json.Marshal(a.CreateForm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create-form': %w", err)
		}
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MetricProvider_Links. Returns the specified
// element and whether it was found
func (a MetricProvider_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MetricProvider_Links
func (a *MetricProvider_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MetricProvider_Links to handle AdditionalProperties
func (a *MetricProvider_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["events"]; found {
		err = json.Unmarshal(raw, &a.Events)
		if err != nil {
			return fmt.Errorf("error reading 'events': %w", err)
		}
		delete(object, "events")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["watchdog"]; found {
		err = json.Unmarshal(raw, &a.Watchdog)
		if err != nil {
			return fmt.Errorf("error reading 'watchdog': %w", err)
		}
		delete(object, "watchdog")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MetricProvider_Links to handle AdditionalProperties
func (a MetricProvider_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["events"], err = json.Marshal(a.Events)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["watchdog"], err = json.Marshal(a.Watchdog)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'watchdog': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for MetricProviderPagedArray_Links. Returns the specified
// element and whether it was found
func (a MetricProviderPagedArray_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for MetricProviderPagedArray_Links
func (a *MetricProviderPagedArray_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for MetricProviderPagedArray_Links to handle AdditionalProperties
func (a *MetricProviderPagedArray_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["create-form"]; found {
		err = json.Unmarshal(raw, &a.CreateForm)
		if err != nil {
			return fmt.Errorf("error reading 'create-form': %w", err)
		}
		delete(object, "create-form")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for MetricProviderPagedArray_Links to handle AdditionalProperties
func (a MetricProviderPagedArray_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.CreateForm != nil {
		object["create-form"], err = json.Marshal(a.CreateForm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create-form': %w", err)
		}
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Update_Links. Returns the specified
// element and whether it was found
func (a Update_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Update_Links
func (a *Update_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Update_Links to handle AdditionalProperties
func (a *Update_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["events:by-context"]; found {
		err = json.Unmarshal(raw, &a.EventsByContext)
		if err != nil {
			return fmt.Errorf("error reading 'events:by-context': %w", err)
		}
		delete(object, "events:by-context")
	}

	if raw, found := object["issue"]; found {
		err = json.Unmarshal(raw, &a.Issue)
		if err != nil {
			return fmt.Errorf("error reading 'issue': %w", err)
		}
		delete(object, "issue")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["update-form"]; found {
		err = json.Unmarshal(raw, &a.UpdateForm)
		if err != nil {
			return fmt.Errorf("error reading 'update-form': %w", err)
		}
		delete(object, "update-form")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Update_Links to handle AdditionalProperties
func (a Update_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["events:by-context"], err = json.Marshal(a.EventsByContext)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events:by-context': %w", err)
	}

	object["issue"], err = json.Marshal(a.Issue)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'issue': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["update-form"], err = json.Marshal(a.UpdateForm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'update-form': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateExpansionary_Links. Returns the specified
// element and whether it was found
func (a UpdateExpansionary_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateExpansionary_Links
func (a *UpdateExpansionary_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateExpansionary_Links to handle AdditionalProperties
func (a *UpdateExpansionary_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["events:by-context"]; found {
		err = json.Unmarshal(raw, &a.EventsByContext)
		if err != nil {
			return fmt.Errorf("error reading 'events:by-context': %w", err)
		}
		delete(object, "events:by-context")
	}

	if raw, found := object["issue"]; found {
		err = json.Unmarshal(raw, &a.Issue)
		if err != nil {
			return fmt.Errorf("error reading 'issue': %w", err)
		}
		delete(object, "issue")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["update-form"]; found {
		err = json.Unmarshal(raw, &a.UpdateForm)
		if err != nil {
			return fmt.Errorf("error reading 'update-form': %w", err)
		}
		delete(object, "update-form")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateExpansionary_Links to handle AdditionalProperties
func (a UpdateExpansionary_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["events:by-context"], err = json.Marshal(a.EventsByContext)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'events:by-context': %w", err)
	}

	object["issue"], err = json.Marshal(a.Issue)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'issue': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["update-form"], err = json.Marshal(a.UpdateForm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'update-form': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateExpansionaryPagedArray_Links. Returns the specified
// element and whether it was found
func (a UpdateExpansionaryPagedArray_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateExpansionaryPagedArray_Links
func (a *UpdateExpansionaryPagedArray_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateExpansionaryPagedArray_Links to handle AdditionalProperties
func (a *UpdateExpansionaryPagedArray_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["beginning"]; found {
		err = json.Unmarshal(raw, &a.Beginning)
		if err != nil {
			return fmt.Errorf("error reading 'beginning': %w", err)
		}
		delete(object, "beginning")
	}

	if raw, found := object["create-form"]; found {
		err = json.Unmarshal(raw, &a.CreateForm)
		if err != nil {
			return fmt.Errorf("error reading 'create-form': %w", err)
		}
		delete(object, "create-form")
	}

	if raw, found := object["next"]; found {
		err = json.Unmarshal(raw, &a.Next)
		if err != nil {
			return fmt.Errorf("error reading 'next': %w", err)
		}
		delete(object, "next")
	}

	if raw, found := object["prev"]; found {
		err = json.Unmarshal(raw, &a.Prev)
		if err != nil {
			return fmt.Errorf("error reading 'prev': %w", err)
		}
		delete(object, "prev")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateExpansionaryPagedArray_Links to handle AdditionalProperties
func (a UpdateExpansionaryPagedArray_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["beginning"], err = json.Marshal(a.Beginning)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'beginning': %w", err)
	}

	if a.CreateForm != nil {
		object["create-form"], err = json.Marshal(a.CreateForm)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'create-form': %w", err)
		}
	}

	if a.Next != nil {
		object["next"], err = json.Marshal(a.Next)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'next': %w", err)
		}
	}

	object["prev"], err = json.Marshal(a.Prev)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'prev': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Watchdog_Links. Returns the specified
// element and whether it was found
func (a Watchdog_Links) Get(fieldName string) (value HALLink, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Watchdog_Links
func (a *Watchdog_Links) Set(fieldName string, value HALLink) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]HALLink)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Watchdog_Links to handle AdditionalProperties
func (a *Watchdog_Links) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["action:convert"]; found {
		err = json.Unmarshal(raw, &a.ActionConvert)
		if err != nil {
			return fmt.Errorf("error reading 'action:convert': %w", err)
		}
		delete(object, "action:convert")
	}

	if raw, found := object["latest_status"]; found {
		err = json.Unmarshal(raw, &a.LatestStatus)
		if err != nil {
			return fmt.Errorf("error reading 'latest_status': %w", err)
		}
		delete(object, "latest_status")
	}

	if raw, found := object["metric_providers"]; found {
		err = json.Unmarshal(raw, &a.MetricProviders)
		if err != nil {
			return fmt.Errorf("error reading 'metric_providers': %w", err)
		}
		delete(object, "metric_providers")
	}

	if raw, found := object["self"]; found {
		err = json.Unmarshal(raw, &a.Self)
		if err != nil {
			return fmt.Errorf("error reading 'self': %w", err)
		}
		delete(object, "self")
	}

	if raw, found := object["statuses"]; found {
		err = json.Unmarshal(raw, &a.Statuses)
		if err != nil {
			return fmt.Errorf("error reading 'statuses': %w", err)
		}
		delete(object, "statuses")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]HALLink)
		for fieldName, fieldBuf := range object {
			var fieldVal HALLink
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Watchdog_Links to handle AdditionalProperties
func (a Watchdog_Links) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["action:convert"], err = json.Marshal(a.ActionConvert)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'action:convert': %w", err)
	}

	if a.LatestStatus != nil {
		object["latest_status"], err = json.Marshal(a.LatestStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_status': %w", err)
		}
	}

	object["metric_providers"], err = json.Marshal(a.MetricProviders)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'metric_providers': %w", err)
	}

	object["self"], err = json.Marshal(a.Self)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'self': %w", err)
	}

	object["statuses"], err = json.Marshal(a.Statuses)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'statuses': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsComponentExpansionaryGroup0 returns the union data inside the ComponentExpansionary_Group as a ComponentExpansionaryGroup0
func (t ComponentExpansionary_Group) AsComponentExpansionaryGroup0() (ComponentExpansionaryGroup0, error) {
	var body ComponentExpansionaryGroup0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComponentExpansionaryGroup0 overwrites any union data inside the ComponentExpansionary_Group as the provided ComponentExpansionaryGroup0
func (t *ComponentExpansionary_Group) FromComponentExpansionaryGroup0(v ComponentExpansionaryGroup0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComponentExpansionaryGroup0 performs a merge with any union data inside the ComponentExpansionary_Group, using the provided ComponentExpansionaryGroup0
func (t *ComponentExpansionary_Group) MergeComponentExpansionaryGroup0(v ComponentExpansionaryGroup0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsComponentExpansionaryGroup1 returns the union data inside the ComponentExpansionary_Group as a ComponentExpansionaryGroup1
func (t ComponentExpansionary_Group) AsComponentExpansionaryGroup1() (ComponentExpansionaryGroup1, error) {
	var body ComponentExpansionaryGroup1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComponentExpansionaryGroup1 overwrites any union data inside the ComponentExpansionary_Group as the provided ComponentExpansionaryGroup1
func (t *ComponentExpansionary_Group) FromComponentExpansionaryGroup1(v ComponentExpansionaryGroup1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComponentExpansionaryGroup1 performs a merge with any union data inside the ComponentExpansionary_Group, using the provided ComponentExpansionaryGroup1
func (t *ComponentExpansionary_Group) MergeComponentExpansionaryGroup1(v ComponentExpansionaryGroup1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ComponentExpansionary_Group) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ComponentExpansionary_Group) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsComponentExpansionaryWatchdog0 returns the union data inside the ComponentExpansionary_Watchdog as a ComponentExpansionaryWatchdog0
func (t ComponentExpansionary_Watchdog) AsComponentExpansionaryWatchdog0() (ComponentExpansionaryWatchdog0, error) {
	var body ComponentExpansionaryWatchdog0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComponentExpansionaryWatchdog0 overwrites any union data inside the ComponentExpansionary_Watchdog as the provided ComponentExpansionaryWatchdog0
func (t *ComponentExpansionary_Watchdog) FromComponentExpansionaryWatchdog0(v ComponentExpansionaryWatchdog0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComponentExpansionaryWatchdog0 performs a merge with any union data inside the ComponentExpansionary_Watchdog, using the provided ComponentExpansionaryWatchdog0
func (t *ComponentExpansionary_Watchdog) MergeComponentExpansionaryWatchdog0(v ComponentExpansionaryWatchdog0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsComponentExpansionaryWatchdog1 returns the union data inside the ComponentExpansionary_Watchdog as a ComponentExpansionaryWatchdog1
func (t ComponentExpansionary_Watchdog) AsComponentExpansionaryWatchdog1() (ComponentExpansionaryWatchdog1, error) {
	var body ComponentExpansionaryWatchdog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComponentExpansionaryWatchdog1 overwrites any union data inside the ComponentExpansionary_Watchdog as the provided ComponentExpansionaryWatchdog1
func (t *ComponentExpansionary_Watchdog) FromComponentExpansionaryWatchdog1(v ComponentExpansionaryWatchdog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComponentExpansionaryWatchdog1 performs a merge with any union data inside the ComponentExpansionary_Watchdog, using the provided ComponentExpansionaryWatchdog1
func (t *ComponentExpansionary_Watchdog) MergeComponentExpansionaryWatchdog1(v ComponentExpansionaryWatchdog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ComponentExpansionary_Watchdog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ComponentExpansionary_Watchdog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFormMetricProviderCreate0 returns the union data inside the FormMetricProviderCreate as a FormMetricProviderCreate0
func (t FormMetricProviderCreate) AsFormMetricProviderCreate0() (FormMetricProviderCreate0, error) {
	var body FormMetricProviderCreate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderCreate0 overwrites any union data inside the FormMetricProviderCreate as the provided FormMetricProviderCreate0
func (t *FormMetricProviderCreate) FromFormMetricProviderCreate0(v FormMetricProviderCreate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderCreate0 performs a merge with any union data inside the FormMetricProviderCreate, using the provided FormMetricProviderCreate0
func (t *FormMetricProviderCreate) MergeFormMetricProviderCreate0(v FormMetricProviderCreate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderCreate1 returns the union data inside the FormMetricProviderCreate as a FormMetricProviderCreate1
func (t FormMetricProviderCreate) AsFormMetricProviderCreate1() (FormMetricProviderCreate1, error) {
	var body FormMetricProviderCreate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderCreate1 overwrites any union data inside the FormMetricProviderCreate as the provided FormMetricProviderCreate1
func (t *FormMetricProviderCreate) FromFormMetricProviderCreate1(v FormMetricProviderCreate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderCreate1 performs a merge with any union data inside the FormMetricProviderCreate, using the provided FormMetricProviderCreate1
func (t *FormMetricProviderCreate) MergeFormMetricProviderCreate1(v FormMetricProviderCreate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderCreate2 returns the union data inside the FormMetricProviderCreate as a FormMetricProviderCreate2
func (t FormMetricProviderCreate) AsFormMetricProviderCreate2() (FormMetricProviderCreate2, error) {
	var body FormMetricProviderCreate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderCreate2 overwrites any union data inside the FormMetricProviderCreate as the provided FormMetricProviderCreate2
func (t *FormMetricProviderCreate) FromFormMetricProviderCreate2(v FormMetricProviderCreate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderCreate2 performs a merge with any union data inside the FormMetricProviderCreate, using the provided FormMetricProviderCreate2
func (t *FormMetricProviderCreate) MergeFormMetricProviderCreate2(v FormMetricProviderCreate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderCreate3 returns the union data inside the FormMetricProviderCreate as a FormMetricProviderCreate3
func (t FormMetricProviderCreate) AsFormMetricProviderCreate3() (FormMetricProviderCreate3, error) {
	var body FormMetricProviderCreate3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderCreate3 overwrites any union data inside the FormMetricProviderCreate as the provided FormMetricProviderCreate3
func (t *FormMetricProviderCreate) FromFormMetricProviderCreate3(v FormMetricProviderCreate3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderCreate3 performs a merge with any union data inside the FormMetricProviderCreate, using the provided FormMetricProviderCreate3
func (t *FormMetricProviderCreate) MergeFormMetricProviderCreate3(v FormMetricProviderCreate3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderCreate4 returns the union data inside the FormMetricProviderCreate as a FormMetricProviderCreate4
func (t FormMetricProviderCreate) AsFormMetricProviderCreate4() (FormMetricProviderCreate4, error) {
	var body FormMetricProviderCreate4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderCreate4 overwrites any union data inside the FormMetricProviderCreate as the provided FormMetricProviderCreate4
func (t *FormMetricProviderCreate) FromFormMetricProviderCreate4(v FormMetricProviderCreate4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderCreate4 performs a merge with any union data inside the FormMetricProviderCreate, using the provided FormMetricProviderCreate4
func (t *FormMetricProviderCreate) MergeFormMetricProviderCreate4(v FormMetricProviderCreate4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderCreate5 returns the union data inside the FormMetricProviderCreate as a FormMetricProviderCreate5
func (t FormMetricProviderCreate) AsFormMetricProviderCreate5() (FormMetricProviderCreate5, error) {
	var body FormMetricProviderCreate5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderCreate5 overwrites any union data inside the FormMetricProviderCreate as the provided FormMetricProviderCreate5
func (t *FormMetricProviderCreate) FromFormMetricProviderCreate5(v FormMetricProviderCreate5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderCreate5 performs a merge with any union data inside the FormMetricProviderCreate, using the provided FormMetricProviderCreate5
func (t *FormMetricProviderCreate) MergeFormMetricProviderCreate5(v FormMetricProviderCreate5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t FormMetricProviderCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FormMetricProviderCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFormMetricProviderUpdate0 returns the union data inside the FormMetricProviderUpdate as a FormMetricProviderUpdate0
func (t FormMetricProviderUpdate) AsFormMetricProviderUpdate0() (FormMetricProviderUpdate0, error) {
	var body FormMetricProviderUpdate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderUpdate0 overwrites any union data inside the FormMetricProviderUpdate as the provided FormMetricProviderUpdate0
func (t *FormMetricProviderUpdate) FromFormMetricProviderUpdate0(v FormMetricProviderUpdate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderUpdate0 performs a merge with any union data inside the FormMetricProviderUpdate, using the provided FormMetricProviderUpdate0
func (t *FormMetricProviderUpdate) MergeFormMetricProviderUpdate0(v FormMetricProviderUpdate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderUpdate1 returns the union data inside the FormMetricProviderUpdate as a FormMetricProviderUpdate1
func (t FormMetricProviderUpdate) AsFormMetricProviderUpdate1() (FormMetricProviderUpdate1, error) {
	var body FormMetricProviderUpdate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderUpdate1 overwrites any union data inside the FormMetricProviderUpdate as the provided FormMetricProviderUpdate1
func (t *FormMetricProviderUpdate) FromFormMetricProviderUpdate1(v FormMetricProviderUpdate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderUpdate1 performs a merge with any union data inside the FormMetricProviderUpdate, using the provided FormMetricProviderUpdate1
func (t *FormMetricProviderUpdate) MergeFormMetricProviderUpdate1(v FormMetricProviderUpdate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderUpdate2 returns the union data inside the FormMetricProviderUpdate as a FormMetricProviderUpdate2
func (t FormMetricProviderUpdate) AsFormMetricProviderUpdate2() (FormMetricProviderUpdate2, error) {
	var body FormMetricProviderUpdate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderUpdate2 overwrites any union data inside the FormMetricProviderUpdate as the provided FormMetricProviderUpdate2
func (t *FormMetricProviderUpdate) FromFormMetricProviderUpdate2(v FormMetricProviderUpdate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderUpdate2 performs a merge with any union data inside the FormMetricProviderUpdate, using the provided FormMetricProviderUpdate2
func (t *FormMetricProviderUpdate) MergeFormMetricProviderUpdate2(v FormMetricProviderUpdate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderUpdate3 returns the union data inside the FormMetricProviderUpdate as a FormMetricProviderUpdate3
func (t FormMetricProviderUpdate) AsFormMetricProviderUpdate3() (FormMetricProviderUpdate3, error) {
	var body FormMetricProviderUpdate3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderUpdate3 overwrites any union data inside the FormMetricProviderUpdate as the provided FormMetricProviderUpdate3
func (t *FormMetricProviderUpdate) FromFormMetricProviderUpdate3(v FormMetricProviderUpdate3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderUpdate3 performs a merge with any union data inside the FormMetricProviderUpdate, using the provided FormMetricProviderUpdate3
func (t *FormMetricProviderUpdate) MergeFormMetricProviderUpdate3(v FormMetricProviderUpdate3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderUpdate4 returns the union data inside the FormMetricProviderUpdate as a FormMetricProviderUpdate4
func (t FormMetricProviderUpdate) AsFormMetricProviderUpdate4() (FormMetricProviderUpdate4, error) {
	var body FormMetricProviderUpdate4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderUpdate4 overwrites any union data inside the FormMetricProviderUpdate as the provided FormMetricProviderUpdate4
func (t *FormMetricProviderUpdate) FromFormMetricProviderUpdate4(v FormMetricProviderUpdate4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderUpdate4 performs a merge with any union data inside the FormMetricProviderUpdate, using the provided FormMetricProviderUpdate4
func (t *FormMetricProviderUpdate) MergeFormMetricProviderUpdate4(v FormMetricProviderUpdate4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderUpdate5 returns the union data inside the FormMetricProviderUpdate as a FormMetricProviderUpdate5
func (t FormMetricProviderUpdate) AsFormMetricProviderUpdate5() (FormMetricProviderUpdate5, error) {
	var body FormMetricProviderUpdate5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderUpdate5 overwrites any union data inside the FormMetricProviderUpdate as the provided FormMetricProviderUpdate5
func (t *FormMetricProviderUpdate) FromFormMetricProviderUpdate5(v FormMetricProviderUpdate5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderUpdate5 performs a merge with any union data inside the FormMetricProviderUpdate, using the provided FormMetricProviderUpdate5
func (t *FormMetricProviderUpdate) MergeFormMetricProviderUpdate5(v FormMetricProviderUpdate5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormMetricProviderUpdate6 returns the union data inside the FormMetricProviderUpdate as a FormMetricProviderUpdate6
func (t FormMetricProviderUpdate) AsFormMetricProviderUpdate6() (FormMetricProviderUpdate6, error) {
	var body FormMetricProviderUpdate6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormMetricProviderUpdate6 overwrites any union data inside the FormMetricProviderUpdate as the provided FormMetricProviderUpdate6
func (t *FormMetricProviderUpdate) FromFormMetricProviderUpdate6(v FormMetricProviderUpdate6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormMetricProviderUpdate6 performs a merge with any union data inside the FormMetricProviderUpdate, using the provided FormMetricProviderUpdate6
func (t *FormMetricProviderUpdate) MergeFormMetricProviderUpdate6(v FormMetricProviderUpdate6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t FormMetricProviderUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FormMetricProviderUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFormWatchdogCreate0 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate0
func (t FormWatchdogCreate) AsFormWatchdogCreate0() (FormWatchdogCreate0, error) {
	var body FormWatchdogCreate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate0 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate0
func (t *FormWatchdogCreate) FromFormWatchdogCreate0(v FormWatchdogCreate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate0 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate0
func (t *FormWatchdogCreate) MergeFormWatchdogCreate0(v FormWatchdogCreate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate1 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate1
func (t FormWatchdogCreate) AsFormWatchdogCreate1() (FormWatchdogCreate1, error) {
	var body FormWatchdogCreate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate1 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate1
func (t *FormWatchdogCreate) FromFormWatchdogCreate1(v FormWatchdogCreate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate1 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate1
func (t *FormWatchdogCreate) MergeFormWatchdogCreate1(v FormWatchdogCreate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate2 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate2
func (t FormWatchdogCreate) AsFormWatchdogCreate2() (FormWatchdogCreate2, error) {
	var body FormWatchdogCreate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate2 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate2
func (t *FormWatchdogCreate) FromFormWatchdogCreate2(v FormWatchdogCreate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate2 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate2
func (t *FormWatchdogCreate) MergeFormWatchdogCreate2(v FormWatchdogCreate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate3 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate3
func (t FormWatchdogCreate) AsFormWatchdogCreate3() (FormWatchdogCreate3, error) {
	var body FormWatchdogCreate3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate3 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate3
func (t *FormWatchdogCreate) FromFormWatchdogCreate3(v FormWatchdogCreate3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate3 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate3
func (t *FormWatchdogCreate) MergeFormWatchdogCreate3(v FormWatchdogCreate3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate4 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate4
func (t FormWatchdogCreate) AsFormWatchdogCreate4() (FormWatchdogCreate4, error) {
	var body FormWatchdogCreate4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate4 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate4
func (t *FormWatchdogCreate) FromFormWatchdogCreate4(v FormWatchdogCreate4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate4 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate4
func (t *FormWatchdogCreate) MergeFormWatchdogCreate4(v FormWatchdogCreate4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate5 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate5
func (t FormWatchdogCreate) AsFormWatchdogCreate5() (FormWatchdogCreate5, error) {
	var body FormWatchdogCreate5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate5 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate5
func (t *FormWatchdogCreate) FromFormWatchdogCreate5(v FormWatchdogCreate5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate5 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate5
func (t *FormWatchdogCreate) MergeFormWatchdogCreate5(v FormWatchdogCreate5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate6 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate6
func (t FormWatchdogCreate) AsFormWatchdogCreate6() (FormWatchdogCreate6, error) {
	var body FormWatchdogCreate6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate6 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate6
func (t *FormWatchdogCreate) FromFormWatchdogCreate6(v FormWatchdogCreate6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate6 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate6
func (t *FormWatchdogCreate) MergeFormWatchdogCreate6(v FormWatchdogCreate6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate7 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate7
func (t FormWatchdogCreate) AsFormWatchdogCreate7() (FormWatchdogCreate7, error) {
	var body FormWatchdogCreate7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate7 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate7
func (t *FormWatchdogCreate) FromFormWatchdogCreate7(v FormWatchdogCreate7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate7 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate7
func (t *FormWatchdogCreate) MergeFormWatchdogCreate7(v FormWatchdogCreate7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogCreate8 returns the union data inside the FormWatchdogCreate as a FormWatchdogCreate8
func (t FormWatchdogCreate) AsFormWatchdogCreate8() (FormWatchdogCreate8, error) {
	var body FormWatchdogCreate8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogCreate8 overwrites any union data inside the FormWatchdogCreate as the provided FormWatchdogCreate8
func (t *FormWatchdogCreate) FromFormWatchdogCreate8(v FormWatchdogCreate8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogCreate8 performs a merge with any union data inside the FormWatchdogCreate, using the provided FormWatchdogCreate8
func (t *FormWatchdogCreate) MergeFormWatchdogCreate8(v FormWatchdogCreate8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t FormWatchdogCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FormWatchdogCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFormWatchdogUpdate0 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate0
func (t FormWatchdogUpdate) AsFormWatchdogUpdate0() (FormWatchdogUpdate0, error) {
	var body FormWatchdogUpdate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate0 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate0
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate0(v FormWatchdogUpdate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate0 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate0
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate0(v FormWatchdogUpdate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate1 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate1
func (t FormWatchdogUpdate) AsFormWatchdogUpdate1() (FormWatchdogUpdate1, error) {
	var body FormWatchdogUpdate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate1 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate1
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate1(v FormWatchdogUpdate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate1 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate1
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate1(v FormWatchdogUpdate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate2 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate2
func (t FormWatchdogUpdate) AsFormWatchdogUpdate2() (FormWatchdogUpdate2, error) {
	var body FormWatchdogUpdate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate2 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate2
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate2(v FormWatchdogUpdate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate2 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate2
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate2(v FormWatchdogUpdate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate3 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate3
func (t FormWatchdogUpdate) AsFormWatchdogUpdate3() (FormWatchdogUpdate3, error) {
	var body FormWatchdogUpdate3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate3 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate3
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate3(v FormWatchdogUpdate3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate3 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate3
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate3(v FormWatchdogUpdate3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate4 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate4
func (t FormWatchdogUpdate) AsFormWatchdogUpdate4() (FormWatchdogUpdate4, error) {
	var body FormWatchdogUpdate4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate4 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate4
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate4(v FormWatchdogUpdate4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate4 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate4
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate4(v FormWatchdogUpdate4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate5 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate5
func (t FormWatchdogUpdate) AsFormWatchdogUpdate5() (FormWatchdogUpdate5, error) {
	var body FormWatchdogUpdate5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate5 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate5
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate5(v FormWatchdogUpdate5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate5 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate5
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate5(v FormWatchdogUpdate5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate6 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate6
func (t FormWatchdogUpdate) AsFormWatchdogUpdate6() (FormWatchdogUpdate6, error) {
	var body FormWatchdogUpdate6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate6 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate6
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate6(v FormWatchdogUpdate6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate6 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate6
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate6(v FormWatchdogUpdate6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate7 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate7
func (t FormWatchdogUpdate) AsFormWatchdogUpdate7() (FormWatchdogUpdate7, error) {
	var body FormWatchdogUpdate7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate7 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate7
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate7(v FormWatchdogUpdate7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate7 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate7
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate7(v FormWatchdogUpdate7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate8 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate8
func (t FormWatchdogUpdate) AsFormWatchdogUpdate8() (FormWatchdogUpdate8, error) {
	var body FormWatchdogUpdate8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate8 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate8
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate8(v FormWatchdogUpdate8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate8 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate8
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate8(v FormWatchdogUpdate8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFormWatchdogUpdate9 returns the union data inside the FormWatchdogUpdate as a FormWatchdogUpdate9
func (t FormWatchdogUpdate) AsFormWatchdogUpdate9() (FormWatchdogUpdate9, error) {
	var body FormWatchdogUpdate9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFormWatchdogUpdate9 overwrites any union data inside the FormWatchdogUpdate as the provided FormWatchdogUpdate9
func (t *FormWatchdogUpdate) FromFormWatchdogUpdate9(v FormWatchdogUpdate9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFormWatchdogUpdate9 performs a merge with any union data inside the FormWatchdogUpdate, using the provided FormWatchdogUpdate9
func (t *FormWatchdogUpdate) MergeFormWatchdogUpdate9(v FormWatchdogUpdate9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t FormWatchdogUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FormWatchdogUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsComponentPagedArray returns the union data inside the Group_Components as a ComponentPagedArray
func (t Group_Components) AsComponentPagedArray() (ComponentPagedArray, error) {
	var body ComponentPagedArray
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromComponentPagedArray overwrites any union data inside the Group_Components as the provided ComponentPagedArray
func (t *Group_Components) FromComponentPagedArray(v ComponentPagedArray) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeComponentPagedArray performs a merge with any union data inside the Group_Components, using the provided ComponentPagedArray
func (t *Group_Components) MergeComponentPagedArray(v ComponentPagedArray) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsGroupComponents1 returns the union data inside the Group_Components as a GroupComponents1
func (t Group_Components) AsGroupComponents1() (GroupComponents1, error) {
	var body GroupComponents1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGroupComponents1 overwrites any union data inside the Group_Components as the provided GroupComponents1
func (t *Group_Components) FromGroupComponents1(v GroupComponents1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGroupComponents1 performs a merge with any union data inside the Group_Components, using the provided GroupComponents1
func (t *Group_Components) MergeGroupComponents1(v GroupComponents1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Group_Components) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Group_Components) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIssueFormCancelBody0 returns the union data inside the IssueFormCancel_Body as a IssueFormCancelBody0
func (t IssueFormCancel_Body) AsIssueFormCancelBody0() (IssueFormCancelBody0, error) {
	var body IssueFormCancelBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormCancelBody0 overwrites any union data inside the IssueFormCancel_Body as the provided IssueFormCancelBody0
func (t *IssueFormCancel_Body) FromIssueFormCancelBody0(v IssueFormCancelBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormCancelBody0 performs a merge with any union data inside the IssueFormCancel_Body, using the provided IssueFormCancelBody0
func (t *IssueFormCancel_Body) MergeIssueFormCancelBody0(v IssueFormCancelBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueFormCancelBody1 returns the union data inside the IssueFormCancel_Body as a IssueFormCancelBody1
func (t IssueFormCancel_Body) AsIssueFormCancelBody1() (IssueFormCancelBody1, error) {
	var body IssueFormCancelBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormCancelBody1 overwrites any union data inside the IssueFormCancel_Body as the provided IssueFormCancelBody1
func (t *IssueFormCancel_Body) FromIssueFormCancelBody1(v IssueFormCancelBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormCancelBody1 performs a merge with any union data inside the IssueFormCancel_Body, using the provided IssueFormCancelBody1
func (t *IssueFormCancel_Body) MergeIssueFormCancelBody1(v IssueFormCancelBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueFormCancel_Body) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueFormCancel_Body) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIssueFormCancelTemplate0 returns the union data inside the IssueFormCancel_Template as a IssueFormCancelTemplate0
func (t IssueFormCancel_Template) AsIssueFormCancelTemplate0() (IssueFormCancelTemplate0, error) {
	var body IssueFormCancelTemplate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormCancelTemplate0 overwrites any union data inside the IssueFormCancel_Template as the provided IssueFormCancelTemplate0
func (t *IssueFormCancel_Template) FromIssueFormCancelTemplate0(v IssueFormCancelTemplate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormCancelTemplate0 performs a merge with any union data inside the IssueFormCancel_Template, using the provided IssueFormCancelTemplate0
func (t *IssueFormCancel_Template) MergeIssueFormCancelTemplate0(v IssueFormCancelTemplate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueFormCancelTemplate1 returns the union data inside the IssueFormCancel_Template as a IssueFormCancelTemplate1
func (t IssueFormCancel_Template) AsIssueFormCancelTemplate1() (IssueFormCancelTemplate1, error) {
	var body IssueFormCancelTemplate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormCancelTemplate1 overwrites any union data inside the IssueFormCancel_Template as the provided IssueFormCancelTemplate1
func (t *IssueFormCancel_Template) FromIssueFormCancelTemplate1(v IssueFormCancelTemplate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormCancelTemplate1 performs a merge with any union data inside the IssueFormCancel_Template, using the provided IssueFormCancelTemplate1
func (t *IssueFormCancel_Template) MergeIssueFormCancelTemplate1(v IssueFormCancelTemplate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueFormCancel_Template) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueFormCancel_Template) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIssueFormCreateTemplate0 returns the union data inside the IssueFormCreate_Template as a IssueFormCreateTemplate0
func (t IssueFormCreate_Template) AsIssueFormCreateTemplate0() (IssueFormCreateTemplate0, error) {
	var body IssueFormCreateTemplate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormCreateTemplate0 overwrites any union data inside the IssueFormCreate_Template as the provided IssueFormCreateTemplate0
func (t *IssueFormCreate_Template) FromIssueFormCreateTemplate0(v IssueFormCreateTemplate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormCreateTemplate0 performs a merge with any union data inside the IssueFormCreate_Template, using the provided IssueFormCreateTemplate0
func (t *IssueFormCreate_Template) MergeIssueFormCreateTemplate0(v IssueFormCreateTemplate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueFormCreateTemplate1 returns the union data inside the IssueFormCreate_Template as a IssueFormCreateTemplate1
func (t IssueFormCreate_Template) AsIssueFormCreateTemplate1() (IssueFormCreateTemplate1, error) {
	var body IssueFormCreateTemplate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormCreateTemplate1 overwrites any union data inside the IssueFormCreate_Template as the provided IssueFormCreateTemplate1
func (t *IssueFormCreate_Template) FromIssueFormCreateTemplate1(v IssueFormCreateTemplate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormCreateTemplate1 performs a merge with any union data inside the IssueFormCreate_Template, using the provided IssueFormCreateTemplate1
func (t *IssueFormCreate_Template) MergeIssueFormCreateTemplate1(v IssueFormCreateTemplate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueFormCreate_Template) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueFormCreate_Template) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIssueFormUpdateTemplate0 returns the union data inside the IssueFormUpdate_Template as a IssueFormUpdateTemplate0
func (t IssueFormUpdate_Template) AsIssueFormUpdateTemplate0() (IssueFormUpdateTemplate0, error) {
	var body IssueFormUpdateTemplate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormUpdateTemplate0 overwrites any union data inside the IssueFormUpdate_Template as the provided IssueFormUpdateTemplate0
func (t *IssueFormUpdate_Template) FromIssueFormUpdateTemplate0(v IssueFormUpdateTemplate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormUpdateTemplate0 performs a merge with any union data inside the IssueFormUpdate_Template, using the provided IssueFormUpdateTemplate0
func (t *IssueFormUpdate_Template) MergeIssueFormUpdateTemplate0(v IssueFormUpdateTemplate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueFormUpdateTemplate1 returns the union data inside the IssueFormUpdate_Template as a IssueFormUpdateTemplate1
func (t IssueFormUpdate_Template) AsIssueFormUpdateTemplate1() (IssueFormUpdateTemplate1, error) {
	var body IssueFormUpdateTemplate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormUpdateTemplate1 overwrites any union data inside the IssueFormUpdate_Template as the provided IssueFormUpdateTemplate1
func (t *IssueFormUpdate_Template) FromIssueFormUpdateTemplate1(v IssueFormUpdateTemplate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormUpdateTemplate1 performs a merge with any union data inside the IssueFormUpdate_Template, using the provided IssueFormUpdateTemplate1
func (t *IssueFormUpdate_Template) MergeIssueFormUpdateTemplate1(v IssueFormUpdateTemplate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueFormUpdateTemplate2 returns the union data inside the IssueFormUpdate_Template as a IssueFormUpdateTemplate2
func (t IssueFormUpdate_Template) AsIssueFormUpdateTemplate2() (IssueFormUpdateTemplate2, error) {
	var body IssueFormUpdateTemplate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueFormUpdateTemplate2 overwrites any union data inside the IssueFormUpdate_Template as the provided IssueFormUpdateTemplate2
func (t *IssueFormUpdate_Template) FromIssueFormUpdateTemplate2(v IssueFormUpdateTemplate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueFormUpdateTemplate2 performs a merge with any union data inside the IssueFormUpdate_Template, using the provided IssueFormUpdateTemplate2
func (t *IssueFormUpdate_Template) MergeIssueFormUpdateTemplate2(v IssueFormUpdateTemplate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueFormUpdate_Template) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueFormUpdate_Template) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIssueTemplateVariableApplication0 returns the union data inside the IssueTemplateVariableApplication as a IssueTemplateVariableApplication0
func (t IssueTemplateVariableApplication) AsIssueTemplateVariableApplication0() (IssueTemplateVariableApplication0, error) {
	var body IssueTemplateVariableApplication0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueTemplateVariableApplication0 overwrites any union data inside the IssueTemplateVariableApplication as the provided IssueTemplateVariableApplication0
func (t *IssueTemplateVariableApplication) FromIssueTemplateVariableApplication0(v IssueTemplateVariableApplication0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueTemplateVariableApplication0 performs a merge with any union data inside the IssueTemplateVariableApplication, using the provided IssueTemplateVariableApplication0
func (t *IssueTemplateVariableApplication) MergeIssueTemplateVariableApplication0(v IssueTemplateVariableApplication0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueTemplateVariableApplication1 returns the union data inside the IssueTemplateVariableApplication as a IssueTemplateVariableApplication1
func (t IssueTemplateVariableApplication) AsIssueTemplateVariableApplication1() (IssueTemplateVariableApplication1, error) {
	var body IssueTemplateVariableApplication1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueTemplateVariableApplication1 overwrites any union data inside the IssueTemplateVariableApplication as the provided IssueTemplateVariableApplication1
func (t *IssueTemplateVariableApplication) FromIssueTemplateVariableApplication1(v IssueTemplateVariableApplication1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueTemplateVariableApplication1 performs a merge with any union data inside the IssueTemplateVariableApplication, using the provided IssueTemplateVariableApplication1
func (t *IssueTemplateVariableApplication) MergeIssueTemplateVariableApplication1(v IssueTemplateVariableApplication1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueTemplateVariableApplication2 returns the union data inside the IssueTemplateVariableApplication as a IssueTemplateVariableApplication2
func (t IssueTemplateVariableApplication) AsIssueTemplateVariableApplication2() (IssueTemplateVariableApplication2, error) {
	var body IssueTemplateVariableApplication2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueTemplateVariableApplication2 overwrites any union data inside the IssueTemplateVariableApplication as the provided IssueTemplateVariableApplication2
func (t *IssueTemplateVariableApplication) FromIssueTemplateVariableApplication2(v IssueTemplateVariableApplication2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueTemplateVariableApplication2 performs a merge with any union data inside the IssueTemplateVariableApplication, using the provided IssueTemplateVariableApplication2
func (t *IssueTemplateVariableApplication) MergeIssueTemplateVariableApplication2(v IssueTemplateVariableApplication2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueTemplateVariableApplication3 returns the union data inside the IssueTemplateVariableApplication as a IssueTemplateVariableApplication3
func (t IssueTemplateVariableApplication) AsIssueTemplateVariableApplication3() (IssueTemplateVariableApplication3, error) {
	var body IssueTemplateVariableApplication3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueTemplateVariableApplication3 overwrites any union data inside the IssueTemplateVariableApplication as the provided IssueTemplateVariableApplication3
func (t *IssueTemplateVariableApplication) FromIssueTemplateVariableApplication3(v IssueTemplateVariableApplication3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueTemplateVariableApplication3 performs a merge with any union data inside the IssueTemplateVariableApplication, using the provided IssueTemplateVariableApplication3
func (t *IssueTemplateVariableApplication) MergeIssueTemplateVariableApplication3(v IssueTemplateVariableApplication3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueTemplateVariableApplication) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueTemplateVariableApplication) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMetricInstanceFormCreateTitle0 returns the union data inside the MetricInstanceFormCreate_Title as a MetricInstanceFormCreateTitle0
func (t MetricInstanceFormCreate_Title) AsMetricInstanceFormCreateTitle0() (MetricInstanceFormCreateTitle0, error) {
	var body MetricInstanceFormCreateTitle0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricInstanceFormCreateTitle0 overwrites any union data inside the MetricInstanceFormCreate_Title as the provided MetricInstanceFormCreateTitle0
func (t *MetricInstanceFormCreate_Title) FromMetricInstanceFormCreateTitle0(v MetricInstanceFormCreateTitle0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricInstanceFormCreateTitle0 performs a merge with any union data inside the MetricInstanceFormCreate_Title, using the provided MetricInstanceFormCreateTitle0
func (t *MetricInstanceFormCreate_Title) MergeMetricInstanceFormCreateTitle0(v MetricInstanceFormCreateTitle0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMetricInstanceFormCreateTitle1 returns the union data inside the MetricInstanceFormCreate_Title as a MetricInstanceFormCreateTitle1
func (t MetricInstanceFormCreate_Title) AsMetricInstanceFormCreateTitle1() (MetricInstanceFormCreateTitle1, error) {
	var body MetricInstanceFormCreateTitle1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricInstanceFormCreateTitle1 overwrites any union data inside the MetricInstanceFormCreate_Title as the provided MetricInstanceFormCreateTitle1
func (t *MetricInstanceFormCreate_Title) FromMetricInstanceFormCreateTitle1(v MetricInstanceFormCreateTitle1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricInstanceFormCreateTitle1 performs a merge with any union data inside the MetricInstanceFormCreate_Title, using the provided MetricInstanceFormCreateTitle1
func (t *MetricInstanceFormCreate_Title) MergeMetricInstanceFormCreateTitle1(v MetricInstanceFormCreateTitle1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricInstanceFormCreate_Title) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricInstanceFormCreate_Title) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMetricProviderFormDefaultUpdateInstances0 returns the union data inside the MetricProviderFormDefaultUpdate_Instances_Item as a MetricProviderFormDefaultUpdateInstances0
func (t MetricProviderFormDefaultUpdate_Instances_Item) AsMetricProviderFormDefaultUpdateInstances0() (MetricProviderFormDefaultUpdateInstances0, error) {
	var body MetricProviderFormDefaultUpdateInstances0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricProviderFormDefaultUpdateInstances0 overwrites any union data inside the MetricProviderFormDefaultUpdate_Instances_Item as the provided MetricProviderFormDefaultUpdateInstances0
func (t *MetricProviderFormDefaultUpdate_Instances_Item) FromMetricProviderFormDefaultUpdateInstances0(v MetricProviderFormDefaultUpdateInstances0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricProviderFormDefaultUpdateInstances0 performs a merge with any union data inside the MetricProviderFormDefaultUpdate_Instances_Item, using the provided MetricProviderFormDefaultUpdateInstances0
func (t *MetricProviderFormDefaultUpdate_Instances_Item) MergeMetricProviderFormDefaultUpdateInstances0(v MetricProviderFormDefaultUpdateInstances0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMetricProviderFormDefaultUpdateInstances1 returns the union data inside the MetricProviderFormDefaultUpdate_Instances_Item as a MetricProviderFormDefaultUpdateInstances1
func (t MetricProviderFormDefaultUpdate_Instances_Item) AsMetricProviderFormDefaultUpdateInstances1() (MetricProviderFormDefaultUpdateInstances1, error) {
	var body MetricProviderFormDefaultUpdateInstances1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricProviderFormDefaultUpdateInstances1 overwrites any union data inside the MetricProviderFormDefaultUpdate_Instances_Item as the provided MetricProviderFormDefaultUpdateInstances1
func (t *MetricProviderFormDefaultUpdate_Instances_Item) FromMetricProviderFormDefaultUpdateInstances1(v MetricProviderFormDefaultUpdateInstances1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricProviderFormDefaultUpdateInstances1 performs a merge with any union data inside the MetricProviderFormDefaultUpdate_Instances_Item, using the provided MetricProviderFormDefaultUpdateInstances1
func (t *MetricProviderFormDefaultUpdate_Instances_Item) MergeMetricProviderFormDefaultUpdateInstances1(v MetricProviderFormDefaultUpdateInstances1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricProviderFormDefaultUpdate_Instances_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricProviderFormDefaultUpdate_Instances_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMetricProviderFormEmbeddedUpdateInstances0 returns the union data inside the MetricProviderFormEmbeddedUpdate_Instances_Item as a MetricProviderFormEmbeddedUpdateInstances0
func (t MetricProviderFormEmbeddedUpdate_Instances_Item) AsMetricProviderFormEmbeddedUpdateInstances0() (MetricProviderFormEmbeddedUpdateInstances0, error) {
	var body MetricProviderFormEmbeddedUpdateInstances0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricProviderFormEmbeddedUpdateInstances0 overwrites any union data inside the MetricProviderFormEmbeddedUpdate_Instances_Item as the provided MetricProviderFormEmbeddedUpdateInstances0
func (t *MetricProviderFormEmbeddedUpdate_Instances_Item) FromMetricProviderFormEmbeddedUpdateInstances0(v MetricProviderFormEmbeddedUpdateInstances0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricProviderFormEmbeddedUpdateInstances0 performs a merge with any union data inside the MetricProviderFormEmbeddedUpdate_Instances_Item, using the provided MetricProviderFormEmbeddedUpdateInstances0
func (t *MetricProviderFormEmbeddedUpdate_Instances_Item) MergeMetricProviderFormEmbeddedUpdateInstances0(v MetricProviderFormEmbeddedUpdateInstances0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMetricProviderFormEmbeddedUpdateInstances1 returns the union data inside the MetricProviderFormEmbeddedUpdate_Instances_Item as a MetricProviderFormEmbeddedUpdateInstances1
func (t MetricProviderFormEmbeddedUpdate_Instances_Item) AsMetricProviderFormEmbeddedUpdateInstances1() (MetricProviderFormEmbeddedUpdateInstances1, error) {
	var body MetricProviderFormEmbeddedUpdateInstances1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricProviderFormEmbeddedUpdateInstances1 overwrites any union data inside the MetricProviderFormEmbeddedUpdate_Instances_Item as the provided MetricProviderFormEmbeddedUpdateInstances1
func (t *MetricProviderFormEmbeddedUpdate_Instances_Item) FromMetricProviderFormEmbeddedUpdateInstances1(v MetricProviderFormEmbeddedUpdateInstances1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricProviderFormEmbeddedUpdateInstances1 performs a merge with any union data inside the MetricProviderFormEmbeddedUpdate_Instances_Item, using the provided MetricProviderFormEmbeddedUpdateInstances1
func (t *MetricProviderFormEmbeddedUpdate_Instances_Item) MergeMetricProviderFormEmbeddedUpdateInstances1(v MetricProviderFormEmbeddedUpdateInstances1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricProviderFormEmbeddedUpdate_Instances_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricProviderFormEmbeddedUpdate_Instances_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsMetricProviderFormUpdateInstances0 returns the union data inside the MetricProviderFormUpdate_Instances_Item as a MetricProviderFormUpdateInstances0
func (t MetricProviderFormUpdate_Instances_Item) AsMetricProviderFormUpdateInstances0() (MetricProviderFormUpdateInstances0, error) {
	var body MetricProviderFormUpdateInstances0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricProviderFormUpdateInstances0 overwrites any union data inside the MetricProviderFormUpdate_Instances_Item as the provided MetricProviderFormUpdateInstances0
func (t *MetricProviderFormUpdate_Instances_Item) FromMetricProviderFormUpdateInstances0(v MetricProviderFormUpdateInstances0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricProviderFormUpdateInstances0 performs a merge with any union data inside the MetricProviderFormUpdate_Instances_Item, using the provided MetricProviderFormUpdateInstances0
func (t *MetricProviderFormUpdate_Instances_Item) MergeMetricProviderFormUpdateInstances0(v MetricProviderFormUpdateInstances0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMetricProviderFormUpdateInstances1 returns the union data inside the MetricProviderFormUpdate_Instances_Item as a MetricProviderFormUpdateInstances1
func (t MetricProviderFormUpdate_Instances_Item) AsMetricProviderFormUpdateInstances1() (MetricProviderFormUpdateInstances1, error) {
	var body MetricProviderFormUpdateInstances1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricProviderFormUpdateInstances1 overwrites any union data inside the MetricProviderFormUpdate_Instances_Item as the provided MetricProviderFormUpdateInstances1
func (t *MetricProviderFormUpdate_Instances_Item) FromMetricProviderFormUpdateInstances1(v MetricProviderFormUpdateInstances1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricProviderFormUpdateInstances1 performs a merge with any union data inside the MetricProviderFormUpdate_Instances_Item, using the provided MetricProviderFormUpdateInstances1
func (t *MetricProviderFormUpdate_Instances_Item) MergeMetricProviderFormUpdateInstances1(v MetricProviderFormUpdateInstances1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t MetricProviderFormUpdate_Instances_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MetricProviderFormUpdate_Instances_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNative0 returns the union data inside the Native as a Native0
func (t Native) AsNative0() (Native0, error) {
	var body Native0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNative0 overwrites any union data inside the Native as the provided Native0
func (t *Native) FromNative0(v Native0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNative0 performs a merge with any union data inside the Native, using the provided Native0
func (t *Native) MergeNative0(v Native0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNative1 returns the union data inside the Native as a Native1
func (t Native) AsNative1() (Native1, error) {
	var body Native1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNative1 overwrites any union data inside the Native as the provided Native1
func (t *Native) FromNative1(v Native1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNative1 performs a merge with any union data inside the Native, using the provided Native1
func (t *Native) MergeNative1(v Native1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNative2 returns the union data inside the Native as a Native2
func (t Native) AsNative2() (Native2, error) {
	var body Native2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNative2 overwrites any union data inside the Native as the provided Native2
func (t *Native) FromNative2(v Native2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNative2 performs a merge with any union data inside the Native, using the provided Native2
func (t *Native) MergeNative2(v Native2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNative3 returns the union data inside the Native as a Native3
func (t Native) AsNative3() (Native3, error) {
	var body Native3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNative3 overwrites any union data inside the Native as the provided Native3
func (t *Native) FromNative3(v Native3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNative3 performs a merge with any union data inside the Native, using the provided Native3
func (t *Native) MergeNative3(v Native3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNative4 returns the union data inside the Native as a Native4
func (t Native) AsNative4() (Native4, error) {
	var body Native4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNative4 overwrites any union data inside the Native as the provided Native4
func (t *Native) FromNative4(v Native4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNative4 performs a merge with any union data inside the Native, using the provided Native4
func (t *Native) MergeNative4(v Native4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Native) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Native) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNativeFormCreate0 returns the union data inside the NativeFormCreate as a NativeFormCreate0
func (t NativeFormCreate) AsNativeFormCreate0() (NativeFormCreate0, error) {
	var body NativeFormCreate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormCreate0 overwrites any union data inside the NativeFormCreate as the provided NativeFormCreate0
func (t *NativeFormCreate) FromNativeFormCreate0(v NativeFormCreate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormCreate0 performs a merge with any union data inside the NativeFormCreate, using the provided NativeFormCreate0
func (t *NativeFormCreate) MergeNativeFormCreate0(v NativeFormCreate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormCreate1 returns the union data inside the NativeFormCreate as a NativeFormCreate1
func (t NativeFormCreate) AsNativeFormCreate1() (NativeFormCreate1, error) {
	var body NativeFormCreate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormCreate1 overwrites any union data inside the NativeFormCreate as the provided NativeFormCreate1
func (t *NativeFormCreate) FromNativeFormCreate1(v NativeFormCreate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormCreate1 performs a merge with any union data inside the NativeFormCreate, using the provided NativeFormCreate1
func (t *NativeFormCreate) MergeNativeFormCreate1(v NativeFormCreate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormCreate2 returns the union data inside the NativeFormCreate as a NativeFormCreate2
func (t NativeFormCreate) AsNativeFormCreate2() (NativeFormCreate2, error) {
	var body NativeFormCreate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormCreate2 overwrites any union data inside the NativeFormCreate as the provided NativeFormCreate2
func (t *NativeFormCreate) FromNativeFormCreate2(v NativeFormCreate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormCreate2 performs a merge with any union data inside the NativeFormCreate, using the provided NativeFormCreate2
func (t *NativeFormCreate) MergeNativeFormCreate2(v NativeFormCreate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormCreate3 returns the union data inside the NativeFormCreate as a NativeFormCreate3
func (t NativeFormCreate) AsNativeFormCreate3() (NativeFormCreate3, error) {
	var body NativeFormCreate3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormCreate3 overwrites any union data inside the NativeFormCreate as the provided NativeFormCreate3
func (t *NativeFormCreate) FromNativeFormCreate3(v NativeFormCreate3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormCreate3 performs a merge with any union data inside the NativeFormCreate, using the provided NativeFormCreate3
func (t *NativeFormCreate) MergeNativeFormCreate3(v NativeFormCreate3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormCreate4 returns the union data inside the NativeFormCreate as a NativeFormCreate4
func (t NativeFormCreate) AsNativeFormCreate4() (NativeFormCreate4, error) {
	var body NativeFormCreate4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormCreate4 overwrites any union data inside the NativeFormCreate as the provided NativeFormCreate4
func (t *NativeFormCreate) FromNativeFormCreate4(v NativeFormCreate4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormCreate4 performs a merge with any union data inside the NativeFormCreate, using the provided NativeFormCreate4
func (t *NativeFormCreate) MergeNativeFormCreate4(v NativeFormCreate4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t NativeFormCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NativeFormCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNativeFormUpdate0 returns the union data inside the NativeFormUpdate as a NativeFormUpdate0
func (t NativeFormUpdate) AsNativeFormUpdate0() (NativeFormUpdate0, error) {
	var body NativeFormUpdate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormUpdate0 overwrites any union data inside the NativeFormUpdate as the provided NativeFormUpdate0
func (t *NativeFormUpdate) FromNativeFormUpdate0(v NativeFormUpdate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormUpdate0 performs a merge with any union data inside the NativeFormUpdate, using the provided NativeFormUpdate0
func (t *NativeFormUpdate) MergeNativeFormUpdate0(v NativeFormUpdate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormUpdate1 returns the union data inside the NativeFormUpdate as a NativeFormUpdate1
func (t NativeFormUpdate) AsNativeFormUpdate1() (NativeFormUpdate1, error) {
	var body NativeFormUpdate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormUpdate1 overwrites any union data inside the NativeFormUpdate as the provided NativeFormUpdate1
func (t *NativeFormUpdate) FromNativeFormUpdate1(v NativeFormUpdate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormUpdate1 performs a merge with any union data inside the NativeFormUpdate, using the provided NativeFormUpdate1
func (t *NativeFormUpdate) MergeNativeFormUpdate1(v NativeFormUpdate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormUpdate2 returns the union data inside the NativeFormUpdate as a NativeFormUpdate2
func (t NativeFormUpdate) AsNativeFormUpdate2() (NativeFormUpdate2, error) {
	var body NativeFormUpdate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormUpdate2 overwrites any union data inside the NativeFormUpdate as the provided NativeFormUpdate2
func (t *NativeFormUpdate) FromNativeFormUpdate2(v NativeFormUpdate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormUpdate2 performs a merge with any union data inside the NativeFormUpdate, using the provided NativeFormUpdate2
func (t *NativeFormUpdate) MergeNativeFormUpdate2(v NativeFormUpdate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormUpdate3 returns the union data inside the NativeFormUpdate as a NativeFormUpdate3
func (t NativeFormUpdate) AsNativeFormUpdate3() (NativeFormUpdate3, error) {
	var body NativeFormUpdate3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormUpdate3 overwrites any union data inside the NativeFormUpdate as the provided NativeFormUpdate3
func (t *NativeFormUpdate) FromNativeFormUpdate3(v NativeFormUpdate3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormUpdate3 performs a merge with any union data inside the NativeFormUpdate, using the provided NativeFormUpdate3
func (t *NativeFormUpdate) MergeNativeFormUpdate3(v NativeFormUpdate3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNativeFormUpdate4 returns the union data inside the NativeFormUpdate as a NativeFormUpdate4
func (t NativeFormUpdate) AsNativeFormUpdate4() (NativeFormUpdate4, error) {
	var body NativeFormUpdate4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNativeFormUpdate4 overwrites any union data inside the NativeFormUpdate as the provided NativeFormUpdate4
func (t *NativeFormUpdate) FromNativeFormUpdate4(v NativeFormUpdate4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNativeFormUpdate4 performs a merge with any union data inside the NativeFormUpdate, using the provided NativeFormUpdate4
func (t *NativeFormUpdate) MergeNativeFormUpdate4(v NativeFormUpdate4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t NativeFormUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NativeFormUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsServicesMetricProvider0 returns the union data inside the ServicesMetricProvider as a ServicesMetricProvider0
func (t ServicesMetricProvider) AsServicesMetricProvider0() (ServicesMetricProvider0, error) {
	var body ServicesMetricProvider0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesMetricProvider0 overwrites any union data inside the ServicesMetricProvider as the provided ServicesMetricProvider0
func (t *ServicesMetricProvider) FromServicesMetricProvider0(v ServicesMetricProvider0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesMetricProvider0 performs a merge with any union data inside the ServicesMetricProvider, using the provided ServicesMetricProvider0
func (t *ServicesMetricProvider) MergeServicesMetricProvider0(v ServicesMetricProvider0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesMetricProvider1 returns the union data inside the ServicesMetricProvider as a ServicesMetricProvider1
func (t ServicesMetricProvider) AsServicesMetricProvider1() (ServicesMetricProvider1, error) {
	var body ServicesMetricProvider1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesMetricProvider1 overwrites any union data inside the ServicesMetricProvider as the provided ServicesMetricProvider1
func (t *ServicesMetricProvider) FromServicesMetricProvider1(v ServicesMetricProvider1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesMetricProvider1 performs a merge with any union data inside the ServicesMetricProvider, using the provided ServicesMetricProvider1
func (t *ServicesMetricProvider) MergeServicesMetricProvider1(v ServicesMetricProvider1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesMetricProvider2 returns the union data inside the ServicesMetricProvider as a ServicesMetricProvider2
func (t ServicesMetricProvider) AsServicesMetricProvider2() (ServicesMetricProvider2, error) {
	var body ServicesMetricProvider2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesMetricProvider2 overwrites any union data inside the ServicesMetricProvider as the provided ServicesMetricProvider2
func (t *ServicesMetricProvider) FromServicesMetricProvider2(v ServicesMetricProvider2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesMetricProvider2 performs a merge with any union data inside the ServicesMetricProvider, using the provided ServicesMetricProvider2
func (t *ServicesMetricProvider) MergeServicesMetricProvider2(v ServicesMetricProvider2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesMetricProvider3 returns the union data inside the ServicesMetricProvider as a ServicesMetricProvider3
func (t ServicesMetricProvider) AsServicesMetricProvider3() (ServicesMetricProvider3, error) {
	var body ServicesMetricProvider3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesMetricProvider3 overwrites any union data inside the ServicesMetricProvider as the provided ServicesMetricProvider3
func (t *ServicesMetricProvider) FromServicesMetricProvider3(v ServicesMetricProvider3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesMetricProvider3 performs a merge with any union data inside the ServicesMetricProvider, using the provided ServicesMetricProvider3
func (t *ServicesMetricProvider) MergeServicesMetricProvider3(v ServicesMetricProvider3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesMetricProvider4 returns the union data inside the ServicesMetricProvider as a ServicesMetricProvider4
func (t ServicesMetricProvider) AsServicesMetricProvider4() (ServicesMetricProvider4, error) {
	var body ServicesMetricProvider4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesMetricProvider4 overwrites any union data inside the ServicesMetricProvider as the provided ServicesMetricProvider4
func (t *ServicesMetricProvider) FromServicesMetricProvider4(v ServicesMetricProvider4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesMetricProvider4 performs a merge with any union data inside the ServicesMetricProvider, using the provided ServicesMetricProvider4
func (t *ServicesMetricProvider) MergeServicesMetricProvider4(v ServicesMetricProvider4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesMetricProvider5 returns the union data inside the ServicesMetricProvider as a ServicesMetricProvider5
func (t ServicesMetricProvider) AsServicesMetricProvider5() (ServicesMetricProvider5, error) {
	var body ServicesMetricProvider5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesMetricProvider5 overwrites any union data inside the ServicesMetricProvider as the provided ServicesMetricProvider5
func (t *ServicesMetricProvider) FromServicesMetricProvider5(v ServicesMetricProvider5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesMetricProvider5 performs a merge with any union data inside the ServicesMetricProvider, using the provided ServicesMetricProvider5
func (t *ServicesMetricProvider) MergeServicesMetricProvider5(v ServicesMetricProvider5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesMetricProvider6 returns the union data inside the ServicesMetricProvider as a ServicesMetricProvider6
func (t ServicesMetricProvider) AsServicesMetricProvider6() (ServicesMetricProvider6, error) {
	var body ServicesMetricProvider6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesMetricProvider6 overwrites any union data inside the ServicesMetricProvider as the provided ServicesMetricProvider6
func (t *ServicesMetricProvider) FromServicesMetricProvider6(v ServicesMetricProvider6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesMetricProvider6 performs a merge with any union data inside the ServicesMetricProvider, using the provided ServicesMetricProvider6
func (t *ServicesMetricProvider) MergeServicesMetricProvider6(v ServicesMetricProvider6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ServicesMetricProvider) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ServicesMetricProvider) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsServicesWatchdog0 returns the union data inside the ServicesWatchdog as a ServicesWatchdog0
func (t ServicesWatchdog) AsServicesWatchdog0() (ServicesWatchdog0, error) {
	var body ServicesWatchdog0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog0 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog0
func (t *ServicesWatchdog) FromServicesWatchdog0(v ServicesWatchdog0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog0 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog0
func (t *ServicesWatchdog) MergeServicesWatchdog0(v ServicesWatchdog0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog1 returns the union data inside the ServicesWatchdog as a ServicesWatchdog1
func (t ServicesWatchdog) AsServicesWatchdog1() (ServicesWatchdog1, error) {
	var body ServicesWatchdog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog1 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog1
func (t *ServicesWatchdog) FromServicesWatchdog1(v ServicesWatchdog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog1 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog1
func (t *ServicesWatchdog) MergeServicesWatchdog1(v ServicesWatchdog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog2 returns the union data inside the ServicesWatchdog as a ServicesWatchdog2
func (t ServicesWatchdog) AsServicesWatchdog2() (ServicesWatchdog2, error) {
	var body ServicesWatchdog2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog2 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog2
func (t *ServicesWatchdog) FromServicesWatchdog2(v ServicesWatchdog2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog2 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog2
func (t *ServicesWatchdog) MergeServicesWatchdog2(v ServicesWatchdog2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog3 returns the union data inside the ServicesWatchdog as a ServicesWatchdog3
func (t ServicesWatchdog) AsServicesWatchdog3() (ServicesWatchdog3, error) {
	var body ServicesWatchdog3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog3 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog3
func (t *ServicesWatchdog) FromServicesWatchdog3(v ServicesWatchdog3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog3 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog3
func (t *ServicesWatchdog) MergeServicesWatchdog3(v ServicesWatchdog3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog4 returns the union data inside the ServicesWatchdog as a ServicesWatchdog4
func (t ServicesWatchdog) AsServicesWatchdog4() (ServicesWatchdog4, error) {
	var body ServicesWatchdog4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog4 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog4
func (t *ServicesWatchdog) FromServicesWatchdog4(v ServicesWatchdog4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog4 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog4
func (t *ServicesWatchdog) MergeServicesWatchdog4(v ServicesWatchdog4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog5 returns the union data inside the ServicesWatchdog as a ServicesWatchdog5
func (t ServicesWatchdog) AsServicesWatchdog5() (ServicesWatchdog5, error) {
	var body ServicesWatchdog5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog5 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog5
func (t *ServicesWatchdog) FromServicesWatchdog5(v ServicesWatchdog5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog5 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog5
func (t *ServicesWatchdog) MergeServicesWatchdog5(v ServicesWatchdog5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog6 returns the union data inside the ServicesWatchdog as a ServicesWatchdog6
func (t ServicesWatchdog) AsServicesWatchdog6() (ServicesWatchdog6, error) {
	var body ServicesWatchdog6
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog6 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog6
func (t *ServicesWatchdog) FromServicesWatchdog6(v ServicesWatchdog6) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog6 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog6
func (t *ServicesWatchdog) MergeServicesWatchdog6(v ServicesWatchdog6) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog7 returns the union data inside the ServicesWatchdog as a ServicesWatchdog7
func (t ServicesWatchdog) AsServicesWatchdog7() (ServicesWatchdog7, error) {
	var body ServicesWatchdog7
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog7 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog7
func (t *ServicesWatchdog) FromServicesWatchdog7(v ServicesWatchdog7) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog7 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog7
func (t *ServicesWatchdog) MergeServicesWatchdog7(v ServicesWatchdog7) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog8 returns the union data inside the ServicesWatchdog as a ServicesWatchdog8
func (t ServicesWatchdog) AsServicesWatchdog8() (ServicesWatchdog8, error) {
	var body ServicesWatchdog8
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog8 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog8
func (t *ServicesWatchdog) FromServicesWatchdog8(v ServicesWatchdog8) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog8 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog8
func (t *ServicesWatchdog) MergeServicesWatchdog8(v ServicesWatchdog8) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicesWatchdog9 returns the union data inside the ServicesWatchdog as a ServicesWatchdog9
func (t ServicesWatchdog) AsServicesWatchdog9() (ServicesWatchdog9, error) {
	var body ServicesWatchdog9
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicesWatchdog9 overwrites any union data inside the ServicesWatchdog as the provided ServicesWatchdog9
func (t *ServicesWatchdog) FromServicesWatchdog9(v ServicesWatchdog9) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicesWatchdog9 performs a merge with any union data inside the ServicesWatchdog, using the provided ServicesWatchdog9
func (t *ServicesWatchdog) MergeServicesWatchdog9(v ServicesWatchdog9) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ServicesWatchdog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ServicesWatchdog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateExpansionaryIssue0 returns the union data inside the UpdateExpansionary_Issue as a UpdateExpansionaryIssue0
func (t UpdateExpansionary_Issue) AsUpdateExpansionaryIssue0() (UpdateExpansionaryIssue0, error) {
	var body UpdateExpansionaryIssue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateExpansionaryIssue0 overwrites any union data inside the UpdateExpansionary_Issue as the provided UpdateExpansionaryIssue0
func (t *UpdateExpansionary_Issue) FromUpdateExpansionaryIssue0(v UpdateExpansionaryIssue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateExpansionaryIssue0 performs a merge with any union data inside the UpdateExpansionary_Issue, using the provided UpdateExpansionaryIssue0
func (t *UpdateExpansionary_Issue) MergeUpdateExpansionaryIssue0(v UpdateExpansionaryIssue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateExpansionaryIssue1 returns the union data inside the UpdateExpansionary_Issue as a UpdateExpansionaryIssue1
func (t UpdateExpansionary_Issue) AsUpdateExpansionaryIssue1() (UpdateExpansionaryIssue1, error) {
	var body UpdateExpansionaryIssue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateExpansionaryIssue1 overwrites any union data inside the UpdateExpansionary_Issue as the provided UpdateExpansionaryIssue1
func (t *UpdateExpansionary_Issue) FromUpdateExpansionaryIssue1(v UpdateExpansionaryIssue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateExpansionaryIssue1 performs a merge with any union data inside the UpdateExpansionary_Issue, using the provided UpdateExpansionaryIssue1
func (t *UpdateExpansionary_Issue) MergeUpdateExpansionaryIssue1(v UpdateExpansionaryIssue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateExpansionary_Issue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateExpansionary_Issue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateFormCreateTemplate0 returns the union data inside the UpdateFormCreate_Template as a UpdateFormCreateTemplate0
func (t UpdateFormCreate_Template) AsUpdateFormCreateTemplate0() (UpdateFormCreateTemplate0, error) {
	var body UpdateFormCreateTemplate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateFormCreateTemplate0 overwrites any union data inside the UpdateFormCreate_Template as the provided UpdateFormCreateTemplate0
func (t *UpdateFormCreate_Template) FromUpdateFormCreateTemplate0(v UpdateFormCreateTemplate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateFormCreateTemplate0 performs a merge with any union data inside the UpdateFormCreate_Template, using the provided UpdateFormCreateTemplate0
func (t *UpdateFormCreate_Template) MergeUpdateFormCreateTemplate0(v UpdateFormCreateTemplate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateFormCreateTemplate1 returns the union data inside the UpdateFormCreate_Template as a UpdateFormCreateTemplate1
func (t UpdateFormCreate_Template) AsUpdateFormCreateTemplate1() (UpdateFormCreateTemplate1, error) {
	var body UpdateFormCreateTemplate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateFormCreateTemplate1 overwrites any union data inside the UpdateFormCreate_Template as the provided UpdateFormCreateTemplate1
func (t *UpdateFormCreate_Template) FromUpdateFormCreateTemplate1(v UpdateFormCreateTemplate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateFormCreateTemplate1 performs a merge with any union data inside the UpdateFormCreate_Template, using the provided UpdateFormCreateTemplate1
func (t *UpdateFormCreate_Template) MergeUpdateFormCreateTemplate1(v UpdateFormCreateTemplate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateFormCreate_Template) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateFormCreate_Template) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateFormUpdateTemplate0 returns the union data inside the UpdateFormUpdate_Template as a UpdateFormUpdateTemplate0
func (t UpdateFormUpdate_Template) AsUpdateFormUpdateTemplate0() (UpdateFormUpdateTemplate0, error) {
	var body UpdateFormUpdateTemplate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateFormUpdateTemplate0 overwrites any union data inside the UpdateFormUpdate_Template as the provided UpdateFormUpdateTemplate0
func (t *UpdateFormUpdate_Template) FromUpdateFormUpdateTemplate0(v UpdateFormUpdateTemplate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateFormUpdateTemplate0 performs a merge with any union data inside the UpdateFormUpdate_Template, using the provided UpdateFormUpdateTemplate0
func (t *UpdateFormUpdate_Template) MergeUpdateFormUpdateTemplate0(v UpdateFormUpdateTemplate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateFormUpdateTemplate1 returns the union data inside the UpdateFormUpdate_Template as a UpdateFormUpdateTemplate1
func (t UpdateFormUpdate_Template) AsUpdateFormUpdateTemplate1() (UpdateFormUpdateTemplate1, error) {
	var body UpdateFormUpdateTemplate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateFormUpdateTemplate1 overwrites any union data inside the UpdateFormUpdate_Template as the provided UpdateFormUpdateTemplate1
func (t *UpdateFormUpdate_Template) FromUpdateFormUpdateTemplate1(v UpdateFormUpdateTemplate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateFormUpdateTemplate1 performs a merge with any union data inside the UpdateFormUpdate_Template, using the provided UpdateFormUpdateTemplate1
func (t *UpdateFormUpdate_Template) MergeUpdateFormUpdateTemplate1(v UpdateFormUpdateTemplate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateFormUpdateTemplate2 returns the union data inside the UpdateFormUpdate_Template as a UpdateFormUpdateTemplate2
func (t UpdateFormUpdate_Template) AsUpdateFormUpdateTemplate2() (UpdateFormUpdateTemplate2, error) {
	var body UpdateFormUpdateTemplate2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateFormUpdateTemplate2 overwrites any union data inside the UpdateFormUpdate_Template as the provided UpdateFormUpdateTemplate2
func (t *UpdateFormUpdate_Template) FromUpdateFormUpdateTemplate2(v UpdateFormUpdateTemplate2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateFormUpdateTemplate2 performs a merge with any union data inside the UpdateFormUpdate_Template, using the provided UpdateFormUpdateTemplate2
func (t *UpdateFormUpdate_Template) MergeUpdateFormUpdateTemplate2(v UpdateFormUpdateTemplate2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateFormUpdate_Template) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateFormUpdate_Template) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsI18nString0 returns the union data inside the I18nString as a I18nString0
func (t I18nString) AsI18nString0() (I18nString0, error) {
	var body I18nString0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromI18nString0 overwrites any union data inside the I18nString as the provided I18nString0
func (t *I18nString) FromI18nString0(v I18nString0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeI18nString0 performs a merge with any union data inside the I18nString, using the provided I18nString0
func (t *I18nString) MergeI18nString0(v I18nString0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsI18nString1 returns the union data inside the I18nString as a I18nString1
func (t I18nString) AsI18nString1() (I18nString1, error) {
	var body I18nString1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromI18nString1 overwrites any union data inside the I18nString as the provided I18nString1
func (t *I18nString) FromI18nString1(v I18nString1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeI18nString1 performs a merge with any union data inside the I18nString, using the provided I18nString1
func (t *I18nString) MergeI18nString1(v I18nString1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t I18nString) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *I18nString) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllComponents request
	GetAllComponents(ctx context.Context, params *GetAllComponentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAComponentWithBody request with any body
	CreateAComponentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAComponent(ctx context.Context, body CreateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAComponent request
	DeleteAComponent(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAComponent request
	RetrieveAComponent(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAComponentWithBody request with any body
	UpdateAComponentWithBody(ctx context.Context, componentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAComponent(ctx context.Context, componentId string, body UpdateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllGroups request
	GetAllGroups(ctx context.Context, params *GetAllGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAGroupWithBody request with any body
	CreateAGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAGroup(ctx context.Context, body CreateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAGroup request
	DeleteAGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAGroup request
	RetrieveAGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAGroupWithBody request with any body
	UpdateAGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAGroup(ctx context.Context, groupId string, body UpdateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReorderAGroupsComponentsWithBody request with any body
	ReorderAGroupsComponentsWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReorderAGroupsComponents(ctx context.Context, groupId string, body ReorderAGroupsComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllIssueTemplates request
	GetAllIssueTemplates(ctx context.Context, params *GetAllIssueTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAIssueTemplateWithBody request with any body
	CreateAIssueTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAIssueTemplate(ctx context.Context, body CreateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAIssueTemplate request
	DeleteAIssueTemplate(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAIssueTemplate request
	RetrieveAIssueTemplate(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAIssueTemplateWithBody request with any body
	UpdateAIssueTemplateWithBody(ctx context.Context, issueTemplateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAIssueTemplate(ctx context.Context, issueTemplateId string, body UpdateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllIssues request
	GetAllIssues(ctx context.Context, params *GetAllIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAIssueWithBody request with any body
	CreateAIssueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAIssue(ctx context.Context, body CreateAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewAIssueWithBody request with any body
	PreviewAIssueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewAIssue(ctx context.Context, body PreviewAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAIssue request
	DeleteAIssue(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAIssue request
	RetrieveAIssue(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReviseAnIssueWithBody request with any body
	ReviseAnIssueWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReviseAnIssue(ctx context.Context, issueId string, body ReviseAnIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelAScheduledIssueWithBody request with any body
	CancelAScheduledIssueWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CancelAScheduledIssue(ctx context.Context, issueId string, body CancelAScheduledIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllUpdates request
	GetAllUpdates(ctx context.Context, issueId string, params *GetAllUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAUpdateWithBody request with any body
	CreateAUpdateWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAUpdate(ctx context.Context, issueId string, body CreateAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PreviewAUpdateWithBody request with any body
	PreviewAUpdateWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PreviewAUpdate(ctx context.Context, issueId string, body PreviewAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAUpdate request
	DeleteAUpdate(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAUpdate request
	RetrieveAUpdate(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReviseAnUpdateWithBody request with any body
	ReviseAnUpdateWithBody(ctx context.Context, issueId string, updateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReviseAnUpdate(ctx context.Context, issueId string, updateId string, body ReviseAnUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllMetricProviders request
	GetAllMetricProviders(ctx context.Context, params *GetAllMetricProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAMetricProviderWithBody request with any body
	CreateAMetricProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAMetricProvider(ctx context.Context, body CreateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAMetricProvider request
	DeleteAMetricProvider(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAMetricProvider request
	RetrieveAMetricProvider(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAMetricProviderWithBody request with any body
	UpdateAMetricProviderWithBody(ctx context.Context, metricProviderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAMetricProvider(ctx context.Context, metricProviderId string, body UpdateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RetrieveAWatchdog request
	RetrieveAWatchdog(ctx context.Context, watchdogId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAWatchdogWithBody request with any body
	UpdateAWatchdogWithBody(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAWatchdog(ctx context.Context, watchdogId string, body UpdateAWatchdogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertAWatchdogsServiceTypeWithBody request with any body
	ConvertAWatchdogsServiceTypeWithBody(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ConvertAWatchdogsServiceType(ctx context.Context, watchdogId string, body ConvertAWatchdogsServiceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllComponents(ctx context.Context, params *GetAllComponentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllComponentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAComponentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAComponentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAComponent(ctx context.Context, body CreateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAComponentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAComponent(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAComponentRequest(c.Server, componentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAComponent(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAComponentRequest(c.Server, componentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAComponentWithBody(ctx context.Context, componentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAComponentRequestWithBody(c.Server, componentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAComponent(ctx context.Context, componentId string, body UpdateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAComponentRequest(c.Server, componentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllGroups(ctx context.Context, params *GetAllGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAGroup(ctx context.Context, body CreateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAGroup(ctx context.Context, groupId string, body UpdateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReorderAGroupsComponentsWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReorderAGroupsComponentsRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReorderAGroupsComponents(ctx context.Context, groupId string, body ReorderAGroupsComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReorderAGroupsComponentsRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllIssueTemplates(ctx context.Context, params *GetAllIssueTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllIssueTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAIssueTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAIssueTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAIssueTemplate(ctx context.Context, body CreateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAIssueTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAIssueTemplate(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAIssueTemplateRequest(c.Server, issueTemplateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAIssueTemplate(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAIssueTemplateRequest(c.Server, issueTemplateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAIssueTemplateWithBody(ctx context.Context, issueTemplateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAIssueTemplateRequestWithBody(c.Server, issueTemplateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAIssueTemplate(ctx context.Context, issueTemplateId string, body UpdateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAIssueTemplateRequest(c.Server, issueTemplateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllIssues(ctx context.Context, params *GetAllIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllIssuesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAIssueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAIssueRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAIssue(ctx context.Context, body CreateAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAIssueRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewAIssueWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewAIssueRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewAIssue(ctx context.Context, body PreviewAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewAIssueRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAIssue(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAIssueRequest(c.Server, issueId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAIssue(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAIssueRequest(c.Server, issueId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviseAnIssueWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviseAnIssueRequestWithBody(c.Server, issueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviseAnIssue(ctx context.Context, issueId string, body ReviseAnIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviseAnIssueRequest(c.Server, issueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelAScheduledIssueWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelAScheduledIssueRequestWithBody(c.Server, issueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelAScheduledIssue(ctx context.Context, issueId string, body CancelAScheduledIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelAScheduledIssueRequest(c.Server, issueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllUpdates(ctx context.Context, issueId string, params *GetAllUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllUpdatesRequest(c.Server, issueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAUpdateWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAUpdateRequestWithBody(c.Server, issueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAUpdate(ctx context.Context, issueId string, body CreateAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAUpdateRequest(c.Server, issueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewAUpdateWithBody(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewAUpdateRequestWithBody(c.Server, issueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PreviewAUpdate(ctx context.Context, issueId string, body PreviewAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPreviewAUpdateRequest(c.Server, issueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAUpdate(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAUpdateRequest(c.Server, issueId, updateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAUpdate(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAUpdateRequest(c.Server, issueId, updateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviseAnUpdateWithBody(ctx context.Context, issueId string, updateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviseAnUpdateRequestWithBody(c.Server, issueId, updateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReviseAnUpdate(ctx context.Context, issueId string, updateId string, body ReviseAnUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReviseAnUpdateRequest(c.Server, issueId, updateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllMetricProviders(ctx context.Context, params *GetAllMetricProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllMetricProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAMetricProviderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAMetricProviderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAMetricProvider(ctx context.Context, body CreateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAMetricProviderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAMetricProvider(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAMetricProviderRequest(c.Server, metricProviderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAMetricProvider(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAMetricProviderRequest(c.Server, metricProviderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAMetricProviderWithBody(ctx context.Context, metricProviderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAMetricProviderRequestWithBody(c.Server, metricProviderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAMetricProvider(ctx context.Context, metricProviderId string, body UpdateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAMetricProviderRequest(c.Server, metricProviderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RetrieveAWatchdog(ctx context.Context, watchdogId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRetrieveAWatchdogRequest(c.Server, watchdogId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAWatchdogWithBody(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAWatchdogRequestWithBody(c.Server, watchdogId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAWatchdog(ctx context.Context, watchdogId string, body UpdateAWatchdogJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAWatchdogRequest(c.Server, watchdogId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertAWatchdogsServiceTypeWithBody(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertAWatchdogsServiceTypeRequestWithBody(c.Server, watchdogId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertAWatchdogsServiceType(ctx context.Context, watchdogId string, body ConvertAWatchdogsServiceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertAWatchdogsServiceTypeRequest(c.Server, watchdogId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllComponentsRequest generates requests for GetAllComponents
func NewGetAllComponentsRequest(server string, params *GetAllComponentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/components")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Issue != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issue", runtime.ParamLocationQuery, *params.Issue); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Event != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimelineItem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timeline_item", runtime.ParamLocationQuery, *params.TimelineItem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAComponentRequest calls the generic CreateAComponent builder with application/json body
func NewCreateAComponentRequest(server string, body CreateAComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAComponentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAComponentRequestWithBody generates requests for CreateAComponent with any type of body
func NewCreateAComponentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/components")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAComponentRequest generates requests for DeleteAComponent
func NewDeleteAComponentRequest(server string, componentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "component_id", runtime.ParamLocationPath, componentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAComponentRequest generates requests for RetrieveAComponent
func NewRetrieveAComponentRequest(server string, componentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "component_id", runtime.ParamLocationPath, componentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAComponentRequest calls the generic UpdateAComponent builder with application/json body
func NewUpdateAComponentRequest(server string, componentId string, body UpdateAComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAComponentRequestWithBody(server, componentId, "application/json", bodyReader)
}

// NewUpdateAComponentRequestWithBody generates requests for UpdateAComponent with any type of body
func NewUpdateAComponentRequestWithBody(server string, componentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "component_id", runtime.ParamLocationPath, componentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/components/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllGroupsRequest generates requests for GetAllGroups
func NewGetAllGroupsRequest(server string, params *GetAllGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAGroupRequest calls the generic CreateAGroup builder with application/json body
func NewCreateAGroupRequest(server string, body CreateAGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAGroupRequestWithBody generates requests for CreateAGroup with any type of body
func NewCreateAGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAGroupRequest generates requests for DeleteAGroup
func NewDeleteAGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAGroupRequest generates requests for RetrieveAGroup
func NewRetrieveAGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAGroupRequest calls the generic UpdateAGroup builder with application/json body
func NewUpdateAGroupRequest(server string, groupId string, body UpdateAGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewUpdateAGroupRequestWithBody generates requests for UpdateAGroup with any type of body
func NewUpdateAGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReorderAGroupsComponentsRequest calls the generic ReorderAGroupsComponents builder with application/json body
func NewReorderAGroupsComponentsRequest(server string, groupId string, body ReorderAGroupsComponentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReorderAGroupsComponentsRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewReorderAGroupsComponentsRequestWithBody generates requests for ReorderAGroupsComponents with any type of body
func NewReorderAGroupsComponentsRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/reorder", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllIssueTemplatesRequest generates requests for GetAllIssueTemplates
func NewGetAllIssueTemplatesRequest(server string, params *GetAllIssueTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAIssueTemplateRequest calls the generic CreateAIssueTemplate builder with application/json body
func NewCreateAIssueTemplateRequest(server string, body CreateAIssueTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAIssueTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAIssueTemplateRequestWithBody generates requests for CreateAIssueTemplate with any type of body
func NewCreateAIssueTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAIssueTemplateRequest generates requests for DeleteAIssueTemplate
func NewDeleteAIssueTemplateRequest(server string, issueTemplateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_template_id", runtime.ParamLocationPath, issueTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAIssueTemplateRequest generates requests for RetrieveAIssueTemplate
func NewRetrieveAIssueTemplateRequest(server string, issueTemplateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_template_id", runtime.ParamLocationPath, issueTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAIssueTemplateRequest calls the generic UpdateAIssueTemplate builder with application/json body
func NewUpdateAIssueTemplateRequest(server string, issueTemplateId string, body UpdateAIssueTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAIssueTemplateRequestWithBody(server, issueTemplateId, "application/json", bodyReader)
}

// NewUpdateAIssueTemplateRequestWithBody generates requests for UpdateAIssueTemplate with any type of body
func NewUpdateAIssueTemplateRequestWithBody(server string, issueTemplateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_template_id", runtime.ParamLocationPath, issueTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllIssuesRequest generates requests for GetAllIssues
func NewGetAllIssuesRequest(server string, params *GetAllIssuesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Components != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "components[]", runtime.ParamLocationQuery, *params.Components); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Component != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "component", runtime.ParamLocationQuery, *params.Component); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Standing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "standing", runtime.ParamLocationQuery, *params.Standing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Upcoming != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "upcoming", runtime.ParamLocationQuery, *params.Upcoming); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Resolved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolved", runtime.ParamLocationQuery, *params.Resolved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAIssueRequest calls the generic CreateAIssue builder with application/json body
func NewCreateAIssueRequest(server string, body CreateAIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAIssueRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAIssueRequestWithBody generates requests for CreateAIssue with any type of body
func NewCreateAIssueRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewAIssueRequest calls the generic PreviewAIssue builder with application/json body
func NewPreviewAIssueRequest(server string, body PreviewAIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewAIssueRequestWithBody(server, "application/json", bodyReader)
}

// NewPreviewAIssueRequestWithBody generates requests for PreviewAIssue with any type of body
func NewPreviewAIssueRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/preview")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAIssueRequest generates requests for DeleteAIssue
func NewDeleteAIssueRequest(server string, issueId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAIssueRequest generates requests for RetrieveAIssue
func NewRetrieveAIssueRequest(server string, issueId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReviseAnIssueRequest calls the generic ReviseAnIssue builder with application/json body
func NewReviseAnIssueRequest(server string, issueId string, body ReviseAnIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReviseAnIssueRequestWithBody(server, issueId, "application/json", bodyReader)
}

// NewReviseAnIssueRequestWithBody generates requests for ReviseAnIssue with any type of body
func NewReviseAnIssueRequestWithBody(server string, issueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelAScheduledIssueRequest calls the generic CancelAScheduledIssue builder with application/json body
func NewCancelAScheduledIssueRequest(server string, issueId string, body CancelAScheduledIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCancelAScheduledIssueRequestWithBody(server, issueId, "application/json", bodyReader)
}

// NewCancelAScheduledIssueRequestWithBody generates requests for CancelAScheduledIssue with any type of body
func NewCancelAScheduledIssueRequestWithBody(server string, issueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/cancel", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllUpdatesRequest generates requests for GetAllUpdates
func NewGetAllUpdatesRequest(server string, issueId string, params *GetAllUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/updates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAUpdateRequest calls the generic CreateAUpdate builder with application/json body
func NewCreateAUpdateRequest(server string, issueId string, body CreateAUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAUpdateRequestWithBody(server, issueId, "application/json", bodyReader)
}

// NewCreateAUpdateRequestWithBody generates requests for CreateAUpdate with any type of body
func NewCreateAUpdateRequestWithBody(server string, issueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/updates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPreviewAUpdateRequest calls the generic PreviewAUpdate builder with application/json body
func NewPreviewAUpdateRequest(server string, issueId string, body PreviewAUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPreviewAUpdateRequestWithBody(server, issueId, "application/json", bodyReader)
}

// NewPreviewAUpdateRequestWithBody generates requests for PreviewAUpdate with any type of body
func NewPreviewAUpdateRequestWithBody(server string, issueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/updates/preview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAUpdateRequest generates requests for DeleteAUpdate
func NewDeleteAUpdateRequest(server string, issueId string, updateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "update_id", runtime.ParamLocationPath, updateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/updates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAUpdateRequest generates requests for RetrieveAUpdate
func NewRetrieveAUpdateRequest(server string, issueId string, updateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "update_id", runtime.ParamLocationPath, updateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/updates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReviseAnUpdateRequest calls the generic ReviseAnUpdate builder with application/json body
func NewReviseAnUpdateRequest(server string, issueId string, updateId string, body ReviseAnUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReviseAnUpdateRequestWithBody(server, issueId, updateId, "application/json", bodyReader)
}

// NewReviseAnUpdateRequestWithBody generates requests for ReviseAnUpdate with any type of body
func NewReviseAnUpdateRequestWithBody(server string, issueId string, updateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "update_id", runtime.ParamLocationPath, updateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/updates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllMetricProvidersRequest generates requests for GetAllMetricProviders
func NewGetAllMetricProvidersRequest(server string, params *GetAllMetricProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric_providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Watchdog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watchdog", runtime.ParamLocationQuery, *params.Watchdog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Default != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "default", runtime.ParamLocationQuery, *params.Default); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAMetricProviderRequest calls the generic CreateAMetricProvider builder with application/json body
func NewCreateAMetricProviderRequest(server string, body CreateAMetricProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAMetricProviderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAMetricProviderRequestWithBody generates requests for CreateAMetricProvider with any type of body
func NewCreateAMetricProviderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric_providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAMetricProviderRequest generates requests for DeleteAMetricProvider
func NewDeleteAMetricProviderRequest(server string, metricProviderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metric_provider_id", runtime.ParamLocationPath, metricProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric_providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRetrieveAMetricProviderRequest generates requests for RetrieveAMetricProvider
func NewRetrieveAMetricProviderRequest(server string, metricProviderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metric_provider_id", runtime.ParamLocationPath, metricProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric_providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAMetricProviderRequest calls the generic UpdateAMetricProvider builder with application/json body
func NewUpdateAMetricProviderRequest(server string, metricProviderId string, body UpdateAMetricProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAMetricProviderRequestWithBody(server, metricProviderId, "application/json", bodyReader)
}

// NewUpdateAMetricProviderRequestWithBody generates requests for UpdateAMetricProvider with any type of body
func NewUpdateAMetricProviderRequestWithBody(server string, metricProviderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metric_provider_id", runtime.ParamLocationPath, metricProviderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metric_providers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRetrieveAWatchdogRequest generates requests for RetrieveAWatchdog
func NewRetrieveAWatchdogRequest(server string, watchdogId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "watchdog_id", runtime.ParamLocationPath, watchdogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watchdogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAWatchdogRequest calls the generic UpdateAWatchdog builder with application/json body
func NewUpdateAWatchdogRequest(server string, watchdogId string, body UpdateAWatchdogJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAWatchdogRequestWithBody(server, watchdogId, "application/json", bodyReader)
}

// NewUpdateAWatchdogRequestWithBody generates requests for UpdateAWatchdog with any type of body
func NewUpdateAWatchdogRequestWithBody(server string, watchdogId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "watchdog_id", runtime.ParamLocationPath, watchdogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watchdogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewConvertAWatchdogsServiceTypeRequest calls the generic ConvertAWatchdogsServiceType builder with application/json body
func NewConvertAWatchdogsServiceTypeRequest(server string, watchdogId string, body ConvertAWatchdogsServiceTypeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewConvertAWatchdogsServiceTypeRequestWithBody(server, watchdogId, "application/json", bodyReader)
}

// NewConvertAWatchdogsServiceTypeRequestWithBody generates requests for ConvertAWatchdogsServiceType with any type of body
func NewConvertAWatchdogsServiceTypeRequestWithBody(server string, watchdogId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "watchdog_id", runtime.ParamLocationPath, watchdogId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watchdogs/%s/convert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllComponentsWithResponse request
	GetAllComponentsWithResponse(ctx context.Context, params *GetAllComponentsParams, reqEditors ...RequestEditorFn) (*GetAllComponentsResponse, error)

	// CreateAComponentWithBodyWithResponse request with any body
	CreateAComponentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAComponentResponse, error)

	CreateAComponentWithResponse(ctx context.Context, body CreateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAComponentResponse, error)

	// DeleteAComponentWithResponse request
	DeleteAComponentWithResponse(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*DeleteAComponentResponse, error)

	// RetrieveAComponentWithResponse request
	RetrieveAComponentWithResponse(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*RetrieveAComponentResponse, error)

	// UpdateAComponentWithBodyWithResponse request with any body
	UpdateAComponentWithBodyWithResponse(ctx context.Context, componentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAComponentResponse, error)

	UpdateAComponentWithResponse(ctx context.Context, componentId string, body UpdateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAComponentResponse, error)

	// GetAllGroupsWithResponse request
	GetAllGroupsWithResponse(ctx context.Context, params *GetAllGroupsParams, reqEditors ...RequestEditorFn) (*GetAllGroupsResponse, error)

	// CreateAGroupWithBodyWithResponse request with any body
	CreateAGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAGroupResponse, error)

	CreateAGroupWithResponse(ctx context.Context, body CreateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAGroupResponse, error)

	// DeleteAGroupWithResponse request
	DeleteAGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteAGroupResponse, error)

	// RetrieveAGroupWithResponse request
	RetrieveAGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*RetrieveAGroupResponse, error)

	// UpdateAGroupWithBodyWithResponse request with any body
	UpdateAGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAGroupResponse, error)

	UpdateAGroupWithResponse(ctx context.Context, groupId string, body UpdateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAGroupResponse, error)

	// ReorderAGroupsComponentsWithBodyWithResponse request with any body
	ReorderAGroupsComponentsWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReorderAGroupsComponentsResponse, error)

	ReorderAGroupsComponentsWithResponse(ctx context.Context, groupId string, body ReorderAGroupsComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReorderAGroupsComponentsResponse, error)

	// GetAllIssueTemplatesWithResponse request
	GetAllIssueTemplatesWithResponse(ctx context.Context, params *GetAllIssueTemplatesParams, reqEditors ...RequestEditorFn) (*GetAllIssueTemplatesResponse, error)

	// CreateAIssueTemplateWithBodyWithResponse request with any body
	CreateAIssueTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAIssueTemplateResponse, error)

	CreateAIssueTemplateWithResponse(ctx context.Context, body CreateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAIssueTemplateResponse, error)

	// DeleteAIssueTemplateWithResponse request
	DeleteAIssueTemplateWithResponse(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*DeleteAIssueTemplateResponse, error)

	// RetrieveAIssueTemplateWithResponse request
	RetrieveAIssueTemplateWithResponse(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*RetrieveAIssueTemplateResponse, error)

	// UpdateAIssueTemplateWithBodyWithResponse request with any body
	UpdateAIssueTemplateWithBodyWithResponse(ctx context.Context, issueTemplateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAIssueTemplateResponse, error)

	UpdateAIssueTemplateWithResponse(ctx context.Context, issueTemplateId string, body UpdateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAIssueTemplateResponse, error)

	// GetAllIssuesWithResponse request
	GetAllIssuesWithResponse(ctx context.Context, params *GetAllIssuesParams, reqEditors ...RequestEditorFn) (*GetAllIssuesResponse, error)

	// CreateAIssueWithBodyWithResponse request with any body
	CreateAIssueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAIssueResponse, error)

	CreateAIssueWithResponse(ctx context.Context, body CreateAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAIssueResponse, error)

	// PreviewAIssueWithBodyWithResponse request with any body
	PreviewAIssueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewAIssueResponse, error)

	PreviewAIssueWithResponse(ctx context.Context, body PreviewAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewAIssueResponse, error)

	// DeleteAIssueWithResponse request
	DeleteAIssueWithResponse(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*DeleteAIssueResponse, error)

	// RetrieveAIssueWithResponse request
	RetrieveAIssueWithResponse(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*RetrieveAIssueResponse, error)

	// ReviseAnIssueWithBodyWithResponse request with any body
	ReviseAnIssueWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReviseAnIssueResponse, error)

	ReviseAnIssueWithResponse(ctx context.Context, issueId string, body ReviseAnIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*ReviseAnIssueResponse, error)

	// CancelAScheduledIssueWithBodyWithResponse request with any body
	CancelAScheduledIssueWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelAScheduledIssueResponse, error)

	CancelAScheduledIssueWithResponse(ctx context.Context, issueId string, body CancelAScheduledIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelAScheduledIssueResponse, error)

	// GetAllUpdatesWithResponse request
	GetAllUpdatesWithResponse(ctx context.Context, issueId string, params *GetAllUpdatesParams, reqEditors ...RequestEditorFn) (*GetAllUpdatesResponse, error)

	// CreateAUpdateWithBodyWithResponse request with any body
	CreateAUpdateWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAUpdateResponse, error)

	CreateAUpdateWithResponse(ctx context.Context, issueId string, body CreateAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAUpdateResponse, error)

	// PreviewAUpdateWithBodyWithResponse request with any body
	PreviewAUpdateWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewAUpdateResponse, error)

	PreviewAUpdateWithResponse(ctx context.Context, issueId string, body PreviewAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewAUpdateResponse, error)

	// DeleteAUpdateWithResponse request
	DeleteAUpdateWithResponse(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*DeleteAUpdateResponse, error)

	// RetrieveAUpdateWithResponse request
	RetrieveAUpdateWithResponse(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*RetrieveAUpdateResponse, error)

	// ReviseAnUpdateWithBodyWithResponse request with any body
	ReviseAnUpdateWithBodyWithResponse(ctx context.Context, issueId string, updateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReviseAnUpdateResponse, error)

	ReviseAnUpdateWithResponse(ctx context.Context, issueId string, updateId string, body ReviseAnUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReviseAnUpdateResponse, error)

	// GetAllMetricProvidersWithResponse request
	GetAllMetricProvidersWithResponse(ctx context.Context, params *GetAllMetricProvidersParams, reqEditors ...RequestEditorFn) (*GetAllMetricProvidersResponse, error)

	// CreateAMetricProviderWithBodyWithResponse request with any body
	CreateAMetricProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAMetricProviderResponse, error)

	CreateAMetricProviderWithResponse(ctx context.Context, body CreateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAMetricProviderResponse, error)

	// DeleteAMetricProviderWithResponse request
	DeleteAMetricProviderWithResponse(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*DeleteAMetricProviderResponse, error)

	// RetrieveAMetricProviderWithResponse request
	RetrieveAMetricProviderWithResponse(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*RetrieveAMetricProviderResponse, error)

	// UpdateAMetricProviderWithBodyWithResponse request with any body
	UpdateAMetricProviderWithBodyWithResponse(ctx context.Context, metricProviderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAMetricProviderResponse, error)

	UpdateAMetricProviderWithResponse(ctx context.Context, metricProviderId string, body UpdateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAMetricProviderResponse, error)

	// RetrieveAWatchdogWithResponse request
	RetrieveAWatchdogWithResponse(ctx context.Context, watchdogId string, reqEditors ...RequestEditorFn) (*RetrieveAWatchdogResponse, error)

	// UpdateAWatchdogWithBodyWithResponse request with any body
	UpdateAWatchdogWithBodyWithResponse(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAWatchdogResponse, error)

	UpdateAWatchdogWithResponse(ctx context.Context, watchdogId string, body UpdateAWatchdogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAWatchdogResponse, error)

	// ConvertAWatchdogsServiceTypeWithBodyWithResponse request with any body
	ConvertAWatchdogsServiceTypeWithBodyWithResponse(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertAWatchdogsServiceTypeResponse, error)

	ConvertAWatchdogsServiceTypeWithResponse(ctx context.Context, watchdogId string, body ConvertAWatchdogsServiceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertAWatchdogsServiceTypeResponse, error)
}

type GetAllComponentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *ComponentExpansionaryPagedArray
}

// Status returns HTTPResponse.Status
func (r GetAllComponentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllComponentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON201   *ComponentExpansionary
	HALJSON400   *Error
	HALJSON403   *Error
}

// Status returns HTTPResponse.Status
func (r CreateAComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *ComponentExpansionary
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r RetrieveAComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *ComponentExpansionary
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *GroupPagedArray
}

// Status returns HTTPResponse.Status
func (r GetAllGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON201   *Group
	HALJSON400   *Error
	HALJSON403   *Error
}

// Status returns HTTPResponse.Status
func (r CreateAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Group
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r RetrieveAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Group
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReorderAGroupsComponentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Group
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r ReorderAGroupsComponentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReorderAGroupsComponentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllIssueTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *IssueTemplatePagedArray
	HALJSON403   *Error
}

// Status returns HTTPResponse.Status
func (r GetAllIssueTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllIssueTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAIssueTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON201   *IssueTemplate
	HALJSON400   *Error
	HALJSON403   *Error
}

// Status returns HTTPResponse.Status
func (r CreateAIssueTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAIssueTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAIssueTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAIssueTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAIssueTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAIssueTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *IssueTemplate
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r RetrieveAIssueTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAIssueTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAIssueTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *IssueTemplate
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAIssueTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAIssueTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllIssuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *IssuePagedArray
}

// Status returns HTTPResponse.Status
func (r GetAllIssuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllIssuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON201   *Issue
	HALJSON400   *Error
	HALJSON403   *Error
}

// Status returns HTTPResponse.Status
func (r CreateAIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewAIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Issue
	HALJSON400   *Error
	HALJSON403   *Error
}

// Status returns HTTPResponse.Status
func (r PreviewAIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewAIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Issue
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r RetrieveAIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReviseAnIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Issue
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r ReviseAnIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReviseAnIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelAScheduledIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Issue
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r CancelAScheduledIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelAScheduledIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *UpdateExpansionaryPagedArray
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r GetAllUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON201   *UpdateExpansionary
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r CreateAUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PreviewAUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *UpdateExpansionary
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r PreviewAUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PreviewAUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *UpdateExpansionary
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r RetrieveAUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReviseAnUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *UpdateExpansionary
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r ReviseAnUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReviseAnUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllMetricProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *MetricProviderPagedArray
	HALJSON403   *Error
}

// Status returns HTTPResponse.Status
func (r GetAllMetricProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllMetricProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAMetricProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON201   *MetricProvider
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r CreateAMetricProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAMetricProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAMetricProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r DeleteAMetricProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAMetricProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAMetricProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *MetricProvider
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r RetrieveAMetricProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAMetricProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAMetricProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *MetricProvider
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAMetricProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAMetricProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RetrieveAWatchdogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Watchdog
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r RetrieveAWatchdogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RetrieveAWatchdogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAWatchdogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Watchdog
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAWatchdogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAWatchdogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertAWatchdogsServiceTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	HALJSON200   *Watchdog
	HALJSON400   *Error
	HALJSON403   *Error
	HALJSON404   *Error
}

// Status returns HTTPResponse.Status
func (r ConvertAWatchdogsServiceTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertAWatchdogsServiceTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllComponentsWithResponse request returning *GetAllComponentsResponse
func (c *ClientWithResponses) GetAllComponentsWithResponse(ctx context.Context, params *GetAllComponentsParams, reqEditors ...RequestEditorFn) (*GetAllComponentsResponse, error) {
	rsp, err := c.GetAllComponents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllComponentsResponse(rsp)
}

// CreateAComponentWithBodyWithResponse request with arbitrary body returning *CreateAComponentResponse
func (c *ClientWithResponses) CreateAComponentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAComponentResponse, error) {
	rsp, err := c.CreateAComponentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAComponentResponse(rsp)
}

func (c *ClientWithResponses) CreateAComponentWithResponse(ctx context.Context, body CreateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAComponentResponse, error) {
	rsp, err := c.CreateAComponent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAComponentResponse(rsp)
}

// DeleteAComponentWithResponse request returning *DeleteAComponentResponse
func (c *ClientWithResponses) DeleteAComponentWithResponse(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*DeleteAComponentResponse, error) {
	rsp, err := c.DeleteAComponent(ctx, componentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAComponentResponse(rsp)
}

// RetrieveAComponentWithResponse request returning *RetrieveAComponentResponse
func (c *ClientWithResponses) RetrieveAComponentWithResponse(ctx context.Context, componentId string, reqEditors ...RequestEditorFn) (*RetrieveAComponentResponse, error) {
	rsp, err := c.RetrieveAComponent(ctx, componentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAComponentResponse(rsp)
}

// UpdateAComponentWithBodyWithResponse request with arbitrary body returning *UpdateAComponentResponse
func (c *ClientWithResponses) UpdateAComponentWithBodyWithResponse(ctx context.Context, componentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAComponentResponse, error) {
	rsp, err := c.UpdateAComponentWithBody(ctx, componentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAComponentResponse(rsp)
}

func (c *ClientWithResponses) UpdateAComponentWithResponse(ctx context.Context, componentId string, body UpdateAComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAComponentResponse, error) {
	rsp, err := c.UpdateAComponent(ctx, componentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAComponentResponse(rsp)
}

// GetAllGroupsWithResponse request returning *GetAllGroupsResponse
func (c *ClientWithResponses) GetAllGroupsWithResponse(ctx context.Context, params *GetAllGroupsParams, reqEditors ...RequestEditorFn) (*GetAllGroupsResponse, error) {
	rsp, err := c.GetAllGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllGroupsResponse(rsp)
}

// CreateAGroupWithBodyWithResponse request with arbitrary body returning *CreateAGroupResponse
func (c *ClientWithResponses) CreateAGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAGroupResponse, error) {
	rsp, err := c.CreateAGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateAGroupWithResponse(ctx context.Context, body CreateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAGroupResponse, error) {
	rsp, err := c.CreateAGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAGroupResponse(rsp)
}

// DeleteAGroupWithResponse request returning *DeleteAGroupResponse
func (c *ClientWithResponses) DeleteAGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteAGroupResponse, error) {
	rsp, err := c.DeleteAGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAGroupResponse(rsp)
}

// RetrieveAGroupWithResponse request returning *RetrieveAGroupResponse
func (c *ClientWithResponses) RetrieveAGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*RetrieveAGroupResponse, error) {
	rsp, err := c.RetrieveAGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAGroupResponse(rsp)
}

// UpdateAGroupWithBodyWithResponse request with arbitrary body returning *UpdateAGroupResponse
func (c *ClientWithResponses) UpdateAGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAGroupResponse, error) {
	rsp, err := c.UpdateAGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateAGroupWithResponse(ctx context.Context, groupId string, body UpdateAGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAGroupResponse, error) {
	rsp, err := c.UpdateAGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAGroupResponse(rsp)
}

// ReorderAGroupsComponentsWithBodyWithResponse request with arbitrary body returning *ReorderAGroupsComponentsResponse
func (c *ClientWithResponses) ReorderAGroupsComponentsWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReorderAGroupsComponentsResponse, error) {
	rsp, err := c.ReorderAGroupsComponentsWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReorderAGroupsComponentsResponse(rsp)
}

func (c *ClientWithResponses) ReorderAGroupsComponentsWithResponse(ctx context.Context, groupId string, body ReorderAGroupsComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReorderAGroupsComponentsResponse, error) {
	rsp, err := c.ReorderAGroupsComponents(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReorderAGroupsComponentsResponse(rsp)
}

// GetAllIssueTemplatesWithResponse request returning *GetAllIssueTemplatesResponse
func (c *ClientWithResponses) GetAllIssueTemplatesWithResponse(ctx context.Context, params *GetAllIssueTemplatesParams, reqEditors ...RequestEditorFn) (*GetAllIssueTemplatesResponse, error) {
	rsp, err := c.GetAllIssueTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllIssueTemplatesResponse(rsp)
}

// CreateAIssueTemplateWithBodyWithResponse request with arbitrary body returning *CreateAIssueTemplateResponse
func (c *ClientWithResponses) CreateAIssueTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAIssueTemplateResponse, error) {
	rsp, err := c.CreateAIssueTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAIssueTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateAIssueTemplateWithResponse(ctx context.Context, body CreateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAIssueTemplateResponse, error) {
	rsp, err := c.CreateAIssueTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAIssueTemplateResponse(rsp)
}

// DeleteAIssueTemplateWithResponse request returning *DeleteAIssueTemplateResponse
func (c *ClientWithResponses) DeleteAIssueTemplateWithResponse(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*DeleteAIssueTemplateResponse, error) {
	rsp, err := c.DeleteAIssueTemplate(ctx, issueTemplateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAIssueTemplateResponse(rsp)
}

// RetrieveAIssueTemplateWithResponse request returning *RetrieveAIssueTemplateResponse
func (c *ClientWithResponses) RetrieveAIssueTemplateWithResponse(ctx context.Context, issueTemplateId string, reqEditors ...RequestEditorFn) (*RetrieveAIssueTemplateResponse, error) {
	rsp, err := c.RetrieveAIssueTemplate(ctx, issueTemplateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAIssueTemplateResponse(rsp)
}

// UpdateAIssueTemplateWithBodyWithResponse request with arbitrary body returning *UpdateAIssueTemplateResponse
func (c *ClientWithResponses) UpdateAIssueTemplateWithBodyWithResponse(ctx context.Context, issueTemplateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAIssueTemplateResponse, error) {
	rsp, err := c.UpdateAIssueTemplateWithBody(ctx, issueTemplateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAIssueTemplateResponse(rsp)
}

func (c *ClientWithResponses) UpdateAIssueTemplateWithResponse(ctx context.Context, issueTemplateId string, body UpdateAIssueTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAIssueTemplateResponse, error) {
	rsp, err := c.UpdateAIssueTemplate(ctx, issueTemplateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAIssueTemplateResponse(rsp)
}

// GetAllIssuesWithResponse request returning *GetAllIssuesResponse
func (c *ClientWithResponses) GetAllIssuesWithResponse(ctx context.Context, params *GetAllIssuesParams, reqEditors ...RequestEditorFn) (*GetAllIssuesResponse, error) {
	rsp, err := c.GetAllIssues(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllIssuesResponse(rsp)
}

// CreateAIssueWithBodyWithResponse request with arbitrary body returning *CreateAIssueResponse
func (c *ClientWithResponses) CreateAIssueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAIssueResponse, error) {
	rsp, err := c.CreateAIssueWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAIssueResponse(rsp)
}

func (c *ClientWithResponses) CreateAIssueWithResponse(ctx context.Context, body CreateAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAIssueResponse, error) {
	rsp, err := c.CreateAIssue(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAIssueResponse(rsp)
}

// PreviewAIssueWithBodyWithResponse request with arbitrary body returning *PreviewAIssueResponse
func (c *ClientWithResponses) PreviewAIssueWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewAIssueResponse, error) {
	rsp, err := c.PreviewAIssueWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewAIssueResponse(rsp)
}

func (c *ClientWithResponses) PreviewAIssueWithResponse(ctx context.Context, body PreviewAIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewAIssueResponse, error) {
	rsp, err := c.PreviewAIssue(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewAIssueResponse(rsp)
}

// DeleteAIssueWithResponse request returning *DeleteAIssueResponse
func (c *ClientWithResponses) DeleteAIssueWithResponse(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*DeleteAIssueResponse, error) {
	rsp, err := c.DeleteAIssue(ctx, issueId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAIssueResponse(rsp)
}

// RetrieveAIssueWithResponse request returning *RetrieveAIssueResponse
func (c *ClientWithResponses) RetrieveAIssueWithResponse(ctx context.Context, issueId string, reqEditors ...RequestEditorFn) (*RetrieveAIssueResponse, error) {
	rsp, err := c.RetrieveAIssue(ctx, issueId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAIssueResponse(rsp)
}

// ReviseAnIssueWithBodyWithResponse request with arbitrary body returning *ReviseAnIssueResponse
func (c *ClientWithResponses) ReviseAnIssueWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReviseAnIssueResponse, error) {
	rsp, err := c.ReviseAnIssueWithBody(ctx, issueId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviseAnIssueResponse(rsp)
}

func (c *ClientWithResponses) ReviseAnIssueWithResponse(ctx context.Context, issueId string, body ReviseAnIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*ReviseAnIssueResponse, error) {
	rsp, err := c.ReviseAnIssue(ctx, issueId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviseAnIssueResponse(rsp)
}

// CancelAScheduledIssueWithBodyWithResponse request with arbitrary body returning *CancelAScheduledIssueResponse
func (c *ClientWithResponses) CancelAScheduledIssueWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CancelAScheduledIssueResponse, error) {
	rsp, err := c.CancelAScheduledIssueWithBody(ctx, issueId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelAScheduledIssueResponse(rsp)
}

func (c *ClientWithResponses) CancelAScheduledIssueWithResponse(ctx context.Context, issueId string, body CancelAScheduledIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*CancelAScheduledIssueResponse, error) {
	rsp, err := c.CancelAScheduledIssue(ctx, issueId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCancelAScheduledIssueResponse(rsp)
}

// GetAllUpdatesWithResponse request returning *GetAllUpdatesResponse
func (c *ClientWithResponses) GetAllUpdatesWithResponse(ctx context.Context, issueId string, params *GetAllUpdatesParams, reqEditors ...RequestEditorFn) (*GetAllUpdatesResponse, error) {
	rsp, err := c.GetAllUpdates(ctx, issueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllUpdatesResponse(rsp)
}

// CreateAUpdateWithBodyWithResponse request with arbitrary body returning *CreateAUpdateResponse
func (c *ClientWithResponses) CreateAUpdateWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAUpdateResponse, error) {
	rsp, err := c.CreateAUpdateWithBody(ctx, issueId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAUpdateResponse(rsp)
}

func (c *ClientWithResponses) CreateAUpdateWithResponse(ctx context.Context, issueId string, body CreateAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAUpdateResponse, error) {
	rsp, err := c.CreateAUpdate(ctx, issueId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAUpdateResponse(rsp)
}

// PreviewAUpdateWithBodyWithResponse request with arbitrary body returning *PreviewAUpdateResponse
func (c *ClientWithResponses) PreviewAUpdateWithBodyWithResponse(ctx context.Context, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PreviewAUpdateResponse, error) {
	rsp, err := c.PreviewAUpdateWithBody(ctx, issueId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewAUpdateResponse(rsp)
}

func (c *ClientWithResponses) PreviewAUpdateWithResponse(ctx context.Context, issueId string, body PreviewAUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PreviewAUpdateResponse, error) {
	rsp, err := c.PreviewAUpdate(ctx, issueId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePreviewAUpdateResponse(rsp)
}

// DeleteAUpdateWithResponse request returning *DeleteAUpdateResponse
func (c *ClientWithResponses) DeleteAUpdateWithResponse(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*DeleteAUpdateResponse, error) {
	rsp, err := c.DeleteAUpdate(ctx, issueId, updateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAUpdateResponse(rsp)
}

// RetrieveAUpdateWithResponse request returning *RetrieveAUpdateResponse
func (c *ClientWithResponses) RetrieveAUpdateWithResponse(ctx context.Context, issueId string, updateId string, reqEditors ...RequestEditorFn) (*RetrieveAUpdateResponse, error) {
	rsp, err := c.RetrieveAUpdate(ctx, issueId, updateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAUpdateResponse(rsp)
}

// ReviseAnUpdateWithBodyWithResponse request with arbitrary body returning *ReviseAnUpdateResponse
func (c *ClientWithResponses) ReviseAnUpdateWithBodyWithResponse(ctx context.Context, issueId string, updateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReviseAnUpdateResponse, error) {
	rsp, err := c.ReviseAnUpdateWithBody(ctx, issueId, updateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviseAnUpdateResponse(rsp)
}

func (c *ClientWithResponses) ReviseAnUpdateWithResponse(ctx context.Context, issueId string, updateId string, body ReviseAnUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReviseAnUpdateResponse, error) {
	rsp, err := c.ReviseAnUpdate(ctx, issueId, updateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReviseAnUpdateResponse(rsp)
}

// GetAllMetricProvidersWithResponse request returning *GetAllMetricProvidersResponse
func (c *ClientWithResponses) GetAllMetricProvidersWithResponse(ctx context.Context, params *GetAllMetricProvidersParams, reqEditors ...RequestEditorFn) (*GetAllMetricProvidersResponse, error) {
	rsp, err := c.GetAllMetricProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllMetricProvidersResponse(rsp)
}

// CreateAMetricProviderWithBodyWithResponse request with arbitrary body returning *CreateAMetricProviderResponse
func (c *ClientWithResponses) CreateAMetricProviderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAMetricProviderResponse, error) {
	rsp, err := c.CreateAMetricProviderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAMetricProviderResponse(rsp)
}

func (c *ClientWithResponses) CreateAMetricProviderWithResponse(ctx context.Context, body CreateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAMetricProviderResponse, error) {
	rsp, err := c.CreateAMetricProvider(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAMetricProviderResponse(rsp)
}

// DeleteAMetricProviderWithResponse request returning *DeleteAMetricProviderResponse
func (c *ClientWithResponses) DeleteAMetricProviderWithResponse(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*DeleteAMetricProviderResponse, error) {
	rsp, err := c.DeleteAMetricProvider(ctx, metricProviderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAMetricProviderResponse(rsp)
}

// RetrieveAMetricProviderWithResponse request returning *RetrieveAMetricProviderResponse
func (c *ClientWithResponses) RetrieveAMetricProviderWithResponse(ctx context.Context, metricProviderId string, reqEditors ...RequestEditorFn) (*RetrieveAMetricProviderResponse, error) {
	rsp, err := c.RetrieveAMetricProvider(ctx, metricProviderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAMetricProviderResponse(rsp)
}

// UpdateAMetricProviderWithBodyWithResponse request with arbitrary body returning *UpdateAMetricProviderResponse
func (c *ClientWithResponses) UpdateAMetricProviderWithBodyWithResponse(ctx context.Context, metricProviderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAMetricProviderResponse, error) {
	rsp, err := c.UpdateAMetricProviderWithBody(ctx, metricProviderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAMetricProviderResponse(rsp)
}

func (c *ClientWithResponses) UpdateAMetricProviderWithResponse(ctx context.Context, metricProviderId string, body UpdateAMetricProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAMetricProviderResponse, error) {
	rsp, err := c.UpdateAMetricProvider(ctx, metricProviderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAMetricProviderResponse(rsp)
}

// RetrieveAWatchdogWithResponse request returning *RetrieveAWatchdogResponse
func (c *ClientWithResponses) RetrieveAWatchdogWithResponse(ctx context.Context, watchdogId string, reqEditors ...RequestEditorFn) (*RetrieveAWatchdogResponse, error) {
	rsp, err := c.RetrieveAWatchdog(ctx, watchdogId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRetrieveAWatchdogResponse(rsp)
}

// UpdateAWatchdogWithBodyWithResponse request with arbitrary body returning *UpdateAWatchdogResponse
func (c *ClientWithResponses) UpdateAWatchdogWithBodyWithResponse(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAWatchdogResponse, error) {
	rsp, err := c.UpdateAWatchdogWithBody(ctx, watchdogId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAWatchdogResponse(rsp)
}

func (c *ClientWithResponses) UpdateAWatchdogWithResponse(ctx context.Context, watchdogId string, body UpdateAWatchdogJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAWatchdogResponse, error) {
	rsp, err := c.UpdateAWatchdog(ctx, watchdogId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAWatchdogResponse(rsp)
}

// ConvertAWatchdogsServiceTypeWithBodyWithResponse request with arbitrary body returning *ConvertAWatchdogsServiceTypeResponse
func (c *ClientWithResponses) ConvertAWatchdogsServiceTypeWithBodyWithResponse(ctx context.Context, watchdogId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ConvertAWatchdogsServiceTypeResponse, error) {
	rsp, err := c.ConvertAWatchdogsServiceTypeWithBody(ctx, watchdogId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertAWatchdogsServiceTypeResponse(rsp)
}

func (c *ClientWithResponses) ConvertAWatchdogsServiceTypeWithResponse(ctx context.Context, watchdogId string, body ConvertAWatchdogsServiceTypeJSONRequestBody, reqEditors ...RequestEditorFn) (*ConvertAWatchdogsServiceTypeResponse, error) {
	rsp, err := c.ConvertAWatchdogsServiceType(ctx, watchdogId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertAWatchdogsServiceTypeResponse(rsp)
}

// ParseGetAllComponentsResponse parses an HTTP response from a GetAllComponentsWithResponse call
func ParseGetAllComponentsResponse(rsp *http.Response) (*GetAllComponentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllComponentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComponentExpansionaryPagedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	}

	return response, nil
}

// ParseCreateAComponentResponse parses an HTTP response from a CreateAComponentWithResponse call
func ParseCreateAComponentResponse(rsp *http.Response) (*CreateAComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ComponentExpansionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	}

	return response, nil
}

// ParseDeleteAComponentResponse parses an HTTP response from a DeleteAComponentWithResponse call
func ParseDeleteAComponentResponse(rsp *http.Response) (*DeleteAComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseRetrieveAComponentResponse parses an HTTP response from a RetrieveAComponentWithResponse call
func ParseRetrieveAComponentResponse(rsp *http.Response) (*RetrieveAComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComponentExpansionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAComponentResponse parses an HTTP response from a UpdateAComponentWithResponse call
func ParseUpdateAComponentResponse(rsp *http.Response) (*UpdateAComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComponentExpansionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseGetAllGroupsResponse parses an HTTP response from a GetAllGroupsWithResponse call
func ParseGetAllGroupsResponse(rsp *http.Response) (*GetAllGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupPagedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	}

	return response, nil
}

// ParseCreateAGroupResponse parses an HTTP response from a CreateAGroupWithResponse call
func ParseCreateAGroupResponse(rsp *http.Response) (*CreateAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	}

	return response, nil
}

// ParseDeleteAGroupResponse parses an HTTP response from a DeleteAGroupWithResponse call
func ParseDeleteAGroupResponse(rsp *http.Response) (*DeleteAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseRetrieveAGroupResponse parses an HTTP response from a RetrieveAGroupWithResponse call
func ParseRetrieveAGroupResponse(rsp *http.Response) (*RetrieveAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAGroupResponse parses an HTTP response from a UpdateAGroupWithResponse call
func ParseUpdateAGroupResponse(rsp *http.Response) (*UpdateAGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseReorderAGroupsComponentsResponse parses an HTTP response from a ReorderAGroupsComponentsWithResponse call
func ParseReorderAGroupsComponentsResponse(rsp *http.Response) (*ReorderAGroupsComponentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReorderAGroupsComponentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseGetAllIssueTemplatesResponse parses an HTTP response from a GetAllIssueTemplatesWithResponse call
func ParseGetAllIssueTemplatesResponse(rsp *http.Response) (*GetAllIssueTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllIssueTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueTemplatePagedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	}

	return response, nil
}

// ParseCreateAIssueTemplateResponse parses an HTTP response from a CreateAIssueTemplateWithResponse call
func ParseCreateAIssueTemplateResponse(rsp *http.Response) (*CreateAIssueTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAIssueTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IssueTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	}

	return response, nil
}

// ParseDeleteAIssueTemplateResponse parses an HTTP response from a DeleteAIssueTemplateWithResponse call
func ParseDeleteAIssueTemplateResponse(rsp *http.Response) (*DeleteAIssueTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAIssueTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseRetrieveAIssueTemplateResponse parses an HTTP response from a RetrieveAIssueTemplateWithResponse call
func ParseRetrieveAIssueTemplateResponse(rsp *http.Response) (*RetrieveAIssueTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAIssueTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAIssueTemplateResponse parses an HTTP response from a UpdateAIssueTemplateWithResponse call
func ParseUpdateAIssueTemplateResponse(rsp *http.Response) (*UpdateAIssueTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAIssueTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseGetAllIssuesResponse parses an HTTP response from a GetAllIssuesWithResponse call
func ParseGetAllIssuesResponse(rsp *http.Response) (*GetAllIssuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllIssuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssuePagedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	}

	return response, nil
}

// ParseCreateAIssueResponse parses an HTTP response from a CreateAIssueWithResponse call
func ParseCreateAIssueResponse(rsp *http.Response) (*CreateAIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	}

	return response, nil
}

// ParsePreviewAIssueResponse parses an HTTP response from a PreviewAIssueWithResponse call
func ParsePreviewAIssueResponse(rsp *http.Response) (*PreviewAIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewAIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	}

	return response, nil
}

// ParseDeleteAIssueResponse parses an HTTP response from a DeleteAIssueWithResponse call
func ParseDeleteAIssueResponse(rsp *http.Response) (*DeleteAIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseRetrieveAIssueResponse parses an HTTP response from a RetrieveAIssueWithResponse call
func ParseRetrieveAIssueResponse(rsp *http.Response) (*RetrieveAIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseReviseAnIssueResponse parses an HTTP response from a ReviseAnIssueWithResponse call
func ParseReviseAnIssueResponse(rsp *http.Response) (*ReviseAnIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReviseAnIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseCancelAScheduledIssueResponse parses an HTTP response from a CancelAScheduledIssueWithResponse call
func ParseCancelAScheduledIssueResponse(rsp *http.Response) (*CancelAScheduledIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CancelAScheduledIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseGetAllUpdatesResponse parses an HTTP response from a GetAllUpdatesWithResponse call
func ParseGetAllUpdatesResponse(rsp *http.Response) (*GetAllUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateExpansionaryPagedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseCreateAUpdateResponse parses an HTTP response from a CreateAUpdateWithResponse call
func ParseCreateAUpdateResponse(rsp *http.Response) (*CreateAUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UpdateExpansionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParsePreviewAUpdateResponse parses an HTTP response from a PreviewAUpdateWithResponse call
func ParsePreviewAUpdateResponse(rsp *http.Response) (*PreviewAUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PreviewAUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateExpansionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAUpdateResponse parses an HTTP response from a DeleteAUpdateWithResponse call
func ParseDeleteAUpdateResponse(rsp *http.Response) (*DeleteAUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseRetrieveAUpdateResponse parses an HTTP response from a RetrieveAUpdateWithResponse call
func ParseRetrieveAUpdateResponse(rsp *http.Response) (*RetrieveAUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateExpansionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseReviseAnUpdateResponse parses an HTTP response from a ReviseAnUpdateWithResponse call
func ParseReviseAnUpdateResponse(rsp *http.Response) (*ReviseAnUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReviseAnUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateExpansionary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseGetAllMetricProvidersResponse parses an HTTP response from a GetAllMetricProvidersWithResponse call
func ParseGetAllMetricProvidersResponse(rsp *http.Response) (*GetAllMetricProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllMetricProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricProviderPagedArray
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	}

	return response, nil
}

// ParseCreateAMetricProviderResponse parses an HTTP response from a CreateAMetricProviderWithResponse call
func ParseCreateAMetricProviderResponse(rsp *http.Response) (*CreateAMetricProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAMetricProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MetricProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAMetricProviderResponse parses an HTTP response from a DeleteAMetricProviderWithResponse call
func ParseDeleteAMetricProviderResponse(rsp *http.Response) (*DeleteAMetricProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAMetricProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseRetrieveAMetricProviderResponse parses an HTTP response from a RetrieveAMetricProviderWithResponse call
func ParseRetrieveAMetricProviderResponse(rsp *http.Response) (*RetrieveAMetricProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAMetricProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAMetricProviderResponse parses an HTTP response from a UpdateAMetricProviderWithResponse call
func ParseUpdateAMetricProviderResponse(rsp *http.Response) (*UpdateAMetricProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAMetricProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseRetrieveAWatchdogResponse parses an HTTP response from a RetrieveAWatchdogWithResponse call
func ParseRetrieveAWatchdogResponse(rsp *http.Response) (*RetrieveAWatchdogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RetrieveAWatchdogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Watchdog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAWatchdogResponse parses an HTTP response from a UpdateAWatchdogWithResponse call
func ParseUpdateAWatchdogResponse(rsp *http.Response) (*UpdateAWatchdogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAWatchdogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Watchdog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}

// ParseConvertAWatchdogsServiceTypeResponse parses an HTTP response from a ConvertAWatchdogsServiceTypeWithResponse call
func ParseConvertAWatchdogsServiceTypeResponse(rsp *http.Response) (*ConvertAWatchdogsServiceTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertAWatchdogsServiceTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Watchdog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.HALJSON404 = &dest

	}

	return response, nil
}
